<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Lean4函数式编程基础与应用</title>
    <link href="/lean/lean-basic/"/>
    <url>/lean/lean-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="lean4与定理证明">Lean4与定理证明</h1><h2 id="简介">1 简介</h2><p><strong>形式验证（FormalVerification）</strong>是指使用逻辑和计算方法来验证用精确的数学术语表达的命题。这包括普通的数学定理，以及硬件或软件、网络协议、机械和混合系统中的形式命题。</p><p>在实践中，验证数学命题和验证系统的正确性之间很类似：形式验证用数学术语描述硬件和软件系统，在此基础上验证其命题的正确性，这就像定理证明的过程。</p><p>二十世纪的逻辑学发展表明，绝大多数传统证明方法可以化为若干基础系统中的一小套公理和规则。有了这种简化，计算机能以两种方式帮助建立命题：</p><p>1）<strong>自动定理证明（Automated theoremproving）</strong>：为定理寻找一个证明</p><p>2）<strong>交互式定理证明器（Interactive theoremproving）</strong>：验证一个所谓的证明是正确的。</p><p>Lean旨在融合交互式和自动定理证明，它将自动化工具和方法置于一个支持用户交互和构建完整公理化证明的框架中。它的目标是支持数学推理和复杂系统的推理，并验证这两个领域的命题。</p><h2 id="基础语法">2 基础语法</h2><h3 id="定义与求值">2.1 定义与求值</h3><ol type="1"><li>定义：</li></ol><p><code>def</code> 关键字声明工作环境中的新常量与函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lean">/- 定义一些常数 -/<br><br>def m : Nat := 1       -- m 是自然数<br>def n : Nat := 0<br>def b1 : Bool := true  -- b1 是布尔型<br>def b2 : Bool := false<br><br>/- 定义一些函数 -/<br>def f (n : Nat) : String := toString n<br>def g (s : String) : Bool := s.length &gt; 0<br></code></pre></td></tr></table></figure><p><code>fun</code> (或<code>λ</code>)关键字用于从给定表达式创建函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lean">#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat<br>#check λ (x : Nat) =&gt; x + 5     -- λ 和 fun 是同义词<br>#check fun x : Nat =&gt; x + 5     -- 同上<br>#check λ x : Nat =&gt; x + 5       -- 同上<br><br>#eval (λ x : Nat =&gt; x + 5) 10    -- 15<br></code></pre></td></tr></table></figure><p><code>let</code> 关键字用于引入局部定义。</p><p>表达式 <code>let a := t1; t2</code> 定义等价于把 <code>t2</code>中所有的 <code>a</code> 替换成 <code>t1</code> 的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lean">#check let y := 2 + 2; y * y   -- Nat<br>#eval  let y := 2 + 2; y * y   -- 16<br><br>def twice_double (x : Nat) : Nat :=<br>  let y := x + x; y * y<br><br>#eval twice_double 2   -- 16<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>求值与检查：</li></ol><p>以井号(#)开头的辅助命令，用于向系统询问信息。</p><p><code>#check</code> 命令要求 Lean 给出它的类型，</p><p><code>#eval</code>命令让 Lean计算给出的表达式。你应该试试自己声明一些常量和检查一些表达式的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs lean">/- 检查类型 -/<br><br>#check m            -- 输出: Nat<br>#check n<br>#check n + 0        -- Nat<br>#check m * (n + 0)  -- Nat<br>#check b1           -- Bool<br>#check b1 &amp;&amp; b2     -- &quot;&amp;&amp;&quot; is the Boolean and<br>#check b1 || b2     -- Boolean or<br>#check true         -- Boolean &quot;true&quot;<br><br>#check Nat.succ     -- Nat → Nat<br>#check (0, 1)       -- Nat × Nat<br>#check Nat.add      -- Nat → Nat → Nat<br><br>#check Nat.succ 2   -- Nat<br>#check Nat.add 3    -- Nat → Nat<br>#check Nat.add 5 2  -- Nat<br>#check (5, 9).1     -- Nat<br>#check (5, 9).2     -- Nat<br><br>/- 求值 -/<br><br>#eval 5 * 4         -- 20<br>#eval m + 2         -- 3<br>#eval b1 &amp;&amp; b2      -- false<br><br>#eval Nat.succ 2   -- 3<br>#eval Nat.add 5 2  -- 7<br>#eval (5, 9).1     -- 5<br>#eval (5, 9).2     -- 9<br></code></pre></td></tr></table></figure><p>在Lean中，基本类型（例如 <code>Nat</code> 和 <code>Bool</code>）本身也是对象，因此也具有类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lean">#check Nat               -- Type<br>#check Bool              -- Type<br>#check Nat → Bool        -- Type<br>#check Nat × Bool        -- Type<br></code></pre></td></tr></table></figure><h3 id="小节与命名空间">2.2 小节与命名空间</h3><ol type="1"><li>小节：</li></ol><p>当变量/函数的定义十分复杂时，我们可以采取一些简化措施：</p><p><code>Variable</code>可用于声明某个变量类型，而不用给出具体值，通常用于简化<code>def</code>的表达。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (α β γ : Type)<br>variable (g : β → γ) (f : α → β) (h : α → α)<br>variable (x : α)<br><br>def compose := g (f x)<br>def doTwice := h (h x)<br>def doThrice := h (h (h x))<br></code></pre></td></tr></table></figure><p>但<code>variable</code>的作用范围是全局，因此我们需要使用<code>Section</code>来限制变量的作用范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lean">section useful<br>  variable (α β γ : Type)<br>  variable (g : β → γ) (f : α → β) (h : α → α)<br>  variable (x : α)<br><br>  def compose := g (f x)<br>  def doTwice := h (h x)<br>  def doThrice := h (h (h x))<br>end useful<br></code></pre></td></tr></table></figure><p>注意，在<code>Section</code>只限制<code>variable</code>，其他定义，如<code>def</code>依然是全局的。</p><ol start="2" type="1"><li>命名空间：</li></ol><p>我们也可以使用<code>namespace</code>关键字来完全分割不同的定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lean">namespace Foo<br>  def a : Nat := 5<br>  def f (x : Nat) : Nat := x + 7<br><br>  def fa : Nat := f a<br>  def ffa : Nat := f (f a)<br>end Foo<br><br>-- #check a  -- error<br>-- #check f  -- error<br>#check Foo.a<br>#check Foo.f<br>#check Foo.fa<br>#check Foo.ffa<br><br></code></pre></td></tr></table></figure><p>我们使用<code>open</code>来打开命名空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lean">open Foo<br><br>#check a<br>#check f<br>#check fa<br>#check Foo.fa<br></code></pre></td></tr></table></figure><p>命名空间允许嵌套</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lean">namespace Foo<br>  def a : Nat := 5<br>  def f (x : Nat) : Nat := x + 7<br><br>  def fa : Nat := f a<br><br>  namespace Bar<br>    def ffa : Nat := f (f a)<br><br>    #check fa<br>    #check ffa<br>  end Bar<br><br>  #check fa<br>  #check Bar.ffa<br>end Foo<br><br>#check Foo.fa<br>#check Foo.Bar.ffa<br><br></code></pre></td></tr></table></figure><h3 id="结构体">2.3 结构体</h3><p>定义结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lean">structure Point where<br>  x : Float<br>  y : Float<br>deriving Repr<br>--最后一行的deriving Repr，可自动为该类型重载构造和显示函数<br></code></pre></td></tr></table></figure><p>创建结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lean">def origin : Point := &#123; x := 0.0, y := 0.0 &#125;<br>#eval origin<br>-- output: &#123; x := 0.000000, y := 0.000000 &#125;<br></code></pre></td></tr></table></figure><p>结构体作为函数参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lean">-- 两点相加<br>def addPoints (p1 : Point) (p2 : Point) : Point :=<br>  &#123; x := p1.x + p2.x, y := p1.y + p2.y &#125;<br>-- 两点距离<br>def distance (p1 : Point) (p2 : Point) : Float :=<br>  Float.sqrt (((p2.x - p1.x) ^ 2.0) + ((p2.y - p1.y) ^ 2.0))<br></code></pre></td></tr></table></figure><h3 id="归纳类型">2.4 归纳类型</h3><p>结构体使多个独立的数据块可以组合成一个连贯的整体，这种将一组值组合在一起的类型称为<strong>积类型（ProductType）</strong>。</p><p>由于无法选择/递归，积类型无法表示所有对象，例如"列表"的尾部可能依然是一个"列表"。</p><p>允许选择的类型称为<strong>和类型（SumType）</strong>，而可以包含自身实例的类型称为<strong>递归类型（RecursiveDatatype）</strong>。</p><p>递归和类型称为<strong>归纳类型（Inductive Datatype）</strong></p><ol type="1"><li>Bool是一个典型归纳类型：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lean">inductive Bool where<br>  | false : Bool<br>  | true : Bool<br></code></pre></td></tr></table></figure><p>类似地，在C#中， Bool 定义如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bool</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">True</span> : <span class="hljs-title">Bool</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">False</span> : <span class="hljs-title">Bool</span> &#123;&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>非负整数的类型 Nat 也是一个归纳数据类型：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lean">inductive Nat where<br>  | zero : Nat<br>  | succ (n : Nat) : Nat<br></code></pre></td></tr></table></figure><p>类似地，在C#中，Nat 定义如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Nat</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Zero</span> : <span class="hljs-title">Nat</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Succ</span> : <span class="hljs-title">Nat</span> &#123;<br>  <span class="hljs-keyword">public</span> Nat n;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Succ</span>(<span class="hljs-params">Nat pred</span>)</span> &#123;<br>    n = pred;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模式匹配与递归函数">2.5 模式匹配与递归函数</h3><ol type="1"><li><code>isZero</code>: 判断给定Nat是否为Nat.zero</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lean">def isZero (n : Nat) : Bool :=<br>  match n with<br>  | Nat.zero =&gt; true<br>  | Nat.succ k =&gt; false<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><code>pred</code>：求当前实例的前驱</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lean">def pred (n : Nat) : Nat :=<br>  match n with<br>  | Nat.zero =&gt; Nat.zero<br>  | Nat.succ k =&gt; k<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>even</code>：判断Nat是否为偶数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lean">def even (n : Nat) : Bool :=<br>  match n with<br>  | Nat.zero =&gt; true<br>  | Nat.succ k =&gt; not (even k) <br></code></pre></td></tr></table></figure><h3 id="主函数">2.6 主函数</h3><p>hello.lean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lean">def main : IO Unit := IO.println &quot;Hello, world!&quot;<br></code></pre></td></tr></table></figure><p>run</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lean">lean --run hello.lean<br></code></pre></td></tr></table></figure><p>当使用 --run 选项调用 Lean 时，它会调用程序的 main定义。对于不从命令行接受参数的程序，main 的类型应该是 IO Unit。</p><p>然而，大多数有用的程序除了产生输出外还要接受输入。以下程序向用户询问他们的姓名，然后向他们问好：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lean">def main : IO Unit := do<br>  let stdin ← IO.getStdin<br>  let stdout ← IO.getStdout<br><br>  stdout.putStrLn &quot;How would you like to be addressed?&quot;<br>  let input ← stdin.getLine<br>  let name := input.dropRightWhile Char.isWhitespace<br><br>  stdout.putStrLn s!&quot;Hello, &#123;name&#125;!&quot;<br></code></pre></td></tr></table></figure><p>在此程序中，main 函数由一个do代码块组成。这里用 let引入了局部变量。</p><p>如果用户回应 David，则与程序交互的会话会读取回应：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">How would you like to <span class="hljs-keyword">be </span><span class="hljs-keyword">addressed?</span><br><span class="hljs-keyword"></span>David<br>Hello, David!<br></code></pre></td></tr></table></figure><h2 id="命题与证明">3 命题与证明</h2><h3 id="命题即类型">3.1 命题即类型</h3><p><code>Prop</code>表示命题的构造子，是最小逻辑单元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lean">#check And     -- Prop → Prop → Prop<br>#check Or      -- Prop → Prop → Prop<br>#check Not     -- Prop → Prop<br>#check Implies -- Prop → Prop → Prop<br><br>variable (p q r : Prop)<br>#check And p q                      -- Prop<br>#check Or (And p q) r               -- Prop<br>#check Implies (And p q) (And q p)  -- Prop<br></code></pre></td></tr></table></figure><p>lean4以<strong>“命题即类型”</strong>为范式工作。命题是一种类型(<code>theorem</code>)，而证明是命题的项。</p><p>下面我们以两个简单样例介绍lean4中的命题定义与证明：</p><ol type="1"><li>现有两个条件p和q，显然可以推出p为结论。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable &#123;p q : Prop&#125;<br><br>theorem t1 : p → q → p := fun (hp : p) (hq : q) =&gt; hp<br></code></pre></td></tr></table></figure><p>这里，我们声明定理t1的类型为<code>p-&gt;q-&gt;p</code>,构造它的一种证明为 <code>fun (hp : p) (hq : q) =&gt; hp</code>。</p><p>同理，上面的这些定义也可以写作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable &#123;p q : Prop&#125;<br>theorem t1 : p → q → p := fun hp : p =&gt; fun hq : q =&gt; hp<br>-- 或<br>variable &#123;p q : Prop&#125;<br>theorem t1 (hp : p) (hq : q) : p := hp<br>-- 或<br>theorem t1 : ∀ &#123;p q : Prop&#125;, p → q → p := fun &#123;p q : Prop&#125; (hp : p) (hq : q) =&gt; hp<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>现有条件q-&gt;p和p-&gt;r, 可以得到结论r</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q r s : Prop)<br><br>theorem t2 (h₁ : q → r) (h₂ : p → q) : p → r :=<br>  fun h₃ : p =&gt;<br>  show r from h₁ (h₂ h₃)<br></code></pre></td></tr></table></figure><p>这里，<code>show r from xxx</code>显式地说明返回值为r。</p><h3 id="命题逻辑">3.2 命题逻辑</h3><p>Lean 定义了所有标准的逻辑连接词和符号。命题连接词有以下表示法:</p><table><thead><tr><th>Ascii</th><th>Unicode</th><th>编辑器缩写</th><th>定义</th></tr></thead><tbody><tr><td>True</td><td></td><td></td><td>True</td></tr><tr><td>False</td><td></td><td></td><td>False</td></tr><tr><td>Not</td><td>¬</td><td><code>\not</code>, <code>\neg</code></td><td>Not</td></tr><tr><td>/\</td><td>∧</td><td><code>\and</code></td><td>And</td></tr><tr><td>/</td><td>∨</td><td><code>\or</code></td><td>Or</td></tr><tr><td>-&gt;</td><td>→</td><td><code>\to</code>, <code>\r</code>, <code>\imp</code></td><td></td></tr><tr><td>&lt;-&gt;</td><td>↔︎</td><td><code>\iff</code>, <code>\lr</code></td><td>Iff</td></tr></tbody></table><ol type="1"><li>合取</li></ol><p>合取引入：表达式<code>And.intro h1 h2</code> 是 <code>p ∧ q</code>的证明，它使用了 <code>h1 : p</code> 和 <code>h2 : q</code> 的证明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q : Prop)<br><br>example (hp : p) (hq : q) : p ∧ q := And.intro hp hq<br>-- 或 <br>example (hp : p) (hq : q) : p ∧ q := ⟨hp, hq⟩  --匿名构造子表示法<br></code></pre></td></tr></table></figure><p>合取消去：表达式<code>And.left h</code> 从 <code>h : p ∧ q</code>建立了一个 <code>p</code> 的证明。类似地，<code>And.right h</code> 是<code>q</code> 的证明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q : Prop)<br><br>example (h : p ∧ q) : p := And.left h<br>example (h : p ∧ q) : q := And.right h<br>example (h : p ∧ q) : q ∧ p := ⟨h.right, h.left⟩<br></code></pre></td></tr></table></figure><p>这里，当给定 <code>h : p ∧ q</code>，我们可以写 <code>h.left</code>和 <code>h.right</code>来简写。</p><ol start="2" type="1"><li>析取</li></ol><p>左右析取（或）引入规则：表达式 <code>Or.intro_left q hp</code> 从证明<code>hp : p</code> 建立了 <code>p ∨ q</code> 的证明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q : Prop)<br>example (hp : p) : p ∨ q := Or.intro_left q hp<br>example (hq : q) : p ∨ q := Or.intro_right p hq<br>-- <br>example (hp : p) : p ∨ q := Or.inl hp<br>example (hq : q) : p ∨ q := Or.inr hq<br></code></pre></td></tr></table></figure><p>当<code>Or.intro_right</code> 和 <code>Or.intro_left</code>的第一个参数可以由 Lean 自动推断出来时，可以简化为 <code>Or.inr</code>和 <code>Or.inl</code>。</p><p>析取消去规则：表达式 <code>Or.elim hpq hpr hqr</code>接受三个论证，<code>hpq : p ∨ q</code>，<code>hpr : p → r</code> 和<code>hqr : q → r</code>，生成 <code>r</code> 的证明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q r : Prop)<br><br>example (h : p ∨ q) : q ∨ p :=<br>  Or.elim h (fun hp =&gt; Or.inr hp) (fun hq =&gt; Or.inl hq)<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>否定</li></ol><p>否定 <code>¬p</code> 真正的定义是 <code>p → False</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q : Prop)<br><br>example (hpq : p → q) (hnq : ¬q) : ¬p :=<br>  fun hp : p =&gt;<br>  show False from hnq (hpq hp)<br></code></pre></td></tr></table></figure><p><code>False</code> 只有一个消去规则<code>False.elim</code>，它表达了一个事实，即矛盾能导出一切（这个规则有时被称为<strong>爆炸原理</strong>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q : Prop)<br><br>example (hp : p) (hnp : ¬p) : q := False.elim (hnp hp)<br>-- 或<br>example (hp : p) (hnp : ¬p) : q := absurd hp hnp<br></code></pre></td></tr></table></figure><p>这种从相互矛盾的假设中推导出任意事实的模式，也可以用<code>absurd</code> 来表示。</p><ol start="4" type="1"><li>逻辑等价</li></ol><p>表达式 <code>Iff.intro h1 h2</code> 从 <code>h1 : p → q</code> 和<code>h2 : q → p</code> 生成了 <code>p ↔︎ q</code> 的证明。</p><p>表达式 <code>Iff.mp h</code> 从 <code>h : p ↔︎ q</code> 生成了<code>p → q</code> 的证明；表达式 <code>Iff.mpr h</code> 从<code>h : p ↔︎ q</code> 生成了 <code>q → p</code> 的证明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q : Prop)<br><br>theorem and_swap : p ∧ q ↔ q ∧ p :=<br>  Iff.intro<br>    (fun h : p ∧ q =&gt; show q ∧ p from And.intro (And.right h) (And.left h))<br>    (fun h : q ∧ p =&gt; show p ∧ q from And.intro (And.right h) (And.left h))<br><br>#check and_swap p q    -- p ∧ q ↔ q ∧ p<br><br>variable (h : p ∧ q)<br>example : q ∧ p := Iff.mp (and_swap p q) h<br></code></pre></td></tr></table></figure><p>我们也可以使用匿名构造子表示法简写如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q : Prop)<br><br>theorem and_swap : p ∧ q ↔ q ∧ p :=<br>  ⟨ fun h =&gt; ⟨h.right, h.left⟩, fun h =&gt; ⟨h.right, h.left⟩ ⟩<br><br>example (h : p ∧ q) : q ∧ p := (and_swap p q).mp h<br></code></pre></td></tr></table></figure><h3 id="辅助子目标">3.3 辅助子目标</h3><p>Lean 提供了一种帮助构造长证明的方法，即 <code>have</code>结构，它在证明中引入了一个辅助的子目标。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q : Prop)<br><br>example (h : p ∧ q) : q ∧ p :=<br>  have hp : p := h.left<br>  have hq : q := h.right<br>  show q ∧ p from And.intro <br></code></pre></td></tr></table></figure><p>表达式 <code>have h : p := s; t</code> 相当于<code>(fun (h : p) =&gt; t) s</code>。</p><p>换句话说，<code>s</code> 是 <code>p</code> 的证明，<code>t</code>是假设 <code>h : p</code> 的期望结论的证明。</p><h3 id="临时占位符">3.4 临时占位符</h3><p>在 Lean 中，<code>sorry</code>是一个特殊的占位符，用于临时"欺骗"类型检查器，让不完整的代码也能通过编译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (p q r : Prop)<br><br>--  ∧ 和 ∨ 的交换律<br>example : p ∧ q ↔ q ∧ p := sorry<br>example : p ∨ q ↔ q ∨ p := sorry<br><br>-- ∧ 和 ∨ 的结合律<br>example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry<br>example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry<br><br>-- 分配律<br>example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry<br>example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry<br></code></pre></td></tr></table></figure><h2 id="量词与等价">4 量词与等价</h2><h3 id="全称量词">4.1 全称量词</h3><p>以下两种写法在逻辑上完全等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lean">-- 写法1：定理参数<br>theorem theorem_param (x : A) (h : P x) : Q x := ...<br>-- 写法2：全称量词<br>theorem forall_version : ∀ (x : A), P x → Q x := ...<br></code></pre></td></tr></table></figure><p>事实上，写法1 是 写法2 的语法糖</p><h3 id="存在量词">4.2 存在量词</h3><p>存在量词引入规则：<code>Exists.intro (a : A) (h : P a)</code> 构造<code>∃ (x : A), P x</code>的证明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lean">example : ∃ x : Nat, x &gt; 0 :=<br>  have h : 1 &gt; 0 := Nat.zero_lt_succ 0<br>  Exists.intro 1 h<br><br>example (x : Nat) (h : x &gt; 0) : ∃ y, y &lt; x :=<br>  Exists.intro 0 (Nat.pos_of_gt h)  -- 需要把 x &gt; 0 转为 0 &lt; x<br><br>example (x y z : Nat) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=<br>  Exists.intro y (And.intro hxy hyz)<br></code></pre></td></tr></table></figure><h3 id="等价关系">4.3 等价关系</h3><p>等价关系的基本性质：反身性、对称性、传递性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lean">universe u<br><br>-- 通过告诉 Lean 不要插入隐参数(在这里显示为元变量)可以使输出更容易阅读。<br><br>#check @Eq.refl.&#123;u&#125;   -- @Eq.refl : ∀ &#123;α : Sort u&#125; (a : α), a = a<br>#check @Eq.symm.&#123;u&#125;   -- @Eq.symm : ∀ &#123;α : Sort u&#125; &#123;a b : α&#125;, a = b → b = a<br>#check @Eq.trans.&#123;u&#125;  -- @Eq.trans : ∀ &#123;α : Sort u&#125; &#123;a b c : α&#125;, a = b → b = c → a = c<br></code></pre></td></tr></table></figure><p>应用样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (α : Type) (a b c d : α)<br>variable (hab : a = b) (hcb : c = b) (hcd : c = d)<br><br>example : a = d :=<br>  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd<br></code></pre></td></tr></table></figure><p>此外，Lean 的库包含大量通用的等式，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (a b c : Nat)<br><br>example : a + 0 = a := Nat.add_zero a<br>example : 0 + a = a := Nat.zero_add a<br>example : a * 1 = a := Nat.mul_one a<br>example : 1 * a = a := Nat.one_mul a<br>example : a + b = b + a := Nat.add_comm a b<br>example : a + b + c = a + (b + c) := Nat.add_assoc a b c<br>example : a * b = b * a := Nat.mul_comm a b<br>example : a * b * c = a * (b * c) := Nat.mul_assoc a b c<br>example : a * (b + c) = a * b + a * c := Nat.mul_add a b c<br>example : a * (b + c) = a * b + a * c := Nat.left_distrib a b c<br>example : (a + b) * c = a * c + b * c := Nat.add_mul a b c<br>example : (a + b) * c = a * c + b * c := Nat.right_distrib a b c<br></code></pre></td></tr></table></figure><h2 id="证明策略">5 证明策略</h2><p>除了直接构造命题实例以外，Lean4还为我们提供了另一种证明命题方法，即<strong>策略（Tactic）</strong>。</p><p>一个证明项代表一个数学证明；策略是描述如何建立这样一个证明的命令或指令。</p><p>策略告诉 Lean如何构建证明。它们自然而然地支持增量式的证明书写，在这种写作方式中，你将分解一个证明，并一步步地实现目标。</p><h3 id="策略证明模式">5.1 策略证明模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=<br>  sorry<br></code></pre></td></tr></table></figure><p>在任何需要项的地方，Lean 允许我们插入一个<code>by &lt;tactics&gt;</code> 块，其中 <code>&lt;tactics&gt;</code>是一串命令，用分号或换行符分开。</p><p>你可以用下面这种方式来证明上面的定理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by<br>  apply And.intro<br>  case left =&gt; exact hp<br>  case right =&gt;<br>    apply And.intro<br>    case left =&gt; exact hq<br>    case right =&gt; exact hp<br></code></pre></td></tr></table></figure><ol type="1"><li><code>apply</code>策略应用于一个表达式，表示所给的表达式应该准确地填充目标，可被视为表示一个有零或多个参数的函数。</li></ol><p>例如, <code>apply And.intro</code> 命令将第一个目标标记为<code>left</code>，将第二个目标标记为 <code>right</code>。</p><ol start="2" type="1"><li><code>exact</code> 策略表示所给的表达式应该准确地填充目标。</li></ol><p>例如，这里的<code>And.intro</code>的第一个目标是通过<code>exact hp</code> 命令来实现的。</p><p>上述证明也可以简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lean">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by<br>  apply And.intro<br>  . exact hp<br>  . apply And.intro<br>    . exact hq<br>    . exact hp<br>-- 或<br>theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by<br>  apply And.intro<br>  exact hp<br>  apply And.intro<br>  exact hq<br>  exact hp<br>-- 或<br>theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := by<br>  apply And.intro hp<br>  exact And.intro hq hp<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>intro</code> 策略可以普遍地用于引入任何类型的变量。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lean">example (α : Type) : α → α := by<br>  intro a<br>  exact a<br><br>example (α : Type) : ∀ x : α, x = x := by<br>  intro x<br>  exact Eq.refl x<br>  <br>example : ∀ a b c : Nat, a = b → a = c → c = b := by<br>  intro a b c h₁ h₂<br>  exact Eq.trans (Eq.symm h₂) h₁<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><code>rw</code>策略提供了一种基本机制，可以将<strong>等式</strong>应用于目标和假设的替换。</li></ol><p>基本用法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">rw <span class="hljs-selector-attr">[h]</span>        -- 使用等式 h 从左到右重写<br>rw <span class="hljs-selector-attr">[← h]</span>      -- 使用等式 h 从右到左重写<br>rw <span class="hljs-selector-attr">[h1, h2]</span>   -- 依次使用 <span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">h2</span><br>rw <span class="hljs-selector-attr">[h]</span> at <span class="hljs-selector-tag">h2</span>  -- 在假设 <span class="hljs-selector-tag">h2</span> 处重写<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lean">example (a b c : Nat) (h : a = b) (h2 : b = c) : a = c := by<br>  rw [h]    -- 目标变为 b = c<br>  rw [h2]   -- 目标变为 c = c<br>  rfl<br><br>example (h : a = b) : b = a := by<br>  rw [← h]  -- 反向重写：b = a 变为 b = b<br>  rfl<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><code>simp</code>策略能够基于表达式的简化规则，自动化简表达式。</li></ol><p>基本用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lean">simp          -- 使用默认简化集<br>simp [h1, h2] -- 额外添加 h1, h2 作为简化规则<br>simp only [h1, h2] -- 只使用指定的规则<br>simp at h     -- 简化假设 h<br>simp [*]      -- 使用所有本地假设<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lean">example : (if True then a else b) = a := by<br>  simp  -- 自动简化 if True<br><br>example (h : p) : (if p then a else b) = a := by<br>  simp [h]  -- 需要告诉 simp 知道 p 为真<br><br>example : 0 + x = x := by<br>  simp  -- 自动使用 Nat.zero_add<br><br>example : 2 + 2 = 4 := by<br>  simp  -- 可以自动计算<br></code></pre></td></tr></table></figure><h3 id="计算式证明">5.2 计算式证明</h3><p>一个计算式证明是指一串使用诸如等式的传递性等基本规则得到的中间结果。在Lean 中，计算式证明从关键字 <code>calc</code> 开始，语法如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">calc<br>  <span class="hljs-symbol">&lt;expr&gt;</span>_0  <span class="hljs-string">&#x27;op_1&#x27;</span>  <span class="hljs-symbol">&lt;expr&gt;</span>_1  <span class="hljs-string">&#x27;:=&#x27;</span>  <span class="hljs-symbol">&lt;proof&gt;</span>_1<br>  <span class="hljs-string">&#x27;_&#x27;</span>       <span class="hljs-string">&#x27;op_2&#x27;</span>  <span class="hljs-symbol">&lt;expr&gt;</span>_2  <span class="hljs-string">&#x27;:=&#x27;</span>  <span class="hljs-symbol">&lt;proof&gt;</span>_2<br>  ...<br>  <span class="hljs-string">&#x27;_&#x27;</span>       <span class="hljs-string">&#x27;op_n&#x27;</span>  <span class="hljs-symbol">&lt;expr&gt;</span>_n  <span class="hljs-string">&#x27;:=&#x27;</span>  <span class="hljs-symbol">&lt;proof&gt;</span>_n<br></code></pre></td></tr></table></figure><p><code>calc</code> 下的每一行使用相同的缩进。每个<code>&lt;proof&gt;_i</code> 是<code>&lt;expr&gt;_&#123;i-1&#125; op_i &lt;expr&gt;_i</code> 的证明。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lean">variable (a b c d e : Nat)<br>variable (h1 : a = b)<br>variable (h2 : b = c + 1)<br>variable (h3 : c = d)<br>variable (h4 : e = 1 + d)<br><br>theorem T : a = e :=<br>  calc<br>    a = b      := h1<br>    _ = c + 1  := h2<br>    _ = d + 1  := congrArg Nat.succ h3<br>    _ = 1 + d  := Nat.add_comm d 1<br>    _ = e      := Eq.symm h4<br></code></pre></td></tr></table></figure><p>上述证明也可以用tactic策略简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lean">theorem T : a = e :=<br>  calc<br>    a = b      := by rw [h1]<br>    _ = c + 1  := by rw [h2]<br>    _ = d + 1  := by rw [h3]<br>    _ = 1 + d  := by rw [Nat.add_comm]<br>    _ = e      := by rw [h4]<br>-- 或<br>theorem T : a = e :=<br>  calc<br>    a = d + 1  := by rw [h1, h2, h3]<br>    _ = 1 + d  := by rw [Nat.add_comm]<br>    _ = e      := by rw [h4]<br>-- 或<br>theorem T : a = e :=<br>  by rw [h1, h2, h3, Nat.add_comm, h4]<br></code></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>【1】<a href="https://www.leanprover.cn/fp-lean-zh/">Lean 函数式编程- Lean 函数式编程</a></p><p>【2】<a href="https://www.leanprover.cn/tp-lean-zh/">Lean 4 定理证明- Lean 4 定理证明</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
      <category>lean</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lean</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrieval Augmented Generation（RAG）检索增强生成</title>
    <link href="/deep-learning/RAG/"/>
    <url>/deep-learning/RAG/</url>
    
    <content type="html"><![CDATA[<h1 id="retrieval-augmented-generationrag">Retrieval AugmentedGeneration（RAG）</h1><h2 id="基本概念">基本概念</h2><p>现有的Large LanguageModel（LLM）基于海量文本信息进行训练。虽然积累了庞大的知识库，但LLM也因此可能对特定领域理解不足，甚至产生“幻觉”（输出错误信息）。换句话说，LLM在预训练过程中积累了大量知识参数，但原先固定下来的知识并不一定完全可靠。</p><p>Retrieval AugmentedGeneration（RAG）检索增强支持技术，通常指的是：利用LLM的上下文学习能力，<strong>在提示词插入数据库的查询结果</strong>，以得到更可靠的LLM输出。</p><blockquote><p>总地来看，RAG技术出现的原因有哪些？</p><ol type="1"><li><p>幻觉问题：大模型在不擅长的场景中容易输出错误信息</p></li><li><p>知识的局限性：轻量化地使模型获取最新知识</p></li><li><p>数据安全性：避免私有数据被用于预训练导致的泄露</p></li></ol></blockquote><h2 id="一般步骤">一般步骤</h2><p>一般来说，RAG在LLM流程中的作用如下：</p><figure><img src="/deep-learning/RAG/v2-b32f7bb8437c13c04876292c066e47f6_1440w.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>RAG的流程包括3个步骤：</p><p>S1 Indexing：构造正确且有用信息的数据集</p><p>S2 Retrieval：使用向量检索等方法，完成有效信息的搜索</p><p>S3 Generation：将检索结果插入提示词，用大模型完成输出</p><h2 id="s1-indexing">S1 Indexing</h2><h2 id="s2-retrieval">S2 Retrieval</h2><h2 id="s3-generation">S3 Generation</h2><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/1973784509318205455">RAG详解：检索增强生成（RetrievalAugmented Generation） - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>RAG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RAG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：模拟、位运算</title>
    <link href="/competition/leetcode/hot-100/others-bits/"/>
    <url>/competition/leetcode/hot-100/others-bits/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100模拟位运算">LeetCode热题100：模拟、位运算</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&amp;envId=top-100-liked">189.轮转数组 - 力扣（LeetCode）</a></td><td>简单模拟</td></tr><tr><td><a href="https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&amp;envId=top-100-liked">41.缺失的第一个正数 - 力扣（LeetCode）</a></td><td>简单模拟</td></tr><tr><td><a href="https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&amp;envId=top-100-liked">73.矩阵置零 - 力扣（LeetCode）</a></td><td>简单模拟</td></tr><tr><td><a href="https://leetcode.cn/problems/spiral-matrix/?envType=study-plan-v2&amp;envId=top-100-liked">54.螺旋矩阵 - 力扣（LeetCode）</a></td><td>简单模拟</td></tr><tr><td><a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&amp;envId=top-100-liked">48.旋转图像 - 力扣（LeetCode）</a></td><td>简单模拟</td></tr><tr><td><a href="https://leetcode.cn/problems/next-permutation/description/?envType=study-plan-v2&amp;envId=top-100-liked">31.下一个排列 - 力扣（LeetCode）</a></td><td>下一个排列</td></tr><tr><td><a href="https://leetcode.cn/problems/single-number/?envType=study-plan-v2&amp;envId=top-100-liked">136.只出现一次的数字 - 力扣（LeetCode）</a></td><td>位运算</td></tr><tr><td><a href="https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">287.寻找重复数 - 力扣（LeetCode）</a></td><td>位运算 / 快慢指针</td></tr></tbody></table><h2 id="轮转数组">轮转数组</h2><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转<code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span> &gt; <span class="hljs-title">vv</span><span class="hljs-params">(v.size())</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>vv[(i+k) % v.<span class="hljs-built_in">size</span>()] = v[i];<br>&#125;<br>v = vv;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="缺失的第一个正数">缺失的第一个正数</h2><p>给你一个未排序的整数数组 <code>nums</code>，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code>并且只使用常数级别额外空间的解决方案。</p><p>1）O(N*logN)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>unordered_set&lt;<span class="hljs-type">int</span> &gt; st;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums)&#123;<br>st.<span class="hljs-built_in">insert</span>(it);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">count</span>(i))&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <br>        <span class="hljs-comment">// 若nums没有缺失正整数，则</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>            <span class="hljs-comment">// 若num[i]合法（是正整数，且 &lt;= nums.size()）</span><br>            <span class="hljs-comment">// 不断交换, 把它放到应该在的位置（nums[nums[i]-1] = i）</span><br><span class="hljs-keyword">while</span>(nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i] != nums[nums[i]<span class="hljs-number">-1</span>])&#123;<br><span class="hljs-type">int</span> x = i, y = nums[i]<span class="hljs-number">-1</span>;<br><span class="hljs-built_in">swap</span>(nums[x], nums[y]);<br>&#125;<br>&#125;<br>        <span class="hljs-comment">// 遍历到某一个不符合nums[nums[i]-1] = i的位置</span><br>        <span class="hljs-comment">// 这个位置就是缺失的第一个正整数的位置</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(nums[i] != i<span class="hljs-number">+1</span>)&#123;<br><span class="hljs-keyword">return</span> i<span class="hljs-number">+1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="矩阵置零">矩阵置零</h2><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为<strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong>。请使用 <strong><a href="http://baike.baidu.com/item/原地算法">原地</a></strong> 算法。</p><p>1）空间复杂度O(N + M)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-comment">// 使用一个行数组，列数组记录是否需要删除</span><br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>(), m = v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span> &gt; <span class="hljs-title">row</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span>, <span class="hljs-title">col</span><span class="hljs-params">(m, <span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j ++)&#123;<br><span class="hljs-keyword">if</span> (v[i][j] == <span class="hljs-number">0</span>) &#123;<br>row[i] = col[j] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j ++)&#123;<br><span class="hljs-keyword">if</span> (row[i] || col[j])&#123;<br>v[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）空间复杂度O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-comment">// 直接将 第 0 行 和 第 0 列</span><br><span class="hljs-comment">// 作为记录数组</span><br><span class="hljs-comment">// 若第0行/列本身就包含0，那么最后需要清空</span><br><span class="hljs-type">int</span> n=v.<span class="hljs-built_in">size</span>(), m=v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><span class="hljs-type">bool</span> row0 = <span class="hljs-literal">false</span>, col0 = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(v[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) col0 = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) row0 = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; m ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[i][j] == <span class="hljs-number">0</span>)&#123;<br>v[<span class="hljs-number">0</span>][j] = v[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; m ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span> || v[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) v[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(col0)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>v[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(row0)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br>v[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="螺旋矩阵">螺旋矩阵</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵<code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>，返回矩阵中的所有元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>(), m = v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> d = <span class="hljs-number">0</span>;<br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">vis</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m));<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(cnt &lt; n*m)&#123;<br>vis[x][y] = <span class="hljs-literal">true</span>;<br>ans.<span class="hljs-built_in">push_back</span>(v[x][y]);<br>cnt++;<br><span class="hljs-type">int</span> nx = x + dirx[d % <span class="hljs-number">4</span>];<br><span class="hljs-type">int</span> ny = y + diry[d % <span class="hljs-number">4</span>];<br><span class="hljs-keyword">if</span>(!(nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n) || !(ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m) || vis[nx][ny])&#123;<br>d++;<br>nx = x + dirx[d % <span class="hljs-number">4</span>];<br>ny = y + diry[d % <span class="hljs-number">4</span>];<br>&#125;<br>x = nx; y = ny;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="旋转图像">旋转图像</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code>表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在<strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p>1）空间复杂度O(N*M)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 中间数组存储</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v)</span> </span>&#123;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; t = v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; v[i].<span class="hljs-built_in">size</span>() ; j ++)&#123;<br>t[j][v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-i] = v[i][j];<br>&#125;<br>&#125;<br>v = t;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）空间复杂度O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 先把数组划分为 四个象限</span><br><span class="hljs-comment">// 以第一象限内的一个点（i, j）为基准，找到其他三个象限的对应点</span><br><span class="hljs-comment">// 进行四次调换即可。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v)</span> </span>&#123;<br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n/<span class="hljs-number">2</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; (n<span class="hljs-number">+1</span>)/<span class="hljs-number">2</span> ; j ++)&#123;<br><span class="hljs-type">int</span> tmp = v[i][j];<br>v[i][j] = v[n<span class="hljs-number">-1</span>-j][i];<br>v[n<span class="hljs-number">-1</span>-j][i] = v[n<span class="hljs-number">-1</span>-i][n<span class="hljs-number">-1</span>-j];<br>v[n<span class="hljs-number">-1</span>-i][n<span class="hljs-number">-1</span>-j] = v[j][n<span class="hljs-number">-1</span>-i];<br>v[j][n<span class="hljs-number">-1</span>-i] = tmp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="下一个排列">下一个排列</h2><p>整数数组的一个 <strong>排列</strong>就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作<code>arr</code>的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code>。</li></ul><p>整数数组的 <strong>下一个排列</strong>是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的<strong>下一个排列</strong>就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code>。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是<code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code>，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code>的下一个排列。</p><p>必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong>修改，只允许使用额外常数空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br><span class="hljs-comment">// 反转数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">re</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123; <br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br><span class="hljs-built_in">swap</span>(nums[l], nums[r]);<br>l++; r--;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 求下一个排列</span><br>    <span class="hljs-comment">// == 以最小的幅度，提高当前排列的字典序</span><br>    <span class="hljs-comment">// == 交换两个数nums[x], nums[y], x要尽可能地靠右，nums[y]要尽可能地小</span><br>    <span class="hljs-comment">// == 找到第一个 nums[i] &lt; nums[i+1]的位置，在i的右侧找到最小的，大于num[i]的数，</span><br>    <span class="hljs-comment">// 交换这两个数，反转nums[i]右侧的数（原本右侧为降序，反转后为升序）</span><br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> i = n<span class="hljs-number">-2</span>;<br><span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i<span class="hljs-number">+1</span>]) i--;<br><span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n<span class="hljs-number">-1</span>; j &gt; i; j --)&#123;<br><span class="hljs-keyword">if</span>(nums[j] &gt; nums[i])&#123;<br><span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br><span class="hljs-built_in">re</span>(nums, i<span class="hljs-number">+1</span>, n<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">re</span>(nums, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="只出现一次的数字">只出现一次的数字</h2><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code>，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 根据位运算法则</span><br><span class="hljs-comment">// A^A == 0</span><br><span class="hljs-comment">// A^0 == A</span><br><span class="hljs-comment">// 且 某个元素只出现一次以外，其余每个元素均出现两次</span><br><span class="hljs-comment">// 所以所有元素的异或之和就是只出现一次的数本身</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>ans = ans^nums[i];<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="寻找重复数">寻找重复数</h2><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code>，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和<code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回<strong>这个重复的数</strong> 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code>且只用常量级 <code>O(1)</code> 的额外空间。</p><p>1）位运算 O(N*LogN)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> b1[<span class="hljs-number">50</span>], b2[<span class="hljs-number">50</span>]; <span class="hljs-comment">// 统计每一位1出现了多少次，多出的部分就是重复的数</span><br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">31</span>; j ++)&#123;<br><span class="hljs-keyword">if</span>(nums[i] &amp; (<span class="hljs-number">1</span>&lt;&lt;j)) b1[j] ++;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; (i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))) b2[j] ++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">31</span>; i ++)&#123;<br><span class="hljs-keyword">if</span>(b1[i] &gt; b2[i])&#123;<br>ans |= (<span class="hljs-number">1</span>&lt;&lt;i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）快慢指针 O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 以数值为节点，设置边：i -&gt; nums[i] </span><br>    <span class="hljs-comment">// 则 包含0在内的子图，一定存在环</span><br>    <span class="hljs-comment">// 使用快慢指针找到环的起点，即为重复点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> s = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>;<br>s = nums[s], f = nums[nums[f]];<br><span class="hljs-keyword">while</span>(s != f)&#123;<br>s = nums[s];<br>f = nums[nums[f]];<br>&#125;<br>f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(s != f)&#123;<br>s = nums[s];<br>f = nums[f];<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
      <tag>模拟</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：动态规划</title>
    <link href="/competition/leetcode/hot-100/dp/"/>
    <url>/competition/leetcode/hot-100/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode热题100：动态规划"><a href="#LeetCode热题100：动态规划" class="headerlink" title="LeetCode热题100：动态规划"></a>LeetCode热题100：动态规划</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/maximum-subarray/?envType=study-plan-v2&envId=top-100-liked">53. 最大子数组和 - 力扣（LeetCode）</a></td><td>线性DP</td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked">152. 乘积最大子数组 - 力扣（LeetCode）</a></td><td>线性DP</td></tr><tr><td><a href="https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-100-liked">70. 爬楼梯 - 力扣（LeetCode）</a></td><td>线性DP</td></tr><tr><td><a href="https://leetcode.cn/problems/pascals-triangle/?envType=study-plan-v2&envId=top-100-liked">118. 杨辉三角 - 力扣（LeetCode）</a></td><td>数字三角形模型</td></tr><tr><td><a href="https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked">198. 打家劫舍 - 力扣（LeetCode）</a></td><td>状态机</td></tr><tr><td><a href="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked">279. 完全平方数 - 力扣（LeetCode）</a></td><td>线性DP</td></tr><tr><td><a href="https://leetcode.cn/problems/coin-change/?envType=study-plan-v2&envId=top-100-liked">322. 零钱兑换 - 力扣（LeetCode）</a></td><td>线性DP</td></tr><tr><td><a href="https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&envId=top-100-liked">139. 单词拆分 - 力扣（LeetCode）</a></td><td>字符串处理+线性DP</td></tr><tr><td><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked">300. 最长递增子序列 - 力扣（LeetCode）</a></td><td>LIS</td></tr><tr><td><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/?envType=study-plan-v2&envId=top-100-liked">416. 分割等和子集 - 力扣（LeetCode）</a></td><td>背包</td></tr><tr><td><a href="https://leetcode.cn/problems/longest-valid-parentheses/?envType=study-plan-v2&envId=top-100-liked">32. 最长有效括号 - 力扣（LeetCode）</a></td><td>线性DP &#x2F; 栈</td></tr><tr><td><a href="https://leetcode.cn/problems/unique-paths/?envType=study-plan-v2&envId=top-100-liked">62. 不同路径 - 力扣（LeetCode）</a></td><td>二维DP</td></tr><tr><td><a href="https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked">64. 最小路径和 - 力扣（LeetCode）</a></td><td>二维DP</td></tr><tr><td><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-100-liked">5. 最长回文子串 - 力扣（LeetCode）</a></td><td>区间DP</td></tr><tr><td><a href="https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=top-100-liked">1143. 最长公共子序列 - 力扣（LeetCode）</a></td><td>LCS</td></tr><tr><td><a href="https://leetcode.cn/problems/edit-distance/?envType=study-plan-v2&envId=top-100-liked">72. 编辑距离 - 力扣（LeetCode）</a></td><td>线性DP</td></tr></tbody></table><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> dp = <span class="hljs-number">0</span>; <span class="hljs-comment">// dp: 到上一个位置为止的最长连续和</span><br><span class="hljs-type">int</span> ans = INT_MIN;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, nums[i] + dp);<br>dp += nums[i];<br><span class="hljs-keyword">if</span>(dp &lt; <span class="hljs-number">0</span>) dp = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> ma, mi, ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>ma = mi = ans = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">swap</span>(ma, mi);<br>&#125;<br>ma = <span class="hljs-built_in">max</span>(ma*nums[i], nums[i]); <span class="hljs-comment">// 以 i 结尾的最大乘积：max(以i-1结尾的最大乘积*nums[i], nums[i])</span><br>mi = <span class="hljs-built_in">min</span>(mi*nums[i], nums[i]);<br>ans = <span class="hljs-built_in">max</span>(ma, ans); <span class="hljs-comment">// 对以每个位置结尾乘积的最大值，取全局最值</span><br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">50</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i ++)&#123;<br>dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><p>给定一个非负整数 *<code>numRows</code>，*生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="/competition/leetcode/hot-100/dp/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> n) &#123;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++)&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-1</span>][j];<br>v.<span class="hljs-built_in">push_back</span>(dp[i][j]);<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">200</span>][<span class="hljs-number">2</span>];<br><span class="hljs-comment">// 0 - 没偷当前房屋；1 - 偷当前房屋</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>dp[i][<span class="hljs-number">1</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + nums[i];<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">10005</span>];<br><span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(dp, inf, <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i*i &lt;= n; i ++)&#123; <span class="hljs-comment">// 求出小于n的全部完全平方数</span><br>v.<span class="hljs-built_in">push_back</span>(i*i);<br>dp[i*i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br><span class="hljs-keyword">if</span>(dp[i] == inf) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br><span class="hljs-keyword">if</span>(i + it &lt;= n)&#123;<br>dp[i+it] = <span class="hljs-built_in">min</span>(dp[i+it], dp[i] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20000</span>];<br><span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(dp, inf, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= amount; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c: coins)&#123;<br><span class="hljs-keyword">if</span>(i-c &gt;= <span class="hljs-number">0</span>)&#123;<br>dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-c] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[amount] == inf ? <span class="hljs-number">-1</span> : dp[amount];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p><p>**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">bool</span> dp[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; dict)</span> </span>&#123;<br>s = <span class="hljs-string">&quot; &quot;</span> + s;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it: dict)&#123;<br><span class="hljs-keyword">if</span>(i + it.<span class="hljs-built_in">size</span>() &lt; s.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-keyword">if</span>(it == s.<span class="hljs-built_in">substr</span>(i<span class="hljs-number">+1</span>, it.<span class="hljs-built_in">size</span>()))&#123;<br>dp[i+it.<span class="hljs-built_in">size</span>()] = dp[i+it.<span class="hljs-built_in">size</span>()] || dp[i];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p>1）DP：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20005</span>];<br><span class="hljs-type">int</span> ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>dp[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)&#123;<br><span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;<br>ans = <span class="hljs-built_in">max</span>(dp[i], ans);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）贪心 + 二分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> low[<span class="hljs-number">3000</span>];<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>low[++cnt] = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(nums[i] &gt; low[cnt])&#123;<br>low[++cnt] = nums[i];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> k = <span class="hljs-built_in">lower_bound</span>(low<span class="hljs-number">+1</span>, low<span class="hljs-number">+1</span>+cnt, nums[i]) - low;<br>low[k] = nums[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">bool</span> dp[<span class="hljs-number">20005</span>];<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums) sum += it;<br><span class="hljs-keyword">if</span>(sum &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum/<span class="hljs-number">2</span>; j &gt;= it; j --)&#123;<br>dp[j] = dp[j]|dp[j-it];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[sum/<span class="hljs-number">2</span>];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>1）DP：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">30005</span>], ans;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-comment">// 若结尾1位不是), 则有效长度一定为0</span><br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 结尾2位情况为 ()</span><br><span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>dp[i] = (i<span class="hljs-number">-2</span> &gt;= <span class="hljs-number">0</span> ? dp[i<span class="hljs-number">-2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                <span class="hljs-comment">// 结尾2位情况为 ))</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp; i<span class="hljs-number">-1</span>-dp[i<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i<span class="hljs-number">-1</span>-dp[i<span class="hljs-number">-1</span>]] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br><span class="hljs-type">int</span> k = (i<span class="hljs-number">-1</span>-dp[i<span class="hljs-number">-1</span>])<span class="hljs-number">-1</span>;<br>dp[i] = (k &gt;= <span class="hljs-number">0</span> ? dp[k] : <span class="hljs-number">0</span>) + dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br>ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-type">int</span> ans;<br>stack&lt;<span class="hljs-type">int</span> &gt; st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)&#123; <br><span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; s[st.<span class="hljs-built_in">top</span>()] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123; <span class="hljs-comment">// 若为), 且栈顶为(, 则完成匹配，计算对应长度</span><br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, i<span class="hljs-number">+1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, i-st.<span class="hljs-built_in">top</span>());<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 若为), 且栈为空或栈顶不为), 说明当前右括号不合法，连续合法序列在此处断开</span><br>st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 左括号直接入栈</span><br>st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">200</span>][<span class="hljs-number">200</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++) dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= n; j ++)&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>给定一个包含非负整数的 <code>m * n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>**说明：**每次只能向下或者向右移动一步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">200</span>][<span class="hljs-number">200</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br><span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f3f3f3f</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)&#123;<br><span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j] + grid[i][j], dp[i][j]);<br><span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>] + grid[i][j], dp[i][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">bool</span> dp[<span class="hljs-number">2000</span>][<span class="hljs-number">2000</span>];<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br><br><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>dp[i][i] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] == s[i<span class="hljs-number">-1</span>])&#123;<br>dp[i<span class="hljs-number">-1</span>][i] = <span class="hljs-literal">true</span>;<br>l = i<span class="hljs-number">-1</span>;<br>r = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">3</span>; len &lt;= s.<span class="hljs-built_in">size</span>(); len ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i+len<span class="hljs-number">-1</span> &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-type">int</span> j = i+len<span class="hljs-number">-1</span>;<br>dp[i][j] = dp[i<span class="hljs-number">+1</span>][j<span class="hljs-number">-1</span>] &amp;&amp; s[i] == s[j];<br><span class="hljs-keyword">if</span>(dp[i][j])&#123;<br>l = i;<br>r = j;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(l, r-l<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1050</span>][<span class="hljs-number">1050</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string t1, string t2)</span> </span>&#123;<br><span class="hljs-type">int</span> n = t<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), m = t<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>t1 = <span class="hljs-string">&quot; &quot;</span> + t1;<br>t2 = <span class="hljs-string">&quot; &quot;</span> + t2;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)&#123;<br><span class="hljs-keyword">if</span>(t1[i] == t2[j])&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> dp[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string w1, string w2)</span> </span>&#123;<br><span class="hljs-type">int</span> n = w<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> m = w<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>w1 = <span class="hljs-string">&quot; &quot;</span> + w1;<br>w2 = <span class="hljs-string">&quot; &quot;</span> + w2;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++) dp[<span class="hljs-number">0</span>][i] = i;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)&#123;<br><span class="hljs-keyword">if</span>(w1[i] == w2[j])&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 不变</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 插入、删除</span><br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, dp[i][j]); <span class="hljs-comment">// 替换</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：贪心</title>
    <link href="/competition/leetcode/hot-100/greed/"/>
    <url>/competition/leetcode/hot-100/greed/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100贪心">LeetCode热题100：贪心</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&amp;envId=top-100-liked">121.买卖股票的最佳时机 - 力扣（LeetCode）</a></td><td>贪心</td></tr><tr><td><a href="https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&amp;envId=top-100-liked">55.跳跃游戏 - 力扣（LeetCode）</a></td><td>贪心</td></tr><tr><td><a href="https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&amp;envId=top-100-liked">45.跳跃游戏 II - 力扣（LeetCode）</a></td><td>贪心</td></tr><tr><td><a href="https://leetcode.cn/problems/partition-labels/?envType=study-plan-v2&amp;envId=top-100-liked">763.划分字母区间 - 力扣（LeetCode）</a></td><td>贪心</td></tr></tbody></table><h2 id="买卖股票的最佳时机">买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素<code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在<strong>未来的某一个不同的日子</strong>卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回<code>0</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cost = INT_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p: prices)&#123; <span class="hljs-comment">// cost记录此前最小的买入价格</span><br>cost = <span class="hljs-built_in">min</span>(cost, p);<br>ans = <span class="hljs-built_in">max</span>(ans, p-cost);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="跳跃游戏">跳跃游戏</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的<strong>第一个下标</strong>。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>; <span class="hljs-comment">// maxlen 记录经过当前位置后，能跳跃的最远距离</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(i &gt; maxlen) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>maxlen = <span class="hljs-built_in">max</span>(i+nums[i], maxlen);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="跳跃游戏-ii">跳跃游戏 II</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组<code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code>向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code>处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code></li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code>的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 设上一次跳跃范围是[x, y]</span><br>        <span class="hljs-comment">// end表示下一次跳跃范围的右边界</span><br>        <span class="hljs-comment">// 每个区间只跳一次，选择下一次跳跃范围最大的，是最优解</span><br><span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> end = <span class="hljs-number">0</span>; <br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>k = <span class="hljs-built_in">max</span>(k, nums[i] + i);<br><span class="hljs-keyword">if</span>(i == end &amp;&amp; i != nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>times++;<br>end = k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> times;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="划分字母区间">划分字母区间</h2><p>给你一个字符串 <code>s</code>。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串<code>"ababcc"</code> 能够被分为 <code>["abab", "cc"]</code>，但类似<code>["aba", "bcc"]</code> 或 <code>["ab", "ab", "cc"]</code>的划分是非法的。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是<code>s</code> 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> last[<span class="hljs-number">26</span>]; <span class="hljs-comment">//每个字母最后一次出现的位置</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++)&#123;<br>last[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-built_in">max</span>(i, last[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]);<br>&#125;<br><span class="hljs-type">int</span> st = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i ++)&#123;<br>end = <span class="hljs-built_in">max</span>(end, last[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]);<br><span class="hljs-keyword">if</span>(i == end)&#123; <span class="hljs-comment">// 若 i &gt;= 目前为止的所有经过的字母的最后位置，则可在此处划分</span><br>ans.<span class="hljs-built_in">push_back</span>(end-st<span class="hljs-number">+1</span>);<br>st = end = i<span class="hljs-number">+1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：堆</title>
    <link href="/competition/leetcode/hot-100/heap/"/>
    <url>/competition/leetcode/hot-100/heap/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100堆">LeetCode热题100：堆</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">215.数组中的第K个最大元素 - 力扣（LeetCode）</a></td><td>堆</td></tr><tr><td><a href="https://leetcode.cn/problems/top-k-frequent-elements/?envType=study-plan-v2&amp;envId=top-100-liked">347.前 K 个高频元素 - 力扣（LeetCode）</a></td><td>堆</td></tr><tr><td><a href="https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&amp;envId=top-100-liked">295.数据流的中位数 - 力扣（LeetCode）</a></td><td>堆</td></tr></tbody></table><h2 id="数组的第k个最大元素">数组的第K个最大元素</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第<code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code>个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p>1）STL：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums)&#123;<br>pq.<span class="hljs-built_in">push</span>(it);<br><span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() &gt; k) pq.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）手写堆：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> heap[<span class="hljs-number">200000</span>];<br><span class="hljs-type">int</span> siz;<br><br>    <span class="hljs-comment">// 向下调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">justDown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> now = x;<br><span class="hljs-keyword">while</span>(now &lt;= siz)&#123;<br><span class="hljs-type">int</span> t = now;<br><span class="hljs-keyword">if</span>(now*<span class="hljs-number">2</span> &lt;= siz &amp;&amp; heap[t] &gt; heap[now*<span class="hljs-number">2</span>]) t = now*<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(now*<span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= siz &amp;&amp; heap[t] &gt; heap[now*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]) t = now*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(t != now)&#123;<br><span class="hljs-built_in">swap</span>(heap[t], heap[now]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>now = t;<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// 向上调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">justUp</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> now = x;<br><span class="hljs-keyword">while</span>(now &gt;= <span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">int</span> t = now;<br><span class="hljs-keyword">if</span>(now/<span class="hljs-number">2</span> &gt;= <span class="hljs-number">1</span> &amp;&amp; heap[t] &lt; heap[now/<span class="hljs-number">2</span>]) t = now/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(t != now)&#123;<br><span class="hljs-built_in">swap</span>(heap[t], heap[now]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>now = t;<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// 移除堆顶</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(siz &gt;= <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">swap</span>(heap[<span class="hljs-number">1</span>], heap[siz]);<br>siz--;<br><span class="hljs-built_in">justDown</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>    <br><span class="hljs-comment">// 插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>heap[++siz] = val;<br><span class="hljs-built_in">justUp</span>(siz);<br>&#125;<br>    <br><span class="hljs-comment">// 查询堆顶</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getTop</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(siz &gt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> heap[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-built_in">push</span>(nums[i]);<br><span class="hljs-keyword">if</span>(siz &gt; k) <span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">getTop</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="前k个高频元素">前K个高频元素</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按<strong>任意顺序</strong> 返回答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> x, sum;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp; rhs) <span class="hljs-type">const</span> &#123;<br><span class="hljs-keyword">return</span> sum &gt; rhs.sum;<br>&#125;<br>&#125;;<br><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>priority_queue&lt;node&gt; pq;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums)&#123;<br>cnt[it]++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;[x, sum]: cnt)&#123;<br><span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>() == k)&#123;<br><span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">top</span>().sum &lt; sum)&#123;<br>pq.<span class="hljs-built_in">pop</span>();<br>pq.<span class="hljs-built_in">push</span>(&#123;x, sum&#125;);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>pq.<span class="hljs-built_in">push</span>(&#123;x, sum&#125;);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>ans.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>().x);<br>pq.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="数据流中的中位数">数据流中的中位数</h2><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li><li>例如 <code>arr = [2,3]</code> 的中位数是<code>(2 + 3) / 2 = 2.5</code> 。</li></ul><p>实现 MedianFinder 类:</p><ul><li><code>MedianFinder()</code>初始化 <code>MedianFinder</code>对象。</li><li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code>添加到数据结构中。</li><li><code>double findMedian()</code>返回到目前为止所有元素的中位数。与实际答案相差 <code>10-5</code>以内的答案将被接受。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 维护一个大根堆、小根堆</span><br>    <span class="hljs-comment">// 两个堆的顶分别是2个中位数</span><br>priority_queue&lt;<span class="hljs-type">int</span> &gt; pql;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; pqr;<br><br><span class="hljs-built_in">MedianFinder</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(pql.<span class="hljs-built_in">empty</span>() || pql.<span class="hljs-built_in">top</span>() &gt;= num)&#123;<br>pql.<span class="hljs-built_in">push</span>(num);<br><span class="hljs-keyword">if</span>(pql.<span class="hljs-built_in">size</span>() &gt; pqr.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>)&#123;<br>pqr.<span class="hljs-built_in">push</span>(pql.<span class="hljs-built_in">top</span>());<br>pql.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>pqr.<span class="hljs-built_in">push</span>(num);<br><span class="hljs-keyword">if</span>(pqr.<span class="hljs-built_in">size</span>() &gt; pql.<span class="hljs-built_in">size</span>())&#123;<br>pql.<span class="hljs-built_in">push</span>(pqr.<span class="hljs-built_in">top</span>());<br>pqr.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(pql.<span class="hljs-built_in">size</span>() == pqr.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-keyword">return</span> (pql.<span class="hljs-built_in">top</span>() + pqr.<span class="hljs-built_in">top</span>())/<span class="hljs-number">2.0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> pql.<span class="hljs-built_in">top</span>();<br>&#125;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder* obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj-&gt;addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj-&gt;findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：栈、队列</title>
    <link href="/competition/leetcode/hot-100/queue-stack/"/>
    <url>/competition/leetcode/hot-100/queue-stack/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100栈队列">LeetCode热题100：栈、队列</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&amp;envId=top-100-liked">239.滑动窗口最大值 - 力扣（LeetCode）</a></td><td>单调队列</td></tr><tr><td><a href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">20.有效的括号 - 力扣（LeetCode）</a></td><td>栈</td></tr><tr><td><a href="https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&amp;envId=top-100-liked">155.最小栈 - 力扣（LeetCode）</a></td><td>最小栈</td></tr><tr><td><a href="https://leetcode.cn/problems/decode-string/?envType=study-plan-v2&amp;envId=top-100-liked">394.字符串解码 - 力扣（LeetCode）</a></td><td>栈、字符串处理</td></tr><tr><td><a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&amp;envId=top-100-liked">739.每日温度 - 力扣（LeetCode）</a></td><td>单调栈</td></tr><tr><td><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&amp;envId=top-100-liked">84.柱状图中最大的矩形 - 力扣（LeetCode）</a></td><td>单调栈</td></tr></tbody></table><h2 id="滑动窗口最大值">滑动窗口最大值</h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的<code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p>1）STL实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// &#123;数值，插入时间&#125;</span><br>deque&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; dq;<br><br><span class="hljs-comment">// 单调队列插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">back</span>().first &lt;= x)&#123;<br>dq.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>dq.<span class="hljs-built_in">push_back</span>(&#123;x, i&#125;);<br>&#125;<br><br><span class="hljs-comment">// 单调队列取最值</span><br>    <span class="hljs-comment">// 取出队首一个时间在范围内的数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>().second &lt;= i - k)&#123;<br>dq.<span class="hljs-built_in">pop_front</span>();<br>&#125;<br><span class="hljs-keyword">if</span>(!dq.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> dq.<span class="hljs-built_in">front</span>().first;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br><span class="hljs-built_in">push</span>(nums[i], i);<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">getMax</span>(k<span class="hljs-number">-1</span>, k));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-built_in">push</span>(nums[i], i);<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">getMax</span>(i, k));<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）数组实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;<br><span class="hljs-type">int</span> h, t;<br><span class="hljs-comment">// 单调队列插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> i)</span></span>&#123;<br><span class="hljs-keyword">while</span>(t &gt;= h &amp;&amp; q[t].first &lt;= x)&#123;<br>t--;<br>&#125;<br>q[++t] = &#123;x, i&#125;;<br>&#125;<br><br><span class="hljs-comment">// 单调队列取最值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">while</span>(h &lt;= t &amp;&amp; q[h].second &lt;= i-k)&#123;<br>h++;<br>&#125;<br><span class="hljs-keyword">if</span>(h &lt;= t) <span class="hljs-keyword">return</span> q[h].first;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>q.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>());<br>h = <span class="hljs-number">0</span>; t = <span class="hljs-number">-1</span>;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br><span class="hljs-built_in">push</span>(nums[i], i);<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">getMax</span>(k<span class="hljs-number">-1</span>, k));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-built_in">push</span>(nums[i], i);<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">getMax</span>(i, k));<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="有效的括号">有效的括号</h2><p>给定一个只包括<code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code>的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol type="1"><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>stack&lt;<span class="hljs-type">char</span>&gt; st, tmp;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br>st.<span class="hljs-built_in">push</span>(s[i]);<br>&#125;<br><span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-type">char</span> t = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(t == <span class="hljs-string">&#x27;)&#x27;</span> || t == <span class="hljs-string">&#x27;&#125;&#x27;</span> || t == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>tmp.<span class="hljs-built_in">push</span>(t);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(!tmp.<span class="hljs-built_in">empty</span>() &amp;&amp; tmp.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; t == <span class="hljs-string">&#x27;(&#x27;</span>) tmp.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!tmp.<span class="hljs-built_in">empty</span>() &amp;&amp; tmp.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; t == <span class="hljs-string">&#x27;&#123;&#x27;</span>) tmp.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!tmp.<span class="hljs-built_in">empty</span>() &amp;&amp; tmp.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; t == <span class="hljs-string">&#x27;[&#x27;</span>) tmp.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> tmp.<span class="hljs-built_in">empty</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最小栈">最小栈</h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>stack&lt;<span class="hljs-type">int</span> &gt; st, stmin;<br><br><span class="hljs-built_in">MinStack</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>st.<span class="hljs-built_in">push</span>(val);<br><span class="hljs-keyword">if</span>(stmin.<span class="hljs-built_in">empty</span>() || stmin.<span class="hljs-built_in">top</span>() &gt;= val) stmin.<span class="hljs-built_in">push</span>(val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(stmin.<span class="hljs-built_in">top</span>() == st.<span class="hljs-built_in">top</span>())&#123;<br>stmin.<span class="hljs-built_in">pop</span>();<br>&#125;<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> stmin.<span class="hljs-built_in">top</span>();<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="字符串解码">字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的<code>encoded_string</code> 正好重复 <code>k</code> 次。注意<code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数<code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code>的输入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br><br>stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>stack&lt;string&gt; strs;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// 设res为当前层的字符串</span><br>        <span class="hljs-comment">// strs中存储上一层的字符串</span><br>        <span class="hljs-comment">// nums中存储上一层的数字</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>num = num*<span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)&#123;<br>res += s[i];<br>&#125;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>)&#123; <br>                <span class="hljs-comment">// 遇到[, 说明进入下一层，将上一层的字符串和数字入栈</span><br>nums.<span class="hljs-built_in">push</span>(num);<br>num = <span class="hljs-number">0</span>;<br>strs.<span class="hljs-built_in">push</span>(res);<br>res = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>                <span class="hljs-comment">// 遇到], 说明走出当前层，将当前层处理后，回到上一层（重置res）</span><br>string t = strs.<span class="hljs-built_in">top</span>(); strs.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> tim = nums.<span class="hljs-built_in">top</span>(); nums.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">while</span>(tim--) t += res;<br>res = t;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;; <br></code></pre></td></tr></table></figure><h2 id="每日温度">每日温度</h2><p>给定一个整数数组 <code>temperatures</code>，表示每天的温度，返回一个数组 <code>answer</code> ，其中<code>answer[i]</code> 是指对于第 <code>i</code>天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用<code>0</code> 来代替。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br>ans.<span class="hljs-built_in">assign</span>(temp.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>stack&lt;<span class="hljs-type">int</span> &gt; st; <span class="hljs-comment">// 存储过去温度的下标</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temp.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-type">int</span> ti = st.<span class="hljs-built_in">top</span>();<br><span class="hljs-keyword">if</span>(temp[ti] &lt; temp[i])&#123;<br>ans[ti] = i - ti;<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="柱形图中的最大矩形">柱形图中的最大矩形</h2><p>给定 <em>n</em>个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>stack&lt;<span class="hljs-type">int</span> &gt; st; <br>h.<span class="hljs-built_in">insert</span>(h.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);<br>h.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-comment">// 设置一个单调递增栈</span><br>            <span class="hljs-comment">// 当元素出栈时，下一个元素是出栈元素向后找第一个比其小的元素</span><br>            <span class="hljs-comment">// 当元素出栈时，上一个元素是出栈元素向前找第一个比其小的元素</span><br>            <span class="hljs-comment">// 因此，我们可以计算以出栈元素为高度的最大矩形面积</span><br><span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>() &amp;&amp; h[i] &lt; h[st.<span class="hljs-built_in">top</span>()])&#123;<br><span class="hljs-type">int</span> cur = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> l = st.<span class="hljs-built_in">top</span>()<span class="hljs-number">+1</span>;<br><span class="hljs-type">int</span> r = i<span class="hljs-number">-1</span>;<br>ans = <span class="hljs-built_in">max</span>(ans, h[cur]*(r-l<span class="hljs-number">+1</span>));<br>&#125;<br>st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：二分</title>
    <link href="/competition/leetcode/hot-100/binary-search/"/>
    <url>/competition/leetcode/hot-100/binary-search/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100二分">LeetCode热题100：二分</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&amp;envId=top-100-liked">35.搜索插入位置 - 力扣（LeetCode）</a></td><td>二分</td></tr><tr><td><a href="https://leetcode.cn/problems/search-a-2d-matrix/?envType=study-plan-v2&amp;envId=top-100-liked">74.搜索二维矩阵 - 力扣（LeetCode）</a></td><td>二分（二维）</td></tr><tr><td><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/?envType=study-plan-v2&amp;envId=top-100-liked">240.搜索二维矩阵 II - 力扣（LeetCode）</a></td><td>二分，二叉搜索树</td></tr><tr><td><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">34.在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></td><td>二分</td></tr><tr><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&amp;envId=top-100-liked">33.搜索旋转排序数组 - 力扣（LeetCode）</a></td><td>二分变形</td></tr><tr><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">153.寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></td><td>二分变形</td></tr><tr><td><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/?envType=study-plan-v2&amp;envId=top-100-liked">4.寻找两个正序数组的中位数 - 力扣（LeetCode）</a></td><td>二分变形</td></tr></tbody></table><h2 id="搜索插入位置">搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> t)</span> </span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(nums[mid] == t) <span class="hljs-keyword">return</span> mid;<br><span class="hljs-keyword">if</span>(nums[mid] &gt; t)&#123;<br>r = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>l = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="搜索二维矩阵">搜索二维矩阵</h2><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ul><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>给你一个整数 <code>target</code> ，如果 <code>target</code>在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ma, <span class="hljs-type">int</span> t)</span> </span>&#123;<br><span class="hljs-type">int</span> n = ma.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> m = ma[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = n*m;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(ma[mid/m][mid%m] == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 将二维数组看作一维数组</span><br><span class="hljs-keyword">if</span>(ma[mid/m][mid%m] &gt;= t)&#123;<br>r = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>l = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="搜索二维矩阵-1">搜索二维矩阵 ||</h2><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵<code>matrix</code> 中的一个目标值 <code>target</code>。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p>1）一次二分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 遍历第每一行 + 二分查找当前行</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v, <span class="hljs-type">int</span> t)</span> </span>&#123;<br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>(), m = v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">binary_search</span>(v[i].<span class="hljs-built_in">begin</span>(), v[i].<span class="hljs-built_in">end</span>(), t)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）两次二分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> ex, <span class="hljs-type">int</span> t)</span></span>&#123;<br><span class="hljs-type">int</span> l = fx<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = ex;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(v[mid][y] &lt; t)&#123;<br>l = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(v[mid][y] == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>r = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v, <span class="hljs-type">int</span> t)</span> </span>&#123;<br><span class="hljs-comment">// 先用一次二分，找到最小的满足 &lt;= t 条件的列</span><br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>(), m = v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = m;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>][mid] &lt;= t)&#123;<br>l = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>r = mid;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 遍历[0, l]的列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l ; i &gt;= <span class="hljs-number">0</span> ; i --)&#123;<br><span class="hljs-comment">// 对每一列再进行一次二分查找</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">bs</span>(v, i, <span class="hljs-number">0</span>, n, t)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>3）二叉搜索树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inrange</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">0</span> || y &gt;= m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 以右上角(0, m-1)为起点</span><br><span class="hljs-comment">// v[x-1][y] 和 v[x][y+1] 分别为左右子节点</span><br><span class="hljs-comment">// 分别 对应 &lt; 和 &gt;</span><br><span class="hljs-comment">// 之后按二叉搜索树查找即可</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>n = v.<span class="hljs-built_in">size</span>(), m = v[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = m<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">inrange</span>(x, y))&#123;<br><span class="hljs-keyword">if</span>(t == v[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &gt; v[x][y])&#123;<br>x++;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &lt; v[x][y])&#123;<br>y--;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="在排序数组中查找元素的第一个和最后一个位置">在排序数组中查找元素的第一个和最后一个位置</h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值<code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回<code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code>的算法解决此问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 查找满足条件的第一个下标；</span><br>    <span class="hljs-comment">// 若找不到，返回-1；</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bs_lower</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(nums[mid] &gt;= f)&#123;<br><span class="hljs-keyword">if</span>(nums[mid] == f) ans = mid;<br>r = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>l = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// 查找满足条件的最后一个下标；</span><br>    <span class="hljs-comment">// 若找不到，返回-1；</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bs_upper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(nums[mid] &gt; f)&#123;<br>r = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(nums[mid] == f) ans = mid;<br>l = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> t)</span> </span>&#123;<br><span class="hljs-type">int</span> low = <span class="hljs-built_in">bs_lower</span>(nums, t);<br><span class="hljs-type">int</span> up = <span class="hljs-built_in">bs_upper</span>(nums, t);<br><span class="hljs-keyword">return</span> &#123;low, up&#125;;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="搜索旋转排序数组">搜索旋转排序数组</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值<strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标<code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了<strong>旋转</strong>，使数组变为<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标<strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code>在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code>。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数<code>target</code> ，如果 <code>nums</code> 中存在这个目标值<code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code>的算法解决此问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> t)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(nums[i] == t) <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 对于任意一个mid</span><br>            <span class="hljs-comment">// 肯定有某一侧是有序的</span><br><span class="hljs-keyword">if</span>(nums[mid] == t) <span class="hljs-keyword">return</span> mid;<br><span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= nums[mid])&#123; <span class="hljs-comment">// 若左侧有序</span><br><span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= t &amp;&amp; t &lt;= nums[mid])&#123; <span class="hljs-comment">// t在有序的一侧</span><br>r = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>l = mid;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 若右侧有序</span><br><span class="hljs-keyword">if</span>(nums[mid] &lt; t &amp;&amp; t &lt;= nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>])&#123; <span class="hljs-comment">// t在有序的一侧</span><br>l = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>r = mid;<br>&#125;<br>&#125;<br>            <span class="hljs-comment">// 若当前的[L,R]已经完全有序，此时代码仍适用于普通情况的二分</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="寻找旋转排序数组中的最小值">寻找旋转排序数组中的最小值</h2><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由<code>1</code> 到 <code>n</code> 次 <strong>旋转</strong>后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code>在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到<code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到<code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code><strong>旋转一次</strong> 的结果为数组<code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code>，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的<strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code>的算法解决此问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]; <br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(nums[mid] &lt;= nums[r])&#123; <span class="hljs-comment">// 若右侧有序，则最小值不在右侧；</span><br>r = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 否则，左侧一定有序，最小值不在左侧</span><br>l = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> nums[r];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="寻找两个正序数组的中位数">寻找两个正序数组的中位数</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code>的正序（从小到大）数组 <code>nums1</code> 和<code>nums2</code>。请你找出并返回这两个正序数组的<strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> m = nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span>(n &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findMedianSortedArrays</span>(nums2, nums1);<br><br><span class="hljs-type">int</span> lmax1, lmax2, rmin1, rmin2, c1, c2;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-number">2</span>*n<span class="hljs-number">+2</span>;<br>        <br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> c1 = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> c2 = n+m-c1;<br>            <br>            <span class="hljs-comment">// 要使找到c1、c2切割位置恰为中位数</span><br>            <span class="hljs-comment">// 需要满足：</span><br>            <span class="hljs-comment">// 1) lmax1 &lt; rmin1</span><br>            <span class="hljs-comment">// 2) lmax2 &lt; rmin2</span><br>            <span class="hljs-comment">// 3) lmax1 &lt; rmin2</span><br>            <span class="hljs-comment">// 4) lmax2 &lt; rmin1</span><br>            <span class="hljs-comment">// 因为2个数组本身有序，所以 1) 和 2) 已满足</span><br>            <span class="hljs-comment">// 我们只需要移动c1, 使得3) 、 4) 满足即可。</span><br>            <br>lmax1 = (c1 == <span class="hljs-number">0</span> ? INT_MIN : nums1[(c1<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]);<br>rmin1 = (c1 == <span class="hljs-number">2</span>*n ? INT_MAX : nums1[c1/<span class="hljs-number">2</span>]);<br>lmax2 = (c2 == <span class="hljs-number">0</span> ? INT_MIN : nums2[(c2<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]);<br>rmin2 = (c2 == <span class="hljs-number">2</span>*m ? INT_MAX : nums2[c2/<span class="hljs-number">2</span>]);<br>            <span class="hljs-comment">// 注意，这里对长度为n、m的数组插入空值#</span><br>            <span class="hljs-comment">// 使得两数组长度为 n*2 + 1 和 m*2 + 1</span><br>            <span class="hljs-comment">// 避免了奇偶数的讨论</span><br><br><span class="hljs-keyword">if</span>(lmax1 &gt; rmin2)&#123;<br>r = c1;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(lmax2 &gt; rmin1)&#123;<br>l = c1;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">double</span> res = <span class="hljs-built_in">max</span>(lmax1, lmax2) + <span class="hljs-built_in">min</span>(rmin1, rmin2);<br><span class="hljs-keyword">return</span> res / <span class="hljs-number">2.0</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：DFS</title>
    <link href="/competition/leetcode/hot-100/dfs/"/>
    <url>/competition/leetcode/hot-100/dfs/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100dfs">LeetCode热题100：DFS</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&amp;envId=top-100-liked">46.全排列 - 力扣（LeetCode）</a></td><td>DFS</td></tr><tr><td><a href="https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&amp;envId=top-100-liked">78.子集 - 力扣（LeetCode）</a></td><td>DFS</td></tr><tr><td><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">17.电话号码的字母组合 - 力扣（LeetCode）</a></td><td>DFS</td></tr><tr><td><a href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">39.组合总和 - 力扣（LeetCode）</a></td><td>DFS</td></tr><tr><td><a href="https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">22.括号生成 - 力扣（LeetCode）</a></td><td>DFS</td></tr><tr><td><a href="https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&amp;envId=top-100-liked">79.单词搜索 - 力扣（LeetCode）</a></td><td>DFS</td></tr><tr><td><a href="https://leetcode.cn/problems/palindrome-partitioning/?envType=study-plan-v2&amp;envId=top-100-liked">131.分割回文串 - 力扣（LeetCode）</a></td><td>DFS+动态规划</td></tr><tr><td><a href="https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&amp;envId=top-100-liked">51.N 皇后 - 力扣（LeetCode）</a></td><td>DFS</td></tr></tbody></table><h2 id="全排列">全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>返回答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span> &gt; &gt; ans;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br>vector&lt;<span class="hljs-type">bool</span> &gt; vis;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == nums.<span class="hljs-built_in">size</span>())&#123;<br>ans.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!vis[i])&#123;<br>vis[i] = <span class="hljs-literal">true</span>;<br>v.<span class="hljs-built_in">push_back</span>(nums[i]);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>, nums);<br>vis[i] = <span class="hljs-literal">false</span>;<br>v.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>vis.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>());<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, nums);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="子集">子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素<strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按<strong>任意顺序</strong> 返回解集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> maxdep, <span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> idx, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == maxdep)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(v);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>v.<span class="hljs-built_in">push_back</span>(nums[i]);<br><span class="hljs-built_in">dfs</span>(maxdep, dep<span class="hljs-number">+1</span>, i<span class="hljs-number">+1</span>, nums);<br>v.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, nums);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="电话号码的排列组合">电话号码的排列组合</h2><p>给定一个仅包含数字 <code>2-9</code>的字符串，返回所有它能表示的字母组合。答案可以按<strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1不对应任何字母。</p><figure><img src="/competition/leetcode/hot-100/dfs/200px-telephone-keypad2svg.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt; v = &#123;&#123;&#125;,&#123;&#125;,&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;j&#x27;</span>,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>&#125;&#125;;<br>vector&lt;string&gt; ans;<br>string tmp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> dep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == s.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-keyword">if</span>(!tmp.<span class="hljs-built_in">empty</span>()) ans.<span class="hljs-built_in">push_back</span>(tmp);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> k = s[dep]-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v[k].<span class="hljs-built_in">size</span>(); i ++)&#123;<br>tmp += v[k][i];<br><span class="hljs-built_in">dfs</span>(s, dep<span class="hljs-number">+1</span>);<br>tmp.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br><span class="hljs-built_in">dfs</span>(digits, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="组合总和">组合总和</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组<code>candidates</code> 和一个目标整数 <code>target</code> ，找出<code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按<strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以<strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于<code>150</code> 个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>vector&lt;<span class="hljs-type">int</span> &gt; tmp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> idx, vector&lt;<span class="hljs-type">int</span>&gt;&amp; c)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cur &gt; t) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(cur == t)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(tmp);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx; i &lt; c.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>tmp.<span class="hljs-built_in">push_back</span>(c[i]);<br><span class="hljs-built_in">dfs</span>(cur+c[i], t, i, c); <span class="hljs-comment">// 这里从i开始，而不是i+1, 使得i可以重复选取</span><br>tmp.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; c, <span class="hljs-type">int</span> t) &#123;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, t, <span class="hljs-number">0</span>, c);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="括号生成">括号生成</h2><p>数字 <code>n</code>代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong> 括号组合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;string&gt; ans;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> n, string s)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l &lt; r || l &gt; n || r &gt; n) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(l == n &amp;&amp; r == n)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(s);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">dfs</span>(l<span class="hljs-number">+1</span>, r, n, s + <span class="hljs-string">&#x27;(&#x27;</span>);<br><span class="hljs-built_in">dfs</span>(l, r<span class="hljs-number">+1</span>, n, s + <span class="hljs-string">&#x27;)&#x27;</span>);<br>&#125;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单词搜索">单词搜索</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code>和一个字符串单词 <code>word</code> 。如果 <code>word</code>存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> dep, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; b, string w)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == w.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)&#123;<br><span class="hljs-type">int</span> nx = x + dirx[i];<br><span class="hljs-type">int</span> ny = y + diry[i];<br><span class="hljs-keyword">if</span>(!(nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; b.<span class="hljs-built_in">size</span>() &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; b[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!vis[nx][ny] &amp;&amp; w[dep<span class="hljs-number">+1</span>] == b[nx][ny])&#123;<br>vis[nx][ny] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(nx, ny, dep<span class="hljs-number">+1</span>, b, w)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>vis[nx][ny] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; b, string w)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; b[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)&#123;<br><span class="hljs-keyword">if</span>(b[i][j] == w[<span class="hljs-number">0</span>])&#123;<br>vis[i][j] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i, j, <span class="hljs-number">0</span>, b, w)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>vis[i][j] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="分割回文串">分割回文串</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code>所有可能的分割方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-type">bool</span> dp[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>];<br>vector&lt;string &gt; tmp;<br>vector&lt;vector&lt;string&gt;&gt; ans;<br><br>    <span class="hljs-comment">// DFS枚举组合</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> d, string s)</span></span>&#123;<br><span class="hljs-keyword">if</span>(d == s.<span class="hljs-built_in">size</span>())&#123;<br>ans.<span class="hljs-built_in">push_back</span>(tmp);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = d; i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(dp[d][i])&#123;<br>tmp.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(d, i-d<span class="hljs-number">+1</span>));<br><span class="hljs-built_in">dfs</span>(i<span class="hljs-number">+1</span>, s);<br>tmp.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br>&#125;<br><br>vector&lt;vector&lt;string&gt; &gt; <span class="hljs-built_in">partition</span>(string s) &#123;、<br>        <span class="hljs-comment">// 先用DP预处理出所有的回文子串</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>dp[i][i] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(i<span class="hljs-number">+1</span> &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] == s[i<span class="hljs-number">+1</span>]) dp[i][i<span class="hljs-number">+1</span>] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">3</span>; len &lt;= s.<span class="hljs-built_in">size</span>(); len++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i+len<span class="hljs-number">-1</span> &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-type">int</span> j = i+len<span class="hljs-number">-1</span>;<br>dp[i][j] = dp[i<span class="hljs-number">+1</span>][j<span class="hljs-number">-1</span>] &amp;&amp; s[i] == s[j];<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, s);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="n皇后">N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>个皇后放置在 <code>n×n</code>的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>分别代表了皇后和空位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>vector&lt;vector&lt;string &gt; &gt; ans;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br><span class="hljs-type">bool</span> col[<span class="hljs-number">100</span>], raw[<span class="hljs-number">100</span>], dia1[<span class="hljs-number">100</span>], dia2[<span class="hljs-number">100</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(raw[x]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(col[y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(dia1[x + y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(dia2[x - y + <span class="hljs-number">50</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> n, <span class="hljs-type">bool</span> s)</span></span>&#123;<br>raw[x] = col[y] = dia1[x + y] = dia2[x - y + <span class="hljs-number">50</span>] = s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(d == n)&#123;<br>            <span class="hljs-comment">// 结果规格化</span><br>vector&lt;string&gt; tmp;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>string t = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(j == v[i]) t += <span class="hljs-string">&#x27;Q&#x27;</span>;<br><span class="hljs-keyword">else</span> t += <span class="hljs-string">&#x27;.&#x27;</span>;<br>&#125;<br>tmp.<span class="hljs-built_in">push_back</span>(t);<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(tmp);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(d, i, n))&#123;<br><span class="hljs-built_in">mark</span>(d, i, n, <span class="hljs-literal">true</span>);<br>v.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">dfs</span>(d<span class="hljs-number">+1</span>, n);<br>v.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">mark</span>(d, i, n, <span class="hljs-literal">false</span>);<br>&#125;<br>&#125;<br>&#125;<br><br>vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：图论</title>
    <link href="/competition/leetcode/hot-100/graph/"/>
    <url>/competition/leetcode/hot-100/graph/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode热题100：图论"><a href="#LeetCode热题100：图论" class="headerlink" title="LeetCode热题100：图论"></a>LeetCode热题100：图论</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked">200. 岛屿数量 - 力扣（LeetCode）</a></td><td>连通图判断</td></tr><tr><td><a href="https://leetcode.cn/problems/rotting-oranges/?envType=study-plan-v2&envId=top-100-liked">994. 腐烂的橘子 - 力扣（LeetCode）</a></td><td>多源BFS</td></tr><tr><td><a href="https://leetcode.cn/problems/course-schedule/?envType=study-plan-v2&envId=top-100-liked">207. 课程表 - 力扣（LeetCode）</a></td><td>拓扑排序</td></tr><tr><td><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/?envType=study-plan-v2&envId=top-100-liked">208. 实现 Trie (前缀树) - 力扣（LeetCode）</a></td><td>前缀树</td></tr></tbody></table><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;g)</span></span>&#123;<br><span class="hljs-keyword">if</span>(g[x][y] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>g[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">4</span> ; i ++)&#123;<br><span class="hljs-type">int</span> nx = x + dirx[i];<br><span class="hljs-type">int</span> ny = y + diry[i];<br><span class="hljs-keyword">if</span>(nx &gt;= g.<span class="hljs-built_in">size</span>() || nx &lt; <span class="hljs-number">0</span> || ny &gt;= g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || ny &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(g[nx][ny] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(nx, ny, g);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; grid.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; grid[i].<span class="hljs-built_in">size</span>() ; j ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i,j, grid)) res++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h2><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p><p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q;<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>]; <span class="hljs-comment">// 移动距离</span><br><span class="hljs-type">int</span> cnt, ans; <span class="hljs-comment">// 使用cnt记录还未腐烂的橘子数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; g)</span></span>&#123;<br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-type">int</span> fx = q.<span class="hljs-built_in">front</span>().first;<br><span class="hljs-type">int</span> fy = q.<span class="hljs-built_in">front</span>().second;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">4</span> ; i ++)&#123;<br><span class="hljs-type">int</span> nx = fx + dirx[i];<br><span class="hljs-type">int</span> ny = fy + diry[i];<br><span class="hljs-keyword">if</span>(!(nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!vis[nx][ny] &amp;&amp; g[nx][ny] == <span class="hljs-number">1</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);<br>vis[nx][ny] = <span class="hljs-literal">true</span>;<br>dis[nx][ny] = dis[fx][fy] + <span class="hljs-number">1</span>;<br>ans = <span class="hljs-built_in">max</span>(dis[nx][ny], ans);<br>cnt--;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; g)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; g.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; g[i].<span class="hljs-built_in">size</span>() ; j ++)&#123;<br><span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-number">2</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>vis[i][j] = <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[i][j] == <span class="hljs-number">1</span>)&#123;<br>cnt++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>vis[i][j] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">bfs</span>(g);<br><span class="hljs-keyword">return</span> cnt ? <span class="hljs-number">-1</span> : ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-type">int</span> ind[<span class="hljs-number">10000</span>], cnt;<br>vector&lt;<span class="hljs-type">int</span> &gt; e[<span class="hljs-number">10000</span>];<br>queue&lt;<span class="hljs-type">int</span> &gt; q;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> num, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pre)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : pre)&#123;<br>ind[v[<span class="hljs-number">0</span>]]++;<br>e[v[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(v[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; num ; i ++)&#123;<br><span class="hljs-keyword">if</span>(ind[i] == <span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(i);<br>cnt++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[f])&#123;<br>ind[it]--;<br><span class="hljs-keyword">if</span>(ind[it] == <span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(it);<br>cnt++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cnt == num;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="实现Trie（前缀树）"><a href="#实现Trie（前缀树）" class="headerlink" title="实现Trie（前缀树）"></a>实现Trie（前缀树）</h2><p><strong><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">bool</span> isEnd; <span class="hljs-comment">// 是否为一个字符串的结尾</span><br>Trie *nex[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 前缀树的每个节点包含 1-26个英文字母</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Trie</span>() &#123;<br>isEnd = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i ++)&#123;<br>nex[i] = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>Trie *p = <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : word)&#123;<br><span class="hljs-keyword">if</span>(!p-&gt;nex[c-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>p-&gt;nex[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>&#125;<br>p = p-&gt;nex[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;<br>p-&gt;isEnd = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>Trie *p = <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : word)&#123;<br><span class="hljs-keyword">if</span>(p-&gt;nex[c-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>p = p-&gt;nex[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> p-&gt;isEnd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>Trie *p = <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : prefix)&#123;<br><span class="hljs-keyword">if</span>(p-&gt;nex[c-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>p = p-&gt;nex[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：二叉树</title>
    <link href="/competition/leetcode/hot-100/binary-tree/"/>
    <url>/competition/leetcode/hot-100/binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100二叉树">LeetCode热题100：二叉树</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/?envType=study-plan-v2&amp;envId=top-100-liked">94.二叉树的中序遍历 - 力扣（LeetCode）</a></td><td>中序遍历</td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&amp;envId=top-100-liked">104.二叉树的最大深度 - 力扣（LeetCode）</a></td><td>树的深度</td></tr><tr><td><a href="https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&amp;envId=top-100-liked">226.翻转二叉树 - 力扣（LeetCode）</a></td><td>树的翻转</td></tr><tr><td><a href="https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&amp;envId=top-100-liked">101.对称二叉树 - 力扣（LeetCode）</a></td><td>树的对称</td></tr><tr><td><a href="https://leetcode.cn/problems/diameter-of-binary-tree/?envType=study-plan-v2&amp;envId=top-100-liked">543.二叉树的直径 - 力扣（LeetCode）</a></td><td>树的直径</td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&amp;envId=top-100-liked">102.二叉树的层序遍历 - 力扣（LeetCode）</a></td><td>层序遍历</td></tr><tr><td><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/?envType=study-plan-v2&amp;envId=top-100-liked">108.将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></td><td>AVL树的构建</td></tr><tr><td><a href="https://leetcode.cn/problems/validate-binary-search-tree/?envType=study-plan-v2&amp;envId=top-100-liked">98.验证二叉搜索树 - 力扣（LeetCode）</a></td><td>递归</td></tr><tr><td><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&amp;envId=top-100-liked">230.二叉搜索树中第 K 小的元素 - 力扣（LeetCode）</a></td><td>中序遍历</td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-right-side-view/?envType=study-plan-v2&amp;envId=top-100-liked">199.二叉树的右视图 - 力扣（LeetCode）</a></td><td>DFS/BFS</td></tr><tr><td><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&amp;envId=top-100-liked">114.二叉树展开为链表 - 力扣（LeetCode）</a></td><td>先序遍历</td></tr><tr><td><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&amp;envId=top-100-liked">105.从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></td><td>先序 +中序建树</td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum-iii/?envType=study-plan-v2&amp;envId=top-100-liked">437.路径总和 III - 力扣（LeetCode）</a></td><td>哈希</td></tr><tr><td><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/?envType=study-plan-v2&amp;envId=top-100-liked">236.二叉树的最近公共祖先 - 力扣（LeetCode）</a></td><td>递归</td></tr><tr><td><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&amp;envId=top-100-liked">124.二叉树中的最大路径和 - 力扣（LeetCode）</a></td><td>递归</td></tr></tbody></table><h2 id="二叉树的中序遍历">二叉树的中序遍历</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的<strong>中序</strong> 遍历</em> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span> &gt; in;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">dfs</span>(p-&gt;left);<br>in.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">dfs</span>(p-&gt;right);<br>&#125;<br>    <br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br><span class="hljs-built_in">dfs</span>(p);<br><span class="hljs-keyword">return</span> in;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的最大深度">二叉树的最大深度</h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong>是指从根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(p-&gt;left), <span class="hljs-built_in">maxDepth</span>(p-&gt;right));<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="翻转二叉树">翻转二叉树</h2><p>给你一棵二叉树的根节点 <code>root</code>，翻转这棵二叉树，并返回其根节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> p;<br><span class="hljs-built_in">invertTree</span>(p-&gt;left);<br><span class="hljs-built_in">invertTree</span>(p-&gt;right);<br><span class="hljs-built_in">swap</span>(p-&gt;left, p-&gt;right);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="对称二叉树">对称二叉树</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameNode</span><span class="hljs-params">(TreeNode *p1, TreeNode *p2)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p1 == <span class="hljs-literal">nullptr</span> &amp;&amp; p2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(p1 == <span class="hljs-literal">nullptr</span> || p2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> p1-&gt;val == p2-&gt;val &amp;&amp; <span class="hljs-built_in">isSameNode</span>(p1-&gt;left, p2-&gt;right) &amp;&amp; <span class="hljs-built_in">isSameNode</span>(p1-&gt;right, p2-&gt;left);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameNode</span>(p-&gt;left, p-&gt;right);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的直径">二叉树的直径</h2><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的<strong>长度</strong> 。这条路径可能经过也可能不经过根节点<code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> max_dep = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 对每个节点，求出 经过该节点的最长路径</span><br>    <span class="hljs-comment">// 这个最长路径 == 向左走的最大距离 + 向右走的最大距离；</span><br>    <span class="hljs-comment">// 这个最长路径的全局最值 就是 树的直径</span><br>    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> d1 = <span class="hljs-number">1</span> + <span class="hljs-built_in">dfs</span>(p-&gt;left); <span class="hljs-comment">// 向左走的最大距离</span><br><span class="hljs-type">int</span> d2 = <span class="hljs-number">1</span> + <span class="hljs-built_in">dfs</span>(p-&gt;right); <span class="hljs-comment">// 向右走的最大距离</span><br>max_dep = <span class="hljs-built_in">max</span>(max_dep, d1 + d2);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(d1, d2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br><span class="hljs-built_in">dfs</span>(p);<br><span class="hljs-keyword">return</span> max_dep;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的层序遍历">二叉树的层序遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的<strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* p) &#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; lev;<br>queue&lt;TreeNode* &gt; q;<br>q.<span class="hljs-built_in">push</span>(p);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br><span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">while</span>(cur--)&#123;<br>TreeNode *f = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>v.<span class="hljs-built_in">push_back</span>(f-&gt;val);<br><span class="hljs-keyword">if</span>(f-&gt;left) q.<span class="hljs-built_in">push</span>(f-&gt;left);<br><span class="hljs-keyword">if</span>(f-&gt;right) q.<span class="hljs-built_in">push</span>(f-&gt;right);<br>&#125;<br>lev.<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br><span class="hljs-keyword">return</span> lev;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="将有序数组转换为二叉搜索树">将有序数组转换为二叉搜索树</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按<strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br>TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>root-&gt;left = <span class="hljs-built_in">build</span>(nums, l, mid<span class="hljs-number">-1</span>);<br>root-&gt;right = <span class="hljs-built_in">build</span>(nums, mid<span class="hljs-number">+1</span>, r);<br><span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="验证二叉搜索树">验证二叉搜索树</h2><p>给你一个二叉树的根节点 <code>root</code>，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>1）判断中序遍历序列是不是升序序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">dfs</span>(p-&gt;left);<br>v.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">dfs</span>(p-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* r)</span> </span>&#123;<br><span class="hljs-built_in">dfs</span>(r);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(v[i] &lt;= v[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）递归判断左/右节点是不是在取值范围[low, up]之间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(TreeNode * p, ll low, ll up)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(p-&gt;val &lt;= low || p-&gt;val &gt;= up) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">judge</span>(p-&gt;left, low, p-&gt;val) &amp;&amp; <span class="hljs-built_in">judge</span>(p-&gt;right, p-&gt;val, up);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* r)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">judge</span>(r, LONG_LONG_MIN, LONG_LONG_MAX);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树中第-k-小的元素">二叉搜索树中第 K 小的元素</h2><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数<code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从1 开始计数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span> || ans != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">dfs</span>(p-&gt;left);<br>cnt--; <span class="hljs-comment">// 中序遍历，找到第k小的就停止递归</span><br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>) ans = p-&gt;val;<br><span class="hljs-built_in">dfs</span>(p-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>cnt = k;<br><span class="hljs-built_in">dfs</span>(r);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的右视图">二叉树的右视图</h2><p>给定一个二叉树的 <strong>根节点</strong><code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>1）DFS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * p, <span class="hljs-type">int</span> dep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(dep &gt; ans.<span class="hljs-built_in">size</span>()) ans.<span class="hljs-built_in">push_back</span>(p-&gt;val); <span class="hljs-comment">//每次都取该深度的第一个相遇节点</span><br><span class="hljs-built_in">dfs</span>(p-&gt;right, dep<span class="hljs-number">+1</span>); <span class="hljs-comment">//先右后左</span><br><span class="hljs-built_in">dfs</span>(p-&gt;left, dep<span class="hljs-number">+1</span>);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* r)</span> </span>&#123;<br><span class="hljs-built_in">dfs</span>(r, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）BFS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* r)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ans;<br>queue&lt;TreeNode *&gt; q;<br>q.<span class="hljs-built_in">push</span>(r);<br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(cur--)&#123;<br>TreeNode* f = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>b = f-&gt;val; <span class="hljs-comment">// 取一个深度的最后一个节点</span><br><span class="hljs-keyword">if</span>(f-&gt;left) q.<span class="hljs-built_in">push</span>(f-&gt;left);<br><span class="hljs-keyword">if</span>(f-&gt;right) q.<span class="hljs-built_in">push</span>(f-&gt;right);<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(b);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树展开为链表">二叉树展开为链表</h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中<code>right</code> 子指针指向链表中下一个结点，而左子指针始终为<code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin"><strong>先序遍历</strong></a>顺序相同。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;TreeNode*&gt; pre;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>pre.<span class="hljs-built_in">push_back</span>(p);<br><span class="hljs-built_in">dfs</span>(p-&gt;left);<br><span class="hljs-built_in">dfs</span>(p-&gt;right);<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* r)</span> </span>&#123;<br><span class="hljs-built_in">dfs</span>(r);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; pre.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>pre[i<span class="hljs-number">-1</span>]-&gt;right = pre[i];<br>pre[i<span class="hljs-number">-1</span>]-&gt;left = <span class="hljs-literal">nullptr</span>;<br>pre[i]-&gt;left = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="从前序与中序遍历序列构造二叉树">从前序与中序遍历序列构造二叉树</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中<code>preorder</code> 是二叉树的<strong>先序遍历</strong>，<code>inorder</code>是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>vector&lt;<span class="hljs-type">int</span> &gt; pre, in;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel &gt; prer) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != pre[prel]) i++;<br>TreeNode *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(in[i]);<br>p-&gt;left = <span class="hljs-built_in">build</span>(prel<span class="hljs-number">+1</span>, prel + (i-inl), inl, i<span class="hljs-number">-1</span>);<br>p-&gt;right = <span class="hljs-built_in">build</span>(prel + (i-inl) + <span class="hljs-number">1</span>, prer, i<span class="hljs-number">+1</span>, inr);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre_, vector&lt;<span class="hljs-type">int</span>&gt;&amp; in_)</span> </span>&#123;<br>pre = pre_;<br>in = in_;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, pre.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, in.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="路径总和-iii">路径总和 III</h2><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数<code>targetSum</code> ，求该二叉树里节点值之和等于<code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong>不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类似于 560 和为k的子数组，用哈希存储走过子路径中数值为 s-t 的数量。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br>ll ans, t;<br>unordered_map&lt;ll, ll&gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p, ll s)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>s += p-&gt;val;<br><span class="hljs-keyword">if</span>(s == t) ans += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(s-t)) ans += mp[s-t];<br>mp[s]++;<br><span class="hljs-built_in">dfs</span>(p-&gt;left, s);<br><span class="hljs-built_in">dfs</span>(p-&gt;right, s);<br>mp[s]--;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* r, ll t_)</span> </span>&#123;<br>t = t_;<br><span class="hljs-built_in">dfs</span>(r, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先">二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 对于一个节点r：</span><br>    <span class="hljs-comment">// 若p，q分别在左右子树中，则此时r就是p，q的最近公共祖先；</span><br>    <span class="hljs-comment">// 若p，q都在左子树，递归查找左节点；</span><br>    <span class="hljs-comment">// 若p，q都在右子树，递归查找右节点；</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* r, TreeNode* p, TreeNode* q)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(!r || r == p || r == q) <span class="hljs-keyword">return</span> r;<br>TreeNode *left = <span class="hljs-built_in">lowestCommonAncestor</span>(r-&gt;left, p, q);<br>TreeNode *right = <span class="hljs-built_in">lowestCommonAncestor</span>(r-&gt;right, p, q);<br><span class="hljs-keyword">if</span>(left &amp;&amp; right) <span class="hljs-keyword">return</span> r;<br><span class="hljs-keyword">return</span> left ? left : right;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树中的最大路径和">二叉树中的最大路径和</h2><p>二叉树中的 <strong>路径</strong>被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中<strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong>节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其<strong>最大路径和</strong> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> ans = INT_MIN; <span class="hljs-comment">// 维护全局最优</span><br>    <span class="hljs-comment">// 假设当前二叉树为 </span><br>    <span class="hljs-comment">//    a</span><br>    <span class="hljs-comment">//   / \</span><br><span class="hljs-comment">    //  b   c</span><br>    <span class="hljs-comment">// getMaxPathSum 返回 a + b 或 a + c 这两条路径二选一的最大值</span><br>    <span class="hljs-comment">// 每次更新 a + getMaxPathSum(b) + getMaxPathSum(c) 的全局最优值即可</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxPathSum</span><span class="hljs-params">(TreeNode *p)</span></span>&#123; <br><span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> lmax = <span class="hljs-built_in">getMaxPathSum</span>(p-&gt;left);<br><span class="hljs-type">int</span> rmax = <span class="hljs-built_in">getMaxPathSum</span>(p-&gt;right);<br>ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, lmax) + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rmax) + p-&gt;val);<br><span class="hljs-type">int</span> res = p-&gt;val + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>(lmax, rmax));<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode *r)</span> </span>&#123;<br><span class="hljs-built_in">getMaxPathSum</span>(r);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：链表</title>
    <link href="/competition/leetcode/hot-100/linked-list/"/>
    <url>/competition/leetcode/hot-100/linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100链表">LeetCode热题100：链表</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">160.相交链表 - 力扣（LeetCode）</a></td><td>相交链表</td></tr><tr><td><a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">206.反转链表 - 力扣（LeetCode）</a></td><td>链表反转</td></tr><tr><td><a href="https://leetcode.cn/problems/palindrome-linked-list/?envType=study-plan-v2&amp;envId=top-100-liked">234.回文链表 - 力扣（LeetCode）</a></td><td>快慢指针，链表反转</td></tr><tr><td><a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&amp;envId=top-100-liked">141.环形链表 - 力扣（LeetCode）</a></td><td>哈希，快慢指针</td></tr><tr><td><a href="https://leetcode.cn/problems/linked-list-cycle-ii/?envType=study-plan-v2&amp;envId=top-100-liked">142.环形链表 II - 力扣（LeetCode）</a></td><td>哈希，快慢指针</td></tr><tr><td><a href="https://leetcode.cn/problems/merge-two-sorted-lists/?envType=study-plan-v2&amp;envId=top-100-liked">21.合并两个有序链表 - 力扣（LeetCode）</a></td><td>合并有序链表</td></tr><tr><td><a href="https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&amp;envId=top-100-liked">2.两数相加 - 力扣（LeetCode）</a></td><td>高精度</td></tr><tr><td><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&amp;envId=top-100-liked">19.删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></td><td>节点删除</td></tr><tr><td><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/?envType=study-plan-v2&amp;envId=top-100-liked">24.两两交换链表中的节点 - 力扣（LeetCode）</a></td><td>交换节点</td></tr><tr><td><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&amp;envId=top-100-liked">25.K 个一组翻转链表 - 力扣（LeetCode）</a></td><td>链表综合</td></tr><tr><td><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&amp;envId=top-100-liked">138.随机链表的复制 - 力扣（LeetCode）</a></td><td>哈希</td></tr><tr><td><a href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">148.排序链表 - 力扣（LeetCode）</a></td><td>合并有序链表，快慢指针</td></tr><tr><td><a href="https://leetcode.cn/problems/merge-k-sorted-lists/?envType=study-plan-v2&amp;envId=top-100-liked">23.合并 K 个升序链表 - 力扣（LeetCode）</a></td><td>优先队列</td></tr><tr><td><a href="https://leetcode.cn/problems/lru-cache/submissions/627886967/?envType=study-plan-v2&amp;envId=top-100-liked">146.LRU 缓存 - 力扣（LeetCode）</a></td><td>循环链表，大模拟</td></tr></tbody></table><h2 id="相交链表">相交链表</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回<code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="/competition/leetcode/hot-100/linked-list/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须<strong>保持其原始结构</strong> 。</p><p>双指针O(M+N)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *h1, ListNode *h2)</span> </span>&#123;<br>        <span class="hljs-comment">// 设链表A,B长度分别为a,b ; 重叠部分长度为c;</span><br>        <span class="hljs-comment">// 指针p1,p2分别从A/B出发，走到头后，再走到B/A；</span><br>        <span class="hljs-comment">// 当走到重叠部分首指针时，恰好有 p1 == p2</span><br>        <span class="hljs-comment">// 因为 a + (b-c) == b + (a-c)</span><br>ListNode *p1 = h1, *p2 = h2;<br><span class="hljs-keyword">while</span>(p1 != p2)&#123;<br>p1 = p1 == <span class="hljs-literal">nullptr</span> ? h2 : p1-&gt;next;<br>p2 = p2 == <span class="hljs-literal">nullptr</span> ? h1 : p2-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> p1;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="反转链表">反转链表</h2><p>给你单链表的头节点 <code>head</code>，请你反转链表，并返回反转后的链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* h)</span> </span>&#123;<br>ListNode* pre = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span>(h)&#123;<br>ListNode *nex = h-&gt;next;<br>h-&gt;next = pre;<br>pre = h;<br>h = nex;<br>&#125;<br><span class="hljs-keyword">return</span> pre;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="回文链表">回文链表</h2><p>给你一个单链表的头节点 <code>head</code>，请你判断该链表是否为回文链表。如果是，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><p>1）转成数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* h)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br><span class="hljs-keyword">while</span>(h != <span class="hljs-literal">nullptr</span>)&#123;<br>v.<span class="hljs-built_in">push_back</span>(h-&gt;val);<br>h = h-&gt;next;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(v[i] != v[v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）快慢指针 + 链表反转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">// 快慢指针</span><br><span class="hljs-comment">// 跳转到 第 (n+1)/2 个 节点</span><br><span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode *h)</span></span>&#123;<br>ListNode *s = h, *f = h;<br><span class="hljs-keyword">while</span>(f != <span class="hljs-literal">nullptr</span> &amp;&amp; f-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>s = s-&gt;next;<br>f = f-&gt;next-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *h)</span></span>&#123;<br>ListNode *pre = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span>(h)&#123;<br>ListNode * nex = h-&gt;next;<br>h-&gt;next = pre;<br>pre = h;<br>h = nex;<br>&#125;<br><span class="hljs-keyword">return</span> pre;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* h)</span> </span>&#123;<br><span class="hljs-comment">// 从中间节点开始，将链表反转，再进行判断</span><br>ListNode *mid = <span class="hljs-built_in">middleNode</span>(h);<br>ListNode *b = <span class="hljs-built_in">reverseList</span>(mid);<br><span class="hljs-keyword">while</span>(b)&#123;<br><span class="hljs-keyword">if</span>(b-&gt;val != h-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>b = b-&gt;next;<br>h = h-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="环形链表">环形链表</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code>指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code>来表示链表尾连接到链表中的位置（索引从 0开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回<code>false</code> 。</p><p>1）哈希</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *h)</span> </span>&#123;<br><span class="hljs-comment">// 用哈希记录之前走过的节点地址</span><br>unordered_set&lt;ListNode*&gt; st;<br><span class="hljs-keyword">while</span>(h != <span class="hljs-literal">nullptr</span>)&#123;<br>st.<span class="hljs-built_in">insert</span>(h);<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(h-&gt;next))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>h = h-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）快慢指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *h)</span> </span>&#123;<br><span class="hljs-comment">// 如果一个链表成环，指针将始终困在环中</span><br><span class="hljs-comment">// 快慢指针最终一定相遇</span><br>ListNode *s = h, *f = h;<br><span class="hljs-keyword">while</span>(f &amp;&amp; f-&gt;next)&#123;<br>s = s-&gt;next;<br>f = f-&gt;next-&gt;next;<br><span class="hljs-keyword">if</span>(s == f) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="环形链表-ii">环形链表 II</h2><p>给定一个链表的头节点 <code>head</code>，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回<code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code>指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code>来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果<code>pos</code> 是<code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code>不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p>1）哈希</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *h)</span> </span>&#123;<br>unordered_set&lt;ListNode*&gt; st;<br><span class="hljs-keyword">while</span>(h != <span class="hljs-literal">nullptr</span>)&#123;<br>st.<span class="hljs-built_in">insert</span>(h);<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(h-&gt;next))&#123;<br><span class="hljs-keyword">return</span> h-&gt;next;<br>&#125;<br>h = h-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）快慢指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *h)</span> </span>&#123;<br>ListNode *s = h, *f = h;<br><span class="hljs-keyword">while</span>(f &amp;&amp; f-&gt;next)&#123;<br>s = s-&gt;next;<br>f = f-&gt;next-&gt;next;<br><span class="hljs-keyword">if</span>(s == f) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 若不成环，直接返回nullptr</span><br><span class="hljs-keyword">if</span>(!(f &amp;&amp; f-&gt;next)) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 若成环:</span><br><span class="hljs-comment">// 设非环上的长度为x步，在环的长度为r步；</span><br><span class="hljs-comment">// 设 f和s相遇时，f 比 s 多 走了 n 圈</span><br><span class="hljs-comment">// 有 f = 2s = s + n*r, 即 s = n*r</span><br><span class="hljs-comment">// 得：只要s再走x步，就走到环的起点（此时s总步数为x+nr, 一定位于环口）</span><br>        <span class="hljs-comment">// 此时，s一直在环内循环，我们将f移动到起点处，当f移动到环口时，s恰移动了x步</span><br>f = h;<br><span class="hljs-keyword">while</span>(s != f)&#123;<br>s = s-&gt;next;<br>f = f-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> f;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并两个有序链表">合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>1）递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* h1, ListNode* h2)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(h1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> h2;<br><span class="hljs-keyword">if</span>(h2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> h1;<br><span class="hljs-keyword">if</span>(h1-&gt;val &lt; h2-&gt;val)&#123;<br>h1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(h1-&gt;next, h2);<br><span class="hljs-keyword">return</span> h1;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>h2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(h2-&gt;next, h1);<br><span class="hljs-keyword">return</span> h2;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）非递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* h1, ListNode* h2)</span> </span>&#123;<br>ListNode* h3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>ListNode* pre = h3;<br><span class="hljs-keyword">while</span>(h1 &amp;&amp; h2)&#123;<br><span class="hljs-keyword">if</span>(h1-&gt;val &lt; h2-&gt;val)&#123;<br>pre-&gt;next = h1;<br>h1 = h1-&gt;next;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>pre-&gt;next = h2;<br>h2 = h2-&gt;next;<br>&#125;<br>pre = pre-&gt;next;<br>&#125;<br><span class="hljs-keyword">while</span>(h1)&#123;<br>pre-&gt;next = h1;<br>h1 = h1-&gt;next;<br>pre = pre-&gt;next;<br>&#125;<br><span class="hljs-keyword">while</span>(h2)&#123;<br>pre-&gt;next = h2;<br>h2 = h2-&gt;next;<br>pre = pre-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> h3-&gt;next;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两数相加">两数相加</h2><p>给你两个 <strong>非空</strong>的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong>的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* h1, ListNode* h2)</span> </span>&#123;<br>ListNode *t1 = h1, *t2 = h2;<br><span class="hljs-comment">// 长度不一致的情况，先补0</span><br><span class="hljs-keyword">while</span>(t1-&gt;next || t2-&gt;next)&#123;<br><span class="hljs-keyword">if</span>(t1-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>t1-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t2-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;<br>t2-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>&#125;<br>t1 = t1-&gt;next; t2 = t2-&gt;next;<br>&#125;<br>t1 = h1, t2 = h2;<br><span class="hljs-keyword">while</span>(t1 &amp;&amp; t2)&#123;<br><span class="hljs-type">int</span> x = t1-&gt;val;<br><span class="hljs-type">int</span> y = t2-&gt;val;<br>t1-&gt;val = (x+y) % <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> add = (x+y) / <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span>(add)&#123; <span class="hljs-comment">// 进位处理</span><br><span class="hljs-keyword">if</span>(t1-&gt;next) t1-&gt;next-&gt;val += add;<br><span class="hljs-keyword">else</span> t1-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(add);<br>&#125;<br>t1 = t1-&gt;next;<br>t2 = t2-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> h1;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="删除链表的倒数第-n-个结点">删除链表的倒数第 N 个结点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code>个结点，并且返回链表的头结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* h, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">// 求长度len</span><br>ListNode *t = h;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(t)&#123;<br>t = t-&gt;next;<br>len++;<br>&#125;<br><span class="hljs-comment">// 删除倒数第 n 个节点，就是删除第 len-n+1 个节点</span><br>ListNode *pre = <span class="hljs-literal">nullptr</span>, *nex = <span class="hljs-literal">nullptr</span>;<br>t = h;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= len-n ; i ++)&#123;<br>pre = t;<br>t = t-&gt;next;<br>nex = t-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(n == len)&#123; <span class="hljs-comment">// 特判：删除的是头节点</span><br>h = h-&gt;next;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>pre-&gt;next = nex;<br>&#125;<br><span class="hljs-keyword">return</span> h;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="两两交换链表中的节点">两两交换链表中的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p>1）修改值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* h)</span> </span>&#123;<br>ListNode *t = h;<br><span class="hljs-keyword">while</span>(t &amp;&amp; t-&gt;next)&#123;<br><span class="hljs-built_in">swap</span>(t-&gt;val, t-&gt;next-&gt;val);<br>t = t-&gt;next-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> h;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）不修改值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* h)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(!(h &amp;&amp; h-&gt;next)) <span class="hljs-keyword">return</span> h; <span class="hljs-comment">// 特判长度为0和1</span><br><span class="hljs-comment">// pre-&gt;L-&gt;R-&gt;nex</span><br>ListNode *dum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, h);<br>ListNode *p = dum;<br><span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;next)&#123;<br>ListNode *l = p-&gt;next;<br>ListNode *r = p-&gt;next-&gt;next;<br>l-&gt;next = r-&gt;next;<br>r-&gt;next = l;<br>p-&gt;next = r;<br>p = l;<br>&#125;<br><span class="hljs-keyword">return</span> dum-&gt;next;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="k-个一组翻转链表">K 个一组翻转链表</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code>个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code>是一个正整数，它的值小于或等于链表的长度。如果节点总数不是<code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br><span class="hljs-comment">// 反转链表 s-&gt;e</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *s, ListNode *e)</span></span>&#123;<br>ListNode *pre = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span>(s != e)&#123;<br>ListNode *nex = s-&gt;next;<br>s-&gt;next = pre;<br>pre = s;<br>s = nex;<br>&#125;<br>e-&gt;next = pre;<br>&#125;<br><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* h, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>ListNode *dum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, h);<br>ListNode *l = dum;<br><span class="hljs-keyword">while</span>(l)&#123;<br><span class="hljs-comment">// 检查剩下的长度是否 &gt;= k</span><br>ListNode *r = l;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; r &amp;&amp; i &lt;= k ; i ++)&#123;<br>r = r-&gt;next;<br>&#125;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>;<br><br>ListNode *nex_l = l-&gt;next;<br><span class="hljs-comment">// 翻转区间[l+1, r]</span><br>ListNode *nex = r-&gt;next;<br>ListNode *pre = l;<br><span class="hljs-built_in">reverseList</span>(l-&gt;next, r);<br>pre-&gt;next = r;<br>nex_l-&gt;next = nex;<br><br>l = nex_l;<br>&#125;<br>end: <span class="hljs-keyword">return</span> dum-&gt;next;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="随机链表的复制">随机链表的复制</h2><p>给你一个长度为 <code>n</code>的链表，每个节点包含一个额外增加的随机指针 <code>random</code>，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin">深拷贝</a></strong>。深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong>节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的<code>next</code> 指针和 <code>random</code>指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* h)</span> </span>&#123;<br>unordered_map&lt;Node*, Node*&gt; mp;<br>Node *t = h;<br>Node *dum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>), *pre = dum;<br><span class="hljs-comment">// 第一次遍历：</span><br><span class="hljs-comment">// 创建节点和next联系</span><br><span class="hljs-comment">// 用map将老节点坐标映射到新节点坐标</span><br><span class="hljs-keyword">while</span>(t)&#123;<br>Node * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(t-&gt;val);<br>node-&gt;random = t-&gt;random;<br>pre-&gt;next = node;<br>pre = node;<br>mp[t] = node;<br>t = t-&gt;next;<br>&#125;<br><span class="hljs-comment">// 再次遍历新的链表，建立random关系</span><br>Node * tt = dum-&gt;next;<br><span class="hljs-keyword">while</span>(tt)&#123;<br>tt-&gt;random = mp[tt-&gt;random];<br>tt = tt-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> dum-&gt;next;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="排序链表">排序链表</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong>排列并返回 <strong>排序后的链表</strong> 。</p><p>1）转成数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 链表 -&gt; 数组 -&gt; 排序 -&gt; 链表</span><br><span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* h)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br>ListNode *dum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">while</span>(h)&#123;<br>v.<span class="hljs-built_in">push_back</span>(h-&gt;val);<br>h = h-&gt;next;<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>ListNode * pre = dum;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br>ListNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(it);<br>pre-&gt;next = node;<br>pre = node;<br>&#125;<br><span class="hljs-keyword">return</span> dum-&gt;next;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）归并排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 每次找到一个中间节点，分割2个子链表</span><br>    <span class="hljs-comment">// 对2个子链表分别排序，再合并</span><br><span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* h)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(!(h &amp;&amp; h-&gt;next)) <span class="hljs-keyword">return</span> h;<br>ListNode *mid = <span class="hljs-built_in">findMid</span>(h);<br>ListNode *newh = mid-&gt;next;<br>mid-&gt;next = <span class="hljs-literal">nullptr</span>;<br>ListNode *l = <span class="hljs-built_in">sortList</span>(h);<br>ListNode *r = <span class="hljs-built_in">sortList</span>(newh);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(l, r);<br>&#125;<br>    <span class="hljs-comment">// 返回一个链表的中间节点，即 第 n/2 个 节点</span><br><span class="hljs-function">ListNode* <span class="hljs-title">findMid</span><span class="hljs-params">(ListNode* h)</span></span>&#123;<br>ListNode *s = h, *f = h;<br><span class="hljs-keyword">while</span>(f-&gt;next &amp;&amp; f-&gt;next-&gt;next)&#123;<br>s = s-&gt;next;<br>f = f-&gt;next-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br>    <span class="hljs-comment">// 合并 [h1, null], [h2, null] 2个有序链表</span><br>    <span class="hljs-comment">// 返回合并后的头节点</span><br><span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode *h1, ListNode *h2)</span></span>&#123;<br><span class="hljs-keyword">if</span>(!h1) <span class="hljs-keyword">return</span> h2;<br><span class="hljs-keyword">if</span>(!h2) <span class="hljs-keyword">return</span> h1;<br><span class="hljs-keyword">if</span>(h1-&gt;val &lt; h2-&gt;val)&#123;<br>h1-&gt;next = <span class="hljs-built_in">merge</span>(h1-&gt;next, h2);<br><span class="hljs-keyword">return</span> h1;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>h2-&gt;next = <span class="hljs-built_in">merge</span>(h1, h2-&gt;next);<br><span class="hljs-keyword">return</span> h2;<br>&#125;<br>&#125; <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并-k-个升序链表">合并 K 个升序链表</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>ListNode *dum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>), *pre = dum;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,ListNode*&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,ListNode*&gt; &gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>,ListNode*&gt; &gt; &gt; pq;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; lists.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(lists[i]) pq.<span class="hljs-built_in">push</span>(&#123;lists[i]-&gt;val, lists[i]&#125;);<br>&#125;<br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>ListNode *f = pq.<span class="hljs-built_in">top</span>().second;<br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(f-&gt;next) pq.<span class="hljs-built_in">push</span>(&#123;f-&gt;next-&gt;val, f-&gt;next&#125;);<br>pre-&gt;next = f;<br>pre = f;<br>&#125;<br><span class="hljs-keyword">return</span> dum-&gt;next;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="lru-缓存">LRU 缓存</h2><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU(最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong>作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code>存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字<code>key</code> 已经存在，则变更其数据值 <code>value</code>；如果不存在，则向缓存中插入该组 <code>key-value</code>。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该<strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code>的平均时间复杂度运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 循环链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> key, val;<br>Node *next, *pre;<br><span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> key_ = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> val_ = <span class="hljs-number">0</span>, Node *next_ = <span class="hljs-literal">nullptr</span>, Node *pre_ = <span class="hljs-literal">nullptr</span>)&#123;<br>key = key_;<br>val = val_;<br>next = next_;<br>pre = pre_;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; mp;<br>Node *dum;<br><span class="hljs-type">int</span> siz;<br><br><span class="hljs-comment">// 删除p节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node *p)</span></span>&#123;<br>p-&gt;pre-&gt;next = p-&gt;next;<br>p-&gt;next-&gt;pre = p-&gt;pre;<br>&#125;<br><br><span class="hljs-comment">// 将p在头部</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(Node *p)</span></span>&#123;<br>p-&gt;pre = dum;<br>p-&gt;next = dum-&gt;next;<br>dum-&gt;next-&gt;pre = p;<br>dum-&gt;next = p;<br>&#125;<br><br><span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>siz = capacity;<br>mp.<span class="hljs-built_in">clear</span>();<br>dum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br><span class="hljs-comment">// 构造循环链表，核心在于首个节点需要设置为自环</span><br>dum-&gt;next = dum;<br>dum-&gt;pre = dum;<br>&#125;<br><span class="hljs-comment">// 得到key指向的value</span><br>    <span class="hljs-comment">// 并更新该节点在链表中的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(key))&#123;<br>Node* p = mp[key];<br><span class="hljs-built_in">remove</span>(p);<br><span class="hljs-built_in">push_front</span>(p);<br><span class="hljs-keyword">return</span> p-&gt;val;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">// 若不存在，插入节点（key，value）</span><br>    <span class="hljs-comment">// 若存在，更新value 和 在链表中的位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(key))&#123;<br>Node *p = mp[key];<br><span class="hljs-built_in">remove</span>(p);<br><span class="hljs-built_in">push_front</span>(p);<br>p-&gt;val = value;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>Node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>mp[key] = p;<br><span class="hljs-built_in">push_front</span>(p);<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">size</span>() &gt; siz)&#123;<br>Node *back = dum-&gt;pre;<br>mp.<span class="hljs-built_in">erase</span>(back-&gt;key);<br><span class="hljs-built_in">remove</span>(back);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：前缀和 差分</title>
    <link href="/competition/leetcode/hot-100/prefix-diff/"/>
    <url>/competition/leetcode/hot-100/prefix-diff/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100前缀和-差分">LeetCode热题100：前缀和 差分</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&amp;envId=top-100-liked">56.合并区间 - 力扣（LeetCode）</a></td><td>差分，排序</td></tr><tr><td><a href="https://leetcode.cn/problems/product-of-array-except-self/?envType=study-plan-v2&amp;envId=top-100-liked">238.除自身以外数组的乘积 - 力扣（LeetCode）</a></td><td>前缀和</td></tr></tbody></table><h2 id="合并区间">合并区间</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为<code>intervals[i] = [starti, endi]</code>。请你合并所有重叠的区间，并返回<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p>1）差分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v) &#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span> &gt; <span class="hljs-title">diff</span><span class="hljs-params">(<span class="hljs-number">20010</span>)</span></span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br><span class="hljs-comment">// 对于[1,2], [3,4]的情况，本题需要分别输出。</span><br><span class="hljs-comment">// 通过对每个区间[L,R]*2，分隔2个区间</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-type">int</span> l = v[i][<span class="hljs-number">0</span>]*<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> r = v[i][<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>;<br>diff[l]++;<br>diff[r<span class="hljs-number">+1</span>]--;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; diff.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>diff[i] += diff[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; diff.<span class="hljs-built_in">size</span>() ; i++)&#123;<br><span class="hljs-keyword">if</span>(diff[i] != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">while</span>(diff[j] != <span class="hljs-number">0</span>) j++;<br>ans.<span class="hljs-built_in">push_back</span>(&#123;i/<span class="hljs-number">2</span>, (j<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>&#125;);<br>i = j;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; v) &#123;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 排序后，记录重叠数组即可</span><br><span class="hljs-type">int</span> l = v[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], r = v[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(v[i][<span class="hljs-number">0</span>] &lt;= r)&#123;<br>                <span class="hljs-comment">// 若和上一个区间出现重叠，拓展右边界</span><br>r = <span class="hljs-built_in">max</span>(r, v[i][<span class="hljs-number">1</span>]);<br>&#125;<span class="hljs-keyword">else</span>&#123; <br>                <span class="hljs-comment">// 否则上一个区间独立，加入ans</span><br>ans.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);<br>l = v[i][<span class="hljs-number">0</span>]; r = v[i][<span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="除自身以外数组的乘积">除自身以外数组的乘积</h2><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code>，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除<code>nums[i]</code> 之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32位</strong> 整数范围内。</p><p>请 <strong>不要使用除法，</strong>且在 <code>O(n)</code>时间复杂度内完成此题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span> &gt; <span class="hljs-title">pre</span><span class="hljs-params">(nums.size())</span>, <span class="hljs-title">back</span><span class="hljs-params">(nums.size())</span></span>;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) pre[i] = nums[i];<br><span class="hljs-keyword">else</span> pre[i] = nums[i]*pre[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ; i &gt;= <span class="hljs-number">0</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>(i == nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) back[i] = nums[i];<br><span class="hljs-keyword">else</span> back[i] = nums[i]*back[i<span class="hljs-number">+1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-type">int</span> l = i == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : pre[i<span class="hljs-number">-1</span>];<br><span class="hljs-type">int</span> r = i == nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ? <span class="hljs-number">1</span> : back[i<span class="hljs-number">+1</span>];<br>ans.<span class="hljs-built_in">push_back</span>(l*r);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：双指针</title>
    <link href="/competition/leetcode/hot-100/double-pointer/"/>
    <url>/competition/leetcode/hot-100/double-pointer/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100双指针">LeetCode热题100：双指针</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&amp;envId=top-100-liked">283.移动零 - 力扣（LeetCode）</a></td><td>双指针</td></tr><tr><td><a href="https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&amp;envId=top-100-liked">11.盛最多水的容器 - 力扣（LeetCode）</a></td><td>双指针</td></tr><tr><td><a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&amp;envId=top-100-liked">15.三数之和 - 力扣（LeetCode）</a></td><td>双指针</td></tr><tr><td><a href="https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&amp;envId=top-100-liked">142.接雨水 - 力扣（LeetCode）</a></td><td>前缀和，双指针</td></tr><tr><td><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&amp;envId=top-100-liked">3.无重复字符的最长子串 - 力扣（LeetCode）</a></td><td>哈希，双指针</td></tr><tr><td><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/?envType=study-plan-v2&amp;envId=top-100-liked">438.找到字符串中所有字母异位词 - 力扣（LeetCode）</a></td><td>哈希，双指针</td></tr><tr><td><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&amp;envId=top-100-liked">76.最小覆盖子串 - 力扣（LeetCode）</a></td><td>哈希，双指针</td></tr><tr><td><a href="https://leetcode.cn/problems/sort-colors/?envType=study-plan-v2&amp;envId=top-100-liked">75.颜色分类 - 力扣（LeetCode）</a></td><td>双指针</td></tr></tbody></table><h2 id="移动零">移动零</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code>移动到数组的末尾，同时保持非零元素的相对顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> zeros = <span class="hljs-number">0</span>; <span class="hljs-comment">// 有几个0</span><br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用k记录当前新数组下标位置</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums)&#123;<br><span class="hljs-keyword">if</span>(it != <span class="hljs-number">0</span>)&#123;<br>nums[k++] = it; <span class="hljs-comment">// k的最快前进速度不会快于it</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>zeros++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(zeros--) nums[k++] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="盛最多水的容器">盛最多水的容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有<code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是<code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code>轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// l 和 r 分别表示当前的左柱子和右柱子</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l != r) &#123;<br>ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">min</span>(height[r], height[l])*(r-l));<br><span class="hljs-comment">// 每次将较短的柱子向另一个方向移动。</span><br>            <span class="hljs-comment">// 因为若移动较长的柱子，无论如何都不可能比当前更面积更大。</span><br>            <span class="hljs-keyword">if</span>(height[l] &lt; height[r])&#123;<br>l++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>r--;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="三数之和">三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组<code>[nums[i], nums[j], nums[k]]</code> 满足<code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code>。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; ans;<br>        <span class="hljs-comment">// 排序</span><br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 首先枚举第一个数X</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i<span class="hljs-number">+2</span> &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(nums[i] + nums[i<span class="hljs-number">+1</span>] + nums[i<span class="hljs-number">+2</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 优化1</span><br><span class="hljs-keyword">if</span>(nums[i] + nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>] + nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 优化2</span><br><span class="hljs-type">int</span> l = i<span class="hljs-number">+1</span>;<br><span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">// 设置 L，R 分别指向 第二个数 和 第三个数；</span><br>            <span class="hljs-comment">// 若 NUM[L] + NUM[R] &lt; X， 说明需要移动左指针，使总和变大；</span><br>            <span class="hljs-comment">// 若 NUM[L] + NUM[R] &gt; X， 说明需要移动右指针，使总和变小；</span><br><span class="hljs-keyword">while</span>(l &lt; r) &#123; <br><span class="hljs-keyword">if</span>(nums[l] + nums[r] == -nums[i]) &#123; <br>ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);<br><span class="hljs-keyword">for</span> (l++; l &lt; r &amp;&amp; nums[l] == nums[l - <span class="hljs-number">1</span>]; l++);<br><span class="hljs-keyword">for</span> (r--; r &gt; l &amp;&amp; nums[r] == nums[r + <span class="hljs-number">1</span>]; r--);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[l] + nums[r] &gt; -nums[i])&#123;<br>r--;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[l] + nums[r] &lt; -nums[i])&#123;<br>l++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="接雨水">接雨水</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code>的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>1）前缀和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 我们依次考虑每一列的雨水体积。</span><br>    <span class="hljs-comment">// 每一列的雨水体积为 min(左侧最高的柱子，右侧最高的柱子) - 当前列的柱子高度。</span><br>    <span class="hljs-comment">// 用 前缀和、后缀和 优化左右侧的查找即可。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span> &gt; <span class="hljs-title">pre</span><span class="hljs-params">(h.size())</span>, <span class="hljs-title">back</span><span class="hljs-params">(h.size())</span></span>;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>pre[<span class="hljs-number">0</span>] = h[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; h.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>pre[i] = <span class="hljs-built_in">max</span>(pre[i<span class="hljs-number">-1</span>], h[i]);<br>&#125;<br>back[h.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>] = h[height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span> ; i &gt;= <span class="hljs-number">0</span> ; i --)&#123;<br>back[i] = <span class="hljs-built_in">max</span>(back[i<span class="hljs-number">+1</span>], h[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> mi = <span class="hljs-built_in">min</span>(pre[i<span class="hljs-number">-1</span>], back[i<span class="hljs-number">+1</span>]);<br>ans += <span class="hljs-built_in">max</span>(mi - height[i], <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; h)</span> </span>&#123;<br>        <span class="hljs-comment">// 我们设置2个指针L，R</span><br>        <span class="hljs-comment">// 设 left_max, right_max 分别为 左侧最大值，右侧最大值。</span><br>        <span class="hljs-comment">// 若 H[L] &lt; H[R]， 说明L指向的列的雨水体积为 max(0, left_max - H[L]) </span><br>        <span class="hljs-comment">// 若 H[L] &gt;= H[R], 说明R指向的列的雨水体积为 max(0, right_max - H[R])</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = h.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> lm = h[l], rm = h[r];<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br><span class="hljs-keyword">if</span>(h[l] &lt; h[r])&#123;<br>ans += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, lm - h[l]);<br>l++;<br>lm = <span class="hljs-built_in">max</span>(lm, h[l]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>ans += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, rm - h[r]);<br>r--;<br>rm = <span class="hljs-built_in">max</span>(rm, h[r]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="无重复字符的最长子串">无重复字符的最长子串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长 子串</strong> 的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// map记录在上一个窗口字符的出现次数</span><br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;<br>        mp[s[l]] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-comment">// 把当前字符插入窗口</span><br>            <span class="hljs-comment">// 若该字符之前出现过，删除直到上一个该字符位置为止的全部字符。</span><br>            mp[s[r]]++;<br>            <span class="hljs-keyword">while</span> (mp[s[r]] &gt;= <span class="hljs-number">2</span>) &#123;<br>                mp[s[l]]--;<br>                l++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(r - l + <span class="hljs-number">1</span>, ans);<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="找到字符串中所有字母异位词">找到字符串中所有字母异位词</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code>中所有 <code>p</code> 的 <strong>异位词</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; p.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> &#123;&#125;; <span class="hljs-comment">// 特判</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span> &gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span>, <span class="hljs-title">pcnt</span><span class="hljs-params">(<span class="hljs-number">27</span>)</span>, ans</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : p)&#123;<br>pcnt[it - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>&#125;<br>        <span class="hljs-comment">// 第一个窗口</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; p.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cnt[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt == pcnt) ans = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">// 从左到右，依次挪动窗口</span><br>        <span class="hljs-comment">// 每次检验该窗口是否符合条件即可。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = p.<span class="hljs-built_in">size</span>() ; i &lt; s.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cnt[s[i-p.<span class="hljs-built_in">size</span>()] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>cnt[s[i] -<span class="hljs-string">&#x27;a&#x27;</span>]++;<br><span class="hljs-keyword">if</span>(cnt == pcnt)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(i-p.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最小覆盖子串">最小覆盖子串</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回<code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果<code>s</code> 中不存在涵盖 <code>t</code>所有字符的子串，则返回空字符串 <code>""</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span> &gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">0</span>)</span></span>; <br>        <span class="hljs-comment">// v 记录当前窗口对字符的需求；</span><br>        <span class="hljs-comment">// &gt; 0 表示仍然对该字符有需求；= 0 表示需求恰满足；&lt; 0 表示需求溢出</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : t) v[it]++;<br>string ans = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, mi = INT_MAX, cnt = t.<span class="hljs-built_in">size</span>(); <br>        <span class="hljs-comment">// cnt记录的是 t的长度 - 当前窗口内与t对应的有效字符数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span> ; r &lt; s.<span class="hljs-built_in">size</span>() ; r ++)&#123;<br>            <span class="hljs-comment">// 将当前字符插入窗口</span><br><span class="hljs-keyword">if</span>(v[s[r]] &gt; <span class="hljs-number">0</span>) cnt--;<br>v[s[r]]--;<br>            <span class="hljs-comment">// 向右移动左指针，删除当前窗口不需要的字符</span><br><span class="hljs-keyword">while</span>(v[s[l]] &lt; <span class="hljs-number">0</span>)&#123;<br>v[s[l]]++; l++;<br>&#125;<br>            <span class="hljs-comment">// 如果当前区间【L,R】已满足条件</span><br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(r-l<span class="hljs-number">+1</span> &lt; mi)&#123;<br>mi = r-l<span class="hljs-number">+1</span>;<br>ans = s.<span class="hljs-built_in">substr</span>(l, r-l<span class="hljs-number">+1</span>);<br>&#125;<br>v[s[l]]++;<br>l++;<br>cnt++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="颜色分类">颜色分类</h2><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组<code>nums</code> ，<strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code>分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><p>1）单指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">swap</span>(nums[i], nums[pre]);<br>pre++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = pre; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">swap</span>(nums[i], nums[pre]);<br>pre++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> p0 = <span class="hljs-number">0</span>, p2 = n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">while</span>(i &lt; p2 &amp;&amp; nums[i] == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-built_in">swap</span>(nums[i], nums[p2]);<br>p2--;<br>&#125;<br><span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">swap</span>(nums[i], nums[p0]);<br>p0++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode热题100：哈希</title>
    <link href="/competition/leetcode/hot-100/hash/"/>
    <url>/competition/leetcode/hot-100/hash/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode热题100哈希">LeetCode热题100：哈希</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&amp;envId=top-100-liked">1.两数之和 - 力扣（LeetCode）</a></td><td>哈希优化查找</td></tr><tr><td><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&amp;envId=top-100-liked">49.字母异位词分组 - 力扣（LeetCode）</a></td><td>哈希表</td></tr><tr><td><a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&amp;envId=top-100-liked">128.最长连续序列 - 力扣（LeetCode）</a></td><td>哈希优化查找</td></tr><tr><td><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked">560.和为 K 的子数组 - 力扣（LeetCode）</a></td><td>哈希，前缀和</td></tr><tr><td><a href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&amp;envId=top-100-liked">169.多数元素 - 力扣（LeetCode）</a></td><td>哈希 / 投票算法</td></tr></tbody></table><h2 id="两数之和">两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值<code>target</code>，请你在该数组中找出 <strong>和为目标值</strong><em><code>target</code></em> 的那 <strong>两个</strong>整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>mp[nums[i]] = i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(target-nums[i]) &amp;&amp; mp[target-nums[i]] != i)&#123;<br><span class="hljs-keyword">return</span> &#123;i, mp[target-nums[i]]&#125;;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="字母异位词分组">字母异位词分组</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong>组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong>是由重新排列源单词的所有字母得到的一个新单词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        <span class="hljs-comment">// 以字母排序后的结果为key，用map对字母异位词进行分组。</span><br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; mp;<br>vector&lt;vector&lt;string &gt; &gt; ans;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : strs)&#123;<br>string s = it;<br><span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(s))&#123;<br>ans[mp[s]].<span class="hljs-built_in">push_back</span>(it);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>mp[s] = ans.<span class="hljs-built_in">size</span>();<br>ans.<span class="hljs-built_in">push_back</span>(&#123;it&#125;);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最长连续序列">最长连续序列</h2><p>给定一个未排序的整数数组 <code>nums</code>，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p>1）排序 + 去重</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>nums.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()), nums.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 排序后已经是上升数组了</span><br>        <span class="hljs-comment">// 检查每个连续区间有多长即可</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(nums[i] == nums[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>)&#123;<br>cnt++;<br>ans = <span class="hljs-built_in">max</span>(ans, cnt);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cnt = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）哈希</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//st去重</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; it : nums)&#123;<br>st.<span class="hljs-built_in">insert</span>(it);<br>&#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 若st-1存在，说明是起点，检查该上升序列有多长；</span><br>        <span class="hljs-comment">// 若st-1不存，说明不是起点，下一个。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; it : st)&#123;<br><span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">count</span>(it<span class="hljs-number">-1</span>))&#123;<br><span class="hljs-type">int</span> x = it;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">count</span>(x<span class="hljs-number">+1</span>))&#123;<br>cnt += <span class="hljs-number">1</span>;<br>x += <span class="hljs-number">1</span>;<br>&#125;<br>ans = <span class="hljs-built_in">max</span>(cnt, ans);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="和为-k-的子数组">和为 K 的子数组</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em>。</p><p>子数组是数组中元素的连续非空序列。</p><p>前缀和，哈希：O(N*logN)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><span class="hljs-comment">// 用哈希表记录某个前缀和数值出现了多少次</span><br><span class="hljs-comment">// 每次查询pre-k是否存在即可</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; nums.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>pre += nums[i];<br><span class="hljs-keyword">if</span>(pre == k) ans++;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(pre-k))&#123;<br>ans += mp[pre-k];<br>&#125;<br>mp[pre] = mp[pre] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="多数元素">多数元素</h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code>，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong><code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>1）哈希</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span> &gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums)&#123;<br>mp[it]++;<br><span class="hljs-keyword">if</span>(mp[it]*<span class="hljs-number">2</span> &gt; nums.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-keyword">return</span> it;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2）投票算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br><span class="hljs-comment">// candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7</span><br><span class="hljs-comment">// count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4  </span><br><span class="hljs-comment">// real:       1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</span><br><br><span class="hljs-comment">// count == 当前统计值，每当count为0时切换为当前数，和真实值相反/相同（相同时，记录的是真实值）</span><br><span class="hljs-comment">// real == 真实值，假设一直统计的是正确值</span><br><span class="hljs-comment">// 因为真实值的数量 &gt; n/2, 所以最后real &gt; 0，且count 也 &gt;= 0</span><br><span class="hljs-comment">// 因此，最后count和real的值一定相同，此时记录的是真实值</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> can, cnt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<br>can = nums[i];<br>cnt = <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(nums[i] == can) cnt++;<br><span class="hljs-keyword">else</span> cnt--;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> can;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>3）栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span> &gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums)&#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() == it)&#123;<br>                st.<span class="hljs-built_in">push</span>(it);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
      <category>热题100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令整理</title>
    <link href="/other/linux-command/"/>
    <url>/other/linux-command/</url>
    
    <content type="html"><![CDATA[<h2 id="linux常用命令整理">Linux常用命令整理</h2><p>目录操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd # 打印当前路径<br>cd src # 跳转到某个位置 ..表示上一级；../..上一级的上一级；<br>ls # 查询当前目录下文件<br>ls -a # 查询隐藏文件<br>ls -l # （ll） 查询当前目录的详细信息，包括文件夹<br>file filename # 输出某个文件的详细信息<br></code></pre></td></tr></table></figure><p>文件操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">读取</span><br>cat file # 输出这个文件的全部内容，用于查看小文件<br><br>head file # 查看文件的头部<br>head --lines=n file # 查看文件的前n行<br>tail file # 查看文件的尾部<br>tail --lines=n file # 查看文件的后n行<br><br>less file # 查看文件的全部内容，允许上下滚动，用于长文件<br>more file # 查看文件的全部内容，只允许向下滚动<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改</span><br><br>vim file # i 进入编辑模式；冒号+wq 保存并退出；q!强制退出<br>vi file <br>nano file<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除</span><br><br>rm file <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯软件赛C++A组省赛真题训练：2025年</title>
    <link href="/competition/lanqiao/2025/"/>
    <url>/competition/lanqiao/2025/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯软件赛ca组省赛真题训练2025年">蓝桥杯软件赛C++A组省赛真题训练：2025年</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P12138">P12138 [蓝桥杯2025 省 A] 寻找质数 - 洛谷</a></td><td>质数筛</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12139">P12139 [蓝桥杯2025 省 A] 黑白棋 - 洛谷</a></td><td>DFS</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12140">P12140 [蓝桥杯2025 省 A] 抽奖 - 洛谷</a></td><td>模拟</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12141">P12141 [蓝桥杯2025 省 A] 红黑树 - 洛谷</a></td><td>二叉树</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12142">P12142 [蓝桥杯2025 省 A] 黑客 - 洛谷</a></td><td>组合数学</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12143">P12143 [蓝桥杯2025 省 A] 好串的数目 - 洛谷</a></td><td>双指针/组合数</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12144">P12144 [蓝桥杯2025 省 A] 地雷阵 - 洛谷</a></td><td>-</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P12145">P12145 [蓝桥杯2025 省 A] 扫地机器人 - 洛谷</a></td><td>-</td></tr></tbody></table><h2 id="寻找质数">寻找质数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 17609</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i*i &lt;= x ; i ++)&#123;<br><span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(cnt &lt; <span class="hljs-number">2025</span>)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(x))&#123;<br>cnt++;<br>cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>x++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="黑白棋">黑白棋</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s[<span class="hljs-number">10</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 101001010011101100010110011001100110</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 在每一行和每一列中，黑色棋子和白色棋子的数量必须相等。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">6</span> ; i ++)&#123;<br><span class="hljs-type">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">6</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) row++;<br><span class="hljs-keyword">if</span>(s[j][i] == <span class="hljs-string">&#x27;1&#x27;</span>) col++;<br>&#125;<br><span class="hljs-keyword">if</span>(row != <span class="hljs-number">3</span> || col != <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 在棋盘的任何一行或一列中，不能有超过两个相同颜色的棋子连续排列</span><br><span class="hljs-comment">// （即不允许出现“黑黑黑”或“白白白”的情况）。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">6</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j<span class="hljs-number">+2</span> &lt;= <span class="hljs-number">6</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(s[i][j] == s[i][j<span class="hljs-number">+1</span>] &amp;&amp; s[i][j] == s[i][j<span class="hljs-number">+2</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(s[j][i] == s[j<span class="hljs-number">+1</span>][i] &amp;&amp; s[j][i] == s[j<span class="hljs-number">+2</span>][i])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 每一行的棋子排列方式必须是唯一的，不能与棋盘中的任何其他行完全相同。</span><br><span class="hljs-comment">// 每一列的棋子排列方式必须是唯一的，不能与棋盘中的任何其他列完全相同。</span><br>string res[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">6</span> ; i ++)&#123;<br>res[i] = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">6</span> ; j ++)&#123;<br>res[i] += s[j][i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">6</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt;= <span class="hljs-number">6</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == s[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(res[i] == res[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == <span class="hljs-number">6</span> &amp;&amp; y == <span class="hljs-number">6</span>)&#123;<br>s[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>())&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">6</span> ; i ++)&#123;<br>cout&lt;&lt;s[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, s[i].<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>);<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>s[x][y] = <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>())&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">6</span> ; i ++)&#123;<br>cout&lt;&lt;s[i].<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, s[i].<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>);<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(x == <span class="hljs-number">6</span>)&#123;<br><span class="hljs-keyword">if</span>(vis[x][y])&#123;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, y<span class="hljs-number">+1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>s[x][y] = <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, y<span class="hljs-number">+1</span>);<br>s[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, y<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(vis[x][y])&#123;<br><span class="hljs-built_in">dfs</span>(x<span class="hljs-number">+1</span>, y);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>s[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-built_in">dfs</span>(x<span class="hljs-number">+1</span>, y);<br>s[x][y] = <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-built_in">dfs</span>(x<span class="hljs-number">+1</span>, y);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>s[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot; 103033&quot;</span>;<br>s[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot; 333033&quot;</span>;<br>s[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot; 333300&quot;</span>;<br>s[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot; 333333&quot;</span>;<br>s[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot; 331331&quot;</span>;<br>s[<span class="hljs-number">6</span>] = <span class="hljs-string">&quot; 303313&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">6</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">6</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> || s[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>vis[i][j] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽奖">抽奖</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br>ll n, m, ans;<br>ll a[<span class="hljs-number">4</span>][maxn], cnt[<span class="hljs-number">4</span>];<br><br><span class="hljs-function">ll <span class="hljs-title">getPrice</span><span class="hljs-params">()</span></span>&#123;<br>ll t[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i++)&#123;<br>t[i] = a[i][cnt[i]];<br>&#125;<br><span class="hljs-comment">// 三个相同的图案，积分 +200；</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">3</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>&#125;<br><span class="hljs-comment">// 三个数字图案，从左到右连续（例如 1,2,3），积分 +200</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>]<span class="hljs-number">-1</span> &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>]<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;<br>&#125;<br><span class="hljs-comment">// 三个数字图案，经过顺序调整后连续（例如 2,1,3 或 3,2,1），积分 +100；</span><br><span class="hljs-built_in">sort</span>(t<span class="hljs-number">+1</span>, t<span class="hljs-number">+4</span>);<br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>]<span class="hljs-number">-1</span> &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>]<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-comment">// 两个相同的图案，积分 +100；</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] || t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br>ll x; cin&gt;&gt;x;<br>cnt[i] = (cnt[i] + x) % n;<br>&#125;<br>ans += <span class="hljs-built_in">getPrice</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(ll j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br>&#125;<br>&#125;<br>cin&gt;&gt;m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="红黑树">红黑树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n, k; cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-type">bool</span> same = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ; i &gt; <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>(k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) same = !same;<br>k = (k<span class="hljs-number">+1</span>)/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(same) cout&lt;&lt;<span class="hljs-string">&quot;RED\n&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;BLACK\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="黑客">黑客</h2><p>（30/100）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll mod = <span class="hljs-number">1000000007</span>;<br><span class="hljs-type">const</span> ll maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><br>ll n, nm;<br>ll a[maxn];<br>ll p[maxn], A, ans;<br>unordered_map&lt;ll, ll&gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n;<br>nm = n<span class="hljs-number">-2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>mp[a[i]]++;<br><span class="hljs-keyword">if</span>(p[a[i]] == <span class="hljs-number">0</span>) p[a[i]] = <span class="hljs-number">1</span>;<br>p[a[i]] *= mp[a[i]];<br>&#125;<br>A = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-2</span> ; i ++)&#123;<br>A = (A*i) % mod;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; it : mp)&#123;<br>ll num = it.first;<br><span class="hljs-keyword">if</span>(nm % num == <span class="hljs-number">0</span> &amp;&amp; mp.<span class="hljs-built_in">count</span>(nm/num) != <span class="hljs-number">0</span>)&#123;<br>ll add = A;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; jt : mp)&#123;<br>ll num2 = jt.first;<br>ll k2 = jt.second;<br>add /= p[num2];<br><span class="hljs-keyword">if</span>(num2 == num || num2 == nm/num)&#123;<br>add *= k2;<br>&#125;<br>&#125;<br>ans += add;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="好串的数目">好串的数目</h2><p>（80/100）区间DP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>string s;<br>ll ans;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y)</span></span>&#123;<br><span class="hljs-type">int</span> xv = x - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-type">int</span> yv = y - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">return</span> xv == yv || xv == yv - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;s;<br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">length</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">length</span>()));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br>dp[i][i] = <span class="hljs-literal">true</span>;<br>ans++;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>dp[i<span class="hljs-number">-1</span>][i] = <span class="hljs-literal">true</span>;<br>ans++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">3</span> ; len &lt;= s.<span class="hljs-built_in">length</span>() ; len ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">0</span> ; l+len<span class="hljs-number">-1</span> &lt; s.<span class="hljs-built_in">length</span>() ; l ++)&#123;<br><span class="hljs-type">int</span> r = l+len<span class="hljs-number">-1</span>;<br>dp[l][r] = (dp[l<span class="hljs-number">+1</span>][r] &amp;&amp; <span class="hljs-built_in">judge</span>(s[l], s[l<span class="hljs-number">+1</span>])) || (dp[l][r<span class="hljs-number">-1</span>] &amp;&amp; <span class="hljs-built_in">judge</span>(s[r<span class="hljs-number">-1</span>], s[r]));<br><span class="hljs-keyword">if</span>(dp[l][r]) ans++;<br><span class="hljs-comment">// cout&lt;&lt;l&lt;&lt;&quot;:&quot;&lt;&lt;r&lt;&lt;&quot; -&gt; &quot;&lt;&lt;dp[l][r]&lt;&lt;&quot;\n&quot;;</span><br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（100/100）组合数</p><p>好串可以分为两种：</p><p>A.本身就是连续上升序列；B.由两个连续上升序列合并而成；</p><p>首先，我们将原字符串按极大连续上升序列划分，得到预处理数组len。</p><p>对于每段长度为n的上升序列，A类好串的个数为 1 + 2 + ... +n，用等差数列求和公式即可。</p><p>然后枚举2段相邻的上升序列，假设长度分别为n和m，B类好串的个数为n*m。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span>;<br><br>string s;<br>ll len[maxn], cnt;<br>ll ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br>ll p = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == s[i<span class="hljs-number">-1</span>] || s[i] == s[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>)&#123;<br>p++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>len[cnt++] = p;<br>p = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>len[cnt++] = p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; cnt ; i ++)&#123;<br>ans += len[i] + len[i]*(len[i]<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) ans += len[i]*len[i<span class="hljs-number">-1</span>];<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（100/100）双指针</p><p>设指针L,R所代表的区间 [ L, R]为以R结尾的，最多违反上升规则的一次的最长序列。</p><p>根据这个规则，每次在答案上累加R-L+1即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span>;<br><br>string s;<br>ll ans, cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span> ; r &lt; s.<span class="hljs-built_in">length</span>() ; r ++)&#123;<br><span class="hljs-keyword">if</span>(!(s[r] == s[r<span class="hljs-number">-1</span>] || s[r] == s[r<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>))&#123;<br>cnt++;<br>&#125;<br><span class="hljs-keyword">while</span>(cnt &gt; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(!(s[l<span class="hljs-number">+1</span>] == s[l] || s[l<span class="hljs-number">+1</span>] == s[l] + <span class="hljs-number">1</span>))&#123;<br>cnt--;<br>&#125;<br>l++;<br>&#125;<br>ans += (r-l<span class="hljs-number">+1</span>);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>蓝桥杯</category>
      
      <category>真题模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛真题训练：2025年</title>
    <link href="/competition/GPLT/2025/"/>
    <url>/competition/GPLT/2025/</url>
    
    <content type="html"><![CDATA[<h1 id="gplt团体程序设计天梯赛真题训练2025年">GPLT团体程序设计天梯赛真题训练：2025年</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>分值</th><th>知识点</th></tr></thead><tbody><tr><td>L1-1 珍惜生命</td><td>5</td><td>HelloWorld</td></tr><tr><td>L1-2 偷感好重</td><td>5</td><td>简单运算</td></tr><tr><td>L1-3 高温补贴</td><td>10</td><td>分支</td></tr><tr><td>L1-4 零头就抹了吧</td><td>10</td><td>位运算</td></tr><tr><td>L1-5 这是字符串题</td><td>15</td><td>循环</td></tr><tr><td>L1-6 这不是字符串题</td><td>15</td><td>字符串</td></tr><tr><td>L1-7 大幂数</td><td>20</td><td>循环</td></tr><tr><td>L1-8 现代战争</td><td>20</td><td>优先队列</td></tr><tr><td>L2-1 算式拆解</td><td>25</td><td>栈</td></tr><tr><td>L2-2 三点共线</td><td>25</td><td>计算几何</td></tr><tr><td>L2-3 胖达的山头</td><td>25</td><td>差分</td></tr><tr><td>L2-4 被n整除的n位数</td><td>25</td><td>DFS</td></tr><tr><td>L3-1 人生就像一场旅行</td><td>30</td><td>Floyd</td></tr><tr><td>L3-2 影响力</td><td>30</td><td>数学，前缀和</td></tr></tbody></table><h2 id="l1-1-珍惜生命">L1-1 珍惜生命</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live.&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l1-2-偷感好重">L1-2 偷感好重</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a,b,c;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>cout&lt;&lt;a+b+c;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l1-3-高温补贴">L1-3 高温补贴</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t1,s,t0;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t1&gt;&gt;s&gt;&gt;t0;<br><span class="hljs-keyword">if</span>(s == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(t1 &gt; <span class="hljs-number">35</span> &amp;&amp; t0 &gt;= <span class="hljs-number">33</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Bu Tie\n&quot;</span>;<br>cout&lt;&lt;t1;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t1 &lt;= <span class="hljs-number">35</span> || t0 &lt; <span class="hljs-number">33</span>)&#123; <br>cout&lt;&lt;<span class="hljs-string">&quot;Bu Re\n&quot;</span>;<br>cout&lt;&lt;t0;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(t1 &gt; <span class="hljs-number">35</span> &amp;&amp; t0 &gt;= <span class="hljs-number">33</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Shi Nei\n&quot;</span>;<br>cout&lt;&lt;t1;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Shu Shi\n&quot;</span>;<br>cout&lt;&lt;t0;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l1-4-零头就抹了吧">L1-4 零头就抹了吧</h2><p>位运算，找到最高位的1，输出该位对应二进制数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">32</span> ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>((n&gt;&gt;(i<span class="hljs-number">-1</span>)) &amp; <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>));<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l1-5-这是字符串题">L1-5 这是字符串题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s;<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>],w[<span class="hljs-number">26</span>],ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i ++)&#123;<br>cin&gt;&gt;w[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : s)&#123;<br>cnt[it - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i ++)&#123;<br>ans += cnt[i]*w[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i ++)&#123;<br>cout&lt;&lt;cnt[i]&lt;&lt;(i == <span class="hljs-number">25</span> ? <span class="hljs-string">&quot;\n&quot;</span>:<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l1-6-这不是字符串题">L1-6 这不是字符串题</h2><p>因为输入数组的数值范围在0-26之间，转为包含a-z的字符串，再进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> op; cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">int</span> l1; cin&gt;&gt;l1;<br>string s1 = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l1 ; i ++)&#123;<br><span class="hljs-type">int</span> x; cin&gt;&gt;x;<br>s1 += <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;a&#x27;</span> + x - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> l2; cin&gt;&gt;l2;<br>string s2 = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l2 ; i ++)&#123;<br><span class="hljs-type">int</span> x; cin&gt;&gt;x;<br>s2 += <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;a&#x27;</span> + x - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> f = s.<span class="hljs-built_in">find</span>(s1);<br><span class="hljs-keyword">if</span>(f != <span class="hljs-number">-1</span>) s.<span class="hljs-built_in">replace</span>(f, l1, s2);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>)&#123;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br>res += s[i];<br><span class="hljs-keyword">if</span>(i<span class="hljs-number">+1</span> &lt; s.<span class="hljs-built_in">length</span>())&#123;<br><span class="hljs-type">int</span> x1 = s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> x2 = s[i<span class="hljs-number">+1</span>] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>((x1 + x2) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>res += <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;a&#x27;</span> + (x1+x2)/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br>s = res;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> l, r; cin&gt;&gt;l&gt;&gt;r; l--; r--;<br>string temp = <span class="hljs-string">&quot;&quot;</span>;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i &gt;= l &amp;&amp; i &lt;= r)&#123;<br>temp += s[i];<br><span class="hljs-keyword">if</span>(i == r)&#123;<br><span class="hljs-built_in">reverse</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>());<br>res += temp;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>res += s[i];<br>&#125;<br>&#125;<br>s = res;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> x; cin&gt;&gt;x;<br>s = s + <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;a&#x27;</span> + x - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br>cout&lt;&lt;<span class="hljs-built_in">int</span>(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>+ <span class="hljs-number">1</span>)&lt;&lt;(i == s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;\n&quot;</span>:<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l1-7-大幂数">L1-7 大幂数</h2><p>从高到低，依次枚举k的值，并判断是否合法。</p><p>注意：需要开LL 和 写求幂函数（k &lt;= 30, 快速幂不是必要的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>ll n;<br><span class="hljs-function">ll <span class="hljs-title">mypow</span><span class="hljs-params">(ll a, ll n)</span></span>&#123;<br>ll res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n)&#123;<br><span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) res *= a;<br>a = a*a;<br>n &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//ll mypow(ll a, ll n)&#123;</span><br><span class="hljs-comment">//ll res = 1;</span><br><span class="hljs-comment">//for(int i = 1 ; i &lt;= n ; i ++)&#123;</span><br><span class="hljs-comment">//res *= a;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//return res;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll k)</span></span>&#123;<br>ll sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; ; i ++)&#123;<br>sum += <span class="hljs-built_in">mypow</span>(i, k);<br><span class="hljs-keyword">if</span>(sum == n)&#123;<br>cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;^&quot;</span>&lt;&lt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> ; j &lt;= i ; j ++)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;+&quot;</span>&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot;^&quot;</span>&lt;&lt;k;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(sum &gt; n) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">30</span> ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(i))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Impossible for &quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;.&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l1-8-现代战争">L1-8 现代战争</h2><p>使用row和col分别记录被消除的行和列。</p><p>使用优先队列存储对应数值和坐标，可以快速找到当前最大值及其坐标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m, k;<br><span class="hljs-type">int</span> a[maxn][maxn];<br><span class="hljs-type">bool</span> row[maxn], col[maxn];<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; &gt; pq;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> tx = pq.<span class="hljs-built_in">top</span>().second.first;<br><span class="hljs-type">int</span> ty = pq.<span class="hljs-built_in">top</span>().second.second;<br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(!row[tx] &amp;&amp; !col[ty])&#123;<br>row[tx] = col[ty] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br>pq.<span class="hljs-built_in">push</span>(&#123; a[i][j], &#123;i, j&#125; &#125;);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(k--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(row[i]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-type">bool</span> f = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-keyword">if</span>(col[j]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(f) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;a[i][j];<br>f = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(f) cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l2-1-算式拆解">L2-1 算式拆解</h2><p>栈模拟。</p><p>若 char ==‘）’，将之前的非空临时字符串存入栈，若栈不为空，则输出顶端；</p><p>若 char == '('，将之前的非空临时字符串存入栈；</p><p>若 char == else，将字符存入临时字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s, res;<br>stack&lt;string &gt; st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : s)&#123;<br><span class="hljs-keyword">if</span>(it == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">empty</span>())&#123;<br>st.<span class="hljs-built_in">push</span>(res);<br>res = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;st.<span class="hljs-built_in">top</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(it == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">empty</span>())&#123;<br>st.<span class="hljs-built_in">push</span>(res);<br>res = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>res += it;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l2-2-三点共线">L2-2 三点共线</h2><p>注意：这里不能用set去重，需要存入vector，最后再去重。因为set的遍历比vector要慢，会超时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e7</span>;<br><br>ll n;<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>*N];<br>vector&lt;ll&gt; v[<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>ll x, y; cin&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">if</span>(y == <span class="hljs-number">2</span>)&#123;<br>vis[x + N] = <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>v[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">1</span> ; i ++)&#123;<br><span class="hljs-built_in">sort</span>(v[i].<span class="hljs-built_in">begin</span>(), v[i].<span class="hljs-built_in">end</span>());<br>v[i].<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(v[i].<span class="hljs-built_in">begin</span>(), v[i].<span class="hljs-built_in">end</span>()), v[i].<span class="hljs-built_in">end</span>());<br>&#125;<br><span class="hljs-type">bool</span> f = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x1 : v[<span class="hljs-number">1</span>])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x0 : v[<span class="hljs-number">0</span>])&#123;<br><span class="hljs-keyword">if</span>(vis[x1*<span class="hljs-number">2</span> - x0 + N])&#123;<br>f = <span class="hljs-literal">true</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;[&quot;</span>&lt;&lt;x0&lt;&lt;<span class="hljs-string">&quot;, 0] &quot;</span>&lt;&lt;<span class="hljs-string">&quot;[&quot;</span>&lt;&lt;x1&lt;&lt;<span class="hljs-string">&quot;, 1] &quot;</span>&lt;&lt;<span class="hljs-string">&quot;[&quot;</span>&lt;&lt;x1*<span class="hljs-number">2</span>-x0&lt;&lt;<span class="hljs-string">&quot;, 2]\n&quot;</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!f) cout&lt;&lt;<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l2-3-胖达的山头">L2-3 胖达的山头</h2><p>将ss:hh:tt转为数值，再转化为差分问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> day = <span class="hljs-number">3600</span>*<span class="hljs-number">24</span>;<br><br><span class="hljs-type">int</span> n, ans, diff[day<span class="hljs-number">+1</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">char</span> c;<br><span class="hljs-type">int</span> s1,h1,t1,s2,h2,t2;<br>cin&gt;&gt;s1&gt;&gt;c&gt;&gt;h1&gt;&gt;c&gt;&gt;t1;<br>cin&gt;&gt;s2&gt;&gt;c&gt;&gt;h2&gt;&gt;c&gt;&gt;t2;<br><span class="hljs-type">int</span> l = s1*<span class="hljs-number">3600</span> + h1*<span class="hljs-number">60</span> + t1;<br><span class="hljs-type">int</span> r = s2*<span class="hljs-number">3600</span> + h2*<span class="hljs-number">60</span> + t2;<br>diff[l]++;<br>diff[r<span class="hljs-number">+1</span>]--;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= day ; i ++)&#123;<br>diff[i] += diff[i<span class="hljs-number">-1</span>];<br>ans = <span class="hljs-built_in">max</span>(diff[i], ans);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l2-4-被n整除的n位数">L2-4 被n整除的n位数</h2><p>DFS从高位到低位生成 L - R的n位数，并剪枝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>ll n, l, r;<br><span class="hljs-type">bool</span> f;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll d, ll sum)</span></span>&#123;<br><span class="hljs-keyword">if</span>(sum &gt; r) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(d == n)&#123;<br><span class="hljs-keyword">if</span>(sum &gt;= l &amp;&amp; sum &lt;= r &amp;&amp; sum % d == <span class="hljs-number">0</span>)&#123;<br>f = <span class="hljs-literal">true</span>;<br>cout&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(sum % d == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-built_in">dfs</span>(d<span class="hljs-number">+1</span>, sum*<span class="hljs-number">10</span> + i);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, i);<br>&#125;<br><span class="hljs-keyword">if</span>(!f) cout&lt;&lt;<span class="hljs-string">&quot;No Solution\n&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l3-1-人生就像一场旅行">L3-1 人生就像一场旅行</h2><p>双权值Floyd。</p><p>注意：输出时，需要排除<span class="math inline">\(d[x][x]\)</span>（自己走到自己）的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span>;<br><br><span class="hljs-type">int</span> b, n, m, k;<br><span class="hljs-type">int</span> d[maxn][maxn],w[maxn][maxn];<br>vector&lt;<span class="hljs-type">int</span>&gt; v1, v2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">1</span> ; t &lt;= n ; t ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(d[i][t] == inf) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(d[i][j] &gt; d[i][t] + d[t][j])&#123;<br>d[i][j] = d[i][t] + d[t][j];<br>w[i][j] = w[i][t] + w[t][j];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[i][j] == d[i][t] + d[t][j])&#123;<br>w[i][j] = <span class="hljs-built_in">max</span>(w[i][j], w[i][t] + w[t][j]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">clear</span>(); v<span class="hljs-number">2.</span><span class="hljs-built_in">clear</span>();<br><span class="hljs-type">int</span> max_ = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> x; cin&gt;&gt;x;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i != x &amp;&amp; d[x][i] &lt;= b)&#123;<br>v<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">if</span>(w[x][i] &gt; max_)&#123;<br>max_ = w[x][i];<br>v<span class="hljs-number">2.</span><span class="hljs-built_in">clear</span>();<br>v<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(w[x][i] == max_)&#123;<br>v<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;T_T\n&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;v1[i]&lt;&lt;(i == v<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ? <span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;v2[i]&lt;&lt;(i == v<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ? <span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(d, inf, <span class="hljs-built_in">sizeof</span>(d));<br>cin&gt;&gt;b&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> x, y; cin&gt;&gt;x&gt;&gt;y&gt;&gt;d[x][y]&gt;&gt;w[x][y];<br>d[y][x] = d[x][y]; w[y][x] = w[x][y];<br>&#125;<br><span class="hljs-built_in">floyd</span>();<br><span class="hljs-keyword">while</span>(k--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l3-2-影响力">L3-2 影响力</h2><p>解法1：二维前缀和</p><p>设数组<span class="math inline">\(a[i,j]\)</span>为$ max(i-1,j-1)$</p><p>求出a数组的二维前缀和，就求出了(0, 0) - (i, j)之间的所有点到（0，0）的切比雪夫距离之和。</p><p>对于非原点，按4个象限划分，并复用前缀和数组即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br>vector&lt;vector&lt;ll&gt; &gt; <span class="hljs-built_in">w</span>(n<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;ll&gt;(m<span class="hljs-number">+1</span>));<br>vector&lt;vector&lt;ll&gt; &gt; <span class="hljs-built_in">a</span>(n<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;ll&gt;(m<span class="hljs-number">+1</span>));<br>vector&lt;vector&lt;ll&gt; &gt; <span class="hljs-built_in">c</span>(n<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;ll&gt;(m<span class="hljs-number">+1</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;w[i][j];<br>a[i][j] = <span class="hljs-built_in">max</span>(i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>a[i][j] += a[i<span class="hljs-number">-1</span>][j] + a[i][j<span class="hljs-number">-1</span>] - a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>            <span class="hljs-comment">// 加上四个象限</span><br>c[i][j] += a[i][j];<br>c[i][j] += a[n-i<span class="hljs-number">+1</span>][j];<br>c[i][j] += a[i][m-j<span class="hljs-number">+1</span>];<br>c[i][j] += a[n-i<span class="hljs-number">+1</span>][m-j<span class="hljs-number">+1</span>];<br><span class="hljs-comment">// 减去4个重合边</span><br>            c[i][j] -= a[i][<span class="hljs-number">1</span>] + a[<span class="hljs-number">1</span>][j] + a[n-i<span class="hljs-number">+1</span>][<span class="hljs-number">1</span>] + a[<span class="hljs-number">1</span>][m-j<span class="hljs-number">+1</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cout&lt;&lt;c[i][j]*w[i][j]&lt;&lt;(j == m ? <span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法2：矩阵旋转 + 前缀和</p><p>切比雪夫距离： <span class="math display">\[d[p1][p2] = max\{|x1 - x2|, |y1 - y2|\}\]</span> 曼哈顿距离： <span class="math display">\[d[p1][p2] = |x1 - x2| + |y1 - y2|\]</span></p><p>设 u = (x+y)/2， v = (x-y)/2，得到对应点（u, v),</p><p>旋转后数组（u, v）的曼哈顿距离 就是 原矩阵（x,y）的切比雪夫距离。</p><p>然后，我们可以推出： <span class="math display">\[D_A=\sum_B\frac{|u_A-u_B|+|v_A-v_B|}{2}\\D_A=\frac{1}{2}\left(\sum_B|u_A-u_B|+\sum_B|v_A-v_B|\right) \\\]</span> 然后，对于一个点（u,v），它的曼哈顿距离之和（这里以u的部分为例，v类似）等于： <span class="math display">\[SumU_A=\sum_{B:u_B\leq u_A}(u_A-u_B)+\sum_{B:u_B&gt;u_A}(u_B-u_A) \\SumU_A=\left(u_A\sum_{B:u_B\leq u_A}1-\sum_{B:u_B\lequ_A}u_B\right)+\left(\sum_{B:u_B&gt;u_A}u_B-u_A\sum_{B:u_B&gt;u_A}1\right)\]</span> 令<span class="math inline">\(count(u\lequ_A)\)</span>表示满足<span class="math inline">\(u_B\lequ_A\)</span>的点的数量，<span class="math inline">\(sum(u\lequ_A)\)</span>表示这些点的<span class="math inline">\(u_B\)</span>值之和。</p><p>令<span class="math inline">\(count(u&gt;u_A)\)</span>表示满足<span class="math inline">\(u_B&gt;u_A\)</span>的点的数量，<span class="math inline">\(sum(u&gt;u_A)\)</span>表示这些点的<span class="math inline">\(u_B\)</span>值之和。 <span class="math display">\[SumU_A=[u_A\cdot count(u\leq u_A)-sum(u\lequ_A)]+[sum(u&gt;u_A)-u_A\cdot count(u&gt;u_A)]\]</span> 我们只需要分别求出四个前缀和/ 后缀和数组即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">a</span>(n<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m<span class="hljs-number">+1</span>));<br>vector&lt;vector&lt;ll&gt; &gt; <span class="hljs-built_in">c</span>(n<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;ll&gt;(m<span class="hljs-number">+1</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br>&#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pcu</span><span class="hljs-params">(<span class="hljs-number">2</span>*N)</span>, <span class="hljs-title">pcv</span><span class="hljs-params">(<span class="hljs-number">2</span>*N)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">psu</span><span class="hljs-params">(<span class="hljs-number">2</span>*N)</span>, <span class="hljs-title">psv</span><span class="hljs-params">(<span class="hljs-number">2</span>*N)</span></span>;<br><span class="hljs-comment">// 写int有一个点会过不了</span><br><span class="hljs-comment">// 换成unsigned过了</span><br><span class="hljs-comment">// 求前缀和</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-type">int</span> u = i+j;<br><span class="hljs-type">int</span> v = i-j;<br>pcu[u+N] ++;<br>pcv[v+N] ++;<br>psu[u+N] += u;<br>psv[v+N] += v;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = -N<span class="hljs-number">+5</span> ; i &lt;= N<span class="hljs-number">-5</span> ; i ++)&#123;<br>pcu[i+N] += pcu[i<span class="hljs-number">-1</span>+N];<br>pcv[i+N] += pcv[i<span class="hljs-number">-1</span>+N];<br>psu[i+N] += psu[i<span class="hljs-number">-1</span>+N];<br>psv[i+N] += psv[i<span class="hljs-number">-1</span>+N];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-type">int</span> u = i+j;<br><span class="hljs-type">int</span> v = i-j;<br>c[i][j] += pcu[u+N]*u - psu[u+N];<br>c[i][j] += pcv[v+N]*v - psv[v+N];<br>&#125;<br>&#125;<br><span class="hljs-comment">// 求后缀和</span><br>pcu.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>*N, <span class="hljs-number">0</span>);<br>psu.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>*N, <span class="hljs-number">0</span>);<br>pcv.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>*N, <span class="hljs-number">0</span>);<br>psv.<span class="hljs-built_in">assign</span>(<span class="hljs-number">2</span>*N, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-type">int</span> u = i+j;<br><span class="hljs-type">int</span> v = i-j;<br>pcu[u+N] ++;<br>pcv[v+N] ++;<br>psu[u+N] += u;<br>psv[v+N] += v;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = N<span class="hljs-number">-5</span> ; i &gt;= -N<span class="hljs-number">+5</span> ; i --)&#123;<br>pcu[i+N] += pcu[i<span class="hljs-number">+1</span>+N];<br>pcv[i+N] += pcv[i<span class="hljs-number">+1</span>+N];<br>psu[i+N] += psu[i<span class="hljs-number">+1</span>+N];<br>psv[i+N] += psv[i<span class="hljs-number">+1</span>+N];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-type">int</span> u = i+j;<br><span class="hljs-type">int</span> v = i-j;<br>c[i][j] += psu[u+N] - pcu[u+N]*u;<br>c[i][j] += psv[v+N] - pcv[v+N]*v;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>c[i][j] /= <span class="hljs-number">2</span>;<br>cout&lt;&lt;c[i][j]*a[i][j]&lt;&lt;(j == m ? <span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>真题模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPLT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/cs-cource/operating-system/"/>
    <url>/cs-cource/operating-system/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h2 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1 操作系统"></a>1 操作系统</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>操作系统是一个大型的程序系统，它负责计算机的全部软硬件资源的分配、调度工作，控制并协调并发活动，实现信息的存取和保护。它提供用户接口，使用户获得良好的工作环境。操作系统使整个计算机系统实现了高效率和高度自动化。</p><h3 id="1-2-目标"><a href="#1-2-目标" class="headerlink" title="1.2 目标*"></a>1.2 目标*</h3><p>1）有效性：A.提高系统资源利用率（利用CPU和I&#x2F;O设备的空闲时间） B.提高系统吞吐量（通过调整工作流程，缩短程序运行周期）</p><p>2）方便性：方便用户使用，不必使用机器语言编写程序，可以使用高级语言。</p><p>3）可拓充性：便于增加新的功能和模块，修改老的功能和模块（微内核，客户&#x2F;服务器模式）。</p><p>4）开放性：遵循世界标准规范。</p><h3 id="1-3-作用-主要功能"><a href="#1-3-作用-主要功能" class="headerlink" title="1.3 作用&#x2F;主要功能*"></a>1.3 作用&#x2F;主要功能*</h3><p>1）作为用户与计算机硬件系统之间的接口：A.命令方式；B.系统调用方式；C.图形窗口方式</p><p>2）作为计算机系统资源的管理者：A.处理机管理（进程管理、处理机调度）；B.存储器管理；C.I&#x2F;O设备管理；D.文件管理</p><p>3）实现了对计算机资源的抽象：用户通过OS抽象接口，直接高效使用计算机，不用关心实际物理接口和O&#x2F;I设备。</p><h3 id="1-4-基本特性"><a href="#1-4-基本特性" class="headerlink" title="1.4 基本特性"></a>1.4 基本特性</h3><p>1）并发性：多道，并行与并发。</p><p>2）共享性：互斥共享；同时访问。</p><p>3）虚拟性：时分复用；空分复用。</p><p>4）异步性：进程是以人们不可预知的速度向前推进，多个进程并发执行，但获得所需的资源后才能执行。</p><h3 id="1-5-发展过程"><a href="#1-5-发展过程" class="headerlink" title="1.5 发展过程"></a>1.5 发展过程</h3><p>无操作系统的计算机系统 &#x3D;&gt;单道批处理系统（1950s）&#x3D;&gt; 多道批处理系统（1960s）（开始成为真正的操作系统）&#x3D;&gt;</p><p>分时系统（也叫交互系统）&#x3D;&gt; 实时系统；</p><blockquote><p>从理论角度，可以将现在的操作系统划分为3类：多道批处理系统、分时系统和实时系统</p><p>但实际的操作系统，往往是混合的，不存在纯粹的一类系统。</p></blockquote><h3 id="1-6-推动OS发展的主要动力"><a href="#1-6-推动OS发展的主要动力" class="headerlink" title="1.6 推动OS发展的主要动力"></a>1.6 推动OS发展的主要动力</h3><p>1）推动操作系统发展的主要动力</p><p>2）方便用户</p><p>3）器件的不断更新换代</p><p>4）计算机体系结构的不断发展</p><p>5）新的应用需求</p><h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2 进程管理"></a>2 进程管理</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><blockquote><p>为什么需要线程？</p><p>1）多道程序环境下，程序的执行属于并发执行</p><p>2）操作系统管理上的方便性。更好的管理内存中运行的各个程序</p></blockquote><blockquote><p>PCB有什么作用？</p><p>为使程序(含数据)能独立运行，应为之配置进程控制块，即PCB；</p><p>为了能有效管理多道环境下的应用程序，需要相关的管理信息（PCB）。</p><p>进程 &#x3D;&#x3D; 程序+PCB；进程实体 &#x3D;&#x3D; 程序+PCB+相关的数据段。</p></blockquote><h3 id="2-2-特征"><a href="#2-2-特征" class="headerlink" title="2.2 特征"></a>2.2 特征</h3><p>1）结构特征：程序 + PCB &#x3D;&#x3D; 进程；程序 + PCB + 数据段 &#x3D;&#x3D; 进程实体。</p><p>2）动态性：相比程序，进程实体有一定的生命期。</p><p>3）并发性：多个进程实体同存于内存中，且能在一段时间内同时运行。</p><p>4）独立性：能独立运行、独立分配资源和独立接受调度的基本单位。</p><p>5）异步性：进程按各自独立的、 不可预知的速度向前推进。</p><h3 id="2-3-状态"><a href="#2-3-状态" class="headerlink" title="2.3 状态"></a>2.3 状态</h3><p>进程包括如下三种基本状态：</p><img src="/cs-cource/operating-system/image-20250421205732140.png" alt="image-20250421205732140" style="zoom:67%;"><p>在不少系统中进程只有上述三种状态，但在另一些系统中，又增加了一些新状态，最重要的是<strong>挂起</strong>状态。</p><blockquote><p>阻塞和挂起的区别？</p><p>阻塞是进程本身引起的，而挂起的原因都是外部的，不是程序本身的原因。</p></blockquote><p>将挂起称为静止，将未被挂起称为活动，可以得到如下5种状态：</p><img src="/cs-cource/operating-system/image-20250421210438333.png" alt="image-20250421210438333" style="zoom: 50%;"><h3 id="2-4-信号量机制"><a href="#2-4-信号量机制" class="headerlink" title="2.4 信号量机制"></a>2.4 信号量机制</h3><blockquote><p>什么是信号量机制？</p><p>信号量是一个用于表示资源数目的整型量S。</p><p>为使多个进程能互斥地访问某临界资源，对这个信号量的操作，必须通过原子操作来进行。</p></blockquote><p>使用信号量可以实现前趋图中的PV关系。</p><img src="/cs-cource/operating-system/image-20250421210950400.png" alt="image-20250421210950400" style="zoom:67%;"><p>由上述前趋图看，得到的伪代码如下：</p><img src="/cs-cource/operating-system/image-20250421211012072.png" alt="image-20250421211012072" style="zoom:67%;"><p>此处P表示请求信号量，V表示释放信号量；a-g信号量的初始值为0。</p><p><strong>AND信号量</strong>被用于解决多个信号量的死锁问题：</p><img src="/cs-cource/operating-system/image-20250421211420434.png" alt="image-20250421211420434" style="zoom:67%;"><p>AND同步机制的基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Swait</span>(S1，S2，…，Sn)<br>　　<span class="hljs-keyword">if</span> Si&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> … <span class="hljs-keyword">and</span> Sn&gt;=<span class="hljs-number">1</span> then<br>　　　<span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> to n <span class="hljs-keyword">do</span><br>　　　  Si:=Si<span class="hljs-number">-1</span>；<br>　　　endfor<br>　　<span class="hljs-keyword">else</span><br>　　 place the process in the waiting queue associated with the first Si found with Si&lt;<span class="hljs-number">1</span>，<span class="hljs-keyword">and</span> set the program count of <span class="hljs-keyword">this</span> process to the beginning of Swait operation <br>　　endif<br><br><span class="hljs-built_in">Ssignal</span>(S1，S2，…，Sn)<br>  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> to n <span class="hljs-keyword">do</span><br>    Si:=Si<span class="hljs-number">+1</span>；<br>    Remove all the process waiting in the queue associated with Si into the ready queue.<br>  endfor； <br></code></pre></td></tr></table></figure><h3 id="2-5-生产者-消费者"><a href="#2-5-生产者-消费者" class="headerlink" title="2.5 生产者-消费者"></a>2.5 生产者-消费者</h3><img src="/cs-cource/operating-system/image-20250421234744799.png" alt="image-20250421234744799" style="zoom:67%;"><h3 id="2-6-哲学家进餐"><a href="#2-6-哲学家进餐" class="headerlink" title="2.6 哲学家进餐"></a>2.6 哲学家进餐</h3><p>放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用。</p><img src="/cs-cource/operating-system/image-20250421234939518.png" alt="image-20250421234939518" style="zoom:50%;"><p>信号量伪代码：</p><img src="/cs-cource/operating-system/image-20250421235102712.png" alt="image-20250421235102712" style="zoom: 67%;"><img src="/cs-cource/operating-system/image-20250421235647771.png" alt="image-20250421235647771" style="zoom:67%;"><p>虽然上述解法可保证不会有两个相邻的哲学家同时进餐，但有可能引起死锁。</p><p>假如五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量chopstick均为0； 当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期地等待。</p><p>对于这样的死锁问题，可采取以下几种解决方法： </p><p>　　(1) 至多只允许有四位哲学家同时去拿左边的筷子。</p><p>　　(2) 仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。即AND信号量。</p><p>　　(3) 规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子，而偶数号哲学家则相反。按此规定，最后总会有一位哲学家能获得两只筷子而进餐。</p><p>AND信号量（正解）：</p><img src="/cs-cource/operating-system/image-20250421235751158.png" alt="image-20250421235751158" style="zoom: 67%;"><h3 id="2-7-读者-写者"><a href="#2-7-读者-写者" class="headerlink" title="2.7 读者-写者"></a>2.7 读者-写者</h3><p>多个读者进程可以共存，一个写进程和其他读&#x2F;写进程不能共存。</p><img src="/cs-cource/operating-system/image-20250421235902360.png" alt="image-20250421235902360" style="zoom:67%;"><h3 id="2-8-理发师"><a href="#2-8-理发师" class="headerlink" title="2-8 理发师"></a>2-8 理发师</h3><p>一个理发师和一把理发椅子，另有N把椅子供顾客休息等待。</p><p>没有顾客时，理发师休息，等待顾客；</p><p>每个顾客来时，先看是否有椅子空位，有空位，则坐下等待，否则不等待直接走。 </p><img src="/cs-cource/operating-system/image-20250422000010421.png" alt="image-20250422000010421" style="zoom:67%;"><h3 id="2-9-进程通信"><a href="#2-9-进程通信" class="headerlink" title="2-9 进程通信"></a>2-9 进程通信</h3><p>1）共享存储器系统</p><p>​在这种通信方式中，要求诸进程公用某些数据结构（例如，有界缓冲区），借以实现诸进程间的信息交换。</p><p>​<strong>公用数据结构的设置及对进程间同步的处理，都是程序员的职责</strong>。这无疑<strong>增加了程序员的负担</strong>，而操作系统却只须提供共享存储器。程序员的工作比较复杂。</p><p>2）消息传递系统</p><p>​消息传递系统是当前应用<strong>最为广泛</strong>的一种进程间的通信机制。程序员直接利用操作系统提供的一组通信命令，不仅能实现大量数据的传递，而且还<strong>隐藏了通信的实现细节，使通信过程对用户是透明的</strong>，从而大大减化了通信程序编制的复杂性。</p><p>​A.直接通信方法：发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。此时，要求发送进程和接收进程都以显式方式提供对方的标识符。通常，系统提供下述两条通信命令(原语)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Send</span>(Receiver，message)；<span class="hljs-comment">//发送一个消息给接收进程</span><br><span class="hljs-built_in">Receive</span>(Sender，message)；<span class="hljs-comment">//接收Sender发来的消息；Sender也可以不指定。 </span><br></code></pre></td></tr></table></figure><p>​B.间接通信方法：间接通信方式指进程之间的通信需要通过作为共享数据结构的实体。该实体用来暂存发送进程发送给目标进程的消息；接收进程则从该实体中取出对方发送给自己的消息。通常把这种中间实体称为<strong>信箱</strong>。</p><p>3）管道通信</p><p>​所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道(共享文件)提供输入的发送进程(即写进程)，以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。</p><h3 id="2-10-线程"><a href="#2-10-线程" class="headerlink" title="2.10 线程"></a>2.10 线程</h3><p>在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。</p><p>使OS具有更好的并发性，在进程内并发有如下优点：</p><p>​1）并发更加细化；2）方便平行计算（并发）软件的开发。</p><blockquote><p>进程和线程的区别？</p><p>A.进程是作为拥有系统资源的基本单位，包含多个线程并为它们提供资源</p><p>B.一个进程都含有一个或多个相对独立的线程。</p><p>C.进程不再是一个可执行的实体。在多线程OS中，是把线程作为独立运行的基本单位。</p></blockquote><h2 id="3-处理机调度与死锁"><a href="#3-处理机调度与死锁" class="headerlink" title="3 处理机调度与死锁"></a>3 处理机调度与死锁</h2><h3 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h3><p>操作系统处理机调度分为（高级、低级、中级）三种</p><p>1）高级调度（作业调度，接纳调度）：</p><p>​作业是一个比程序更为广泛的概念，不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。</p><p>2）低级调度（进程调度，短程调度）：</p><p>​进程调度用于决定就绪队列中的哪个进程应获得处理机，然后再由分派程序把处理机分配给该进程的具体操作。这是<strong>操作系统真正实现多道并发的关键</strong>。</p><p>​进程调度可采用“抢占&#x2F;非抢占”两种调度方式。非抢占调度指的是：一旦把处理机分配给某进程后，都一直让它运行下去，直至该进程完成；抢占调度允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机重新分配给另一进程。</p><p>3）中级调度（中程调度）：</p><p>​中级调度将暂时不能运行的进程不再占用宝贵的内存资源，调至外存上去等待；当这些进程重又具备运行条件且内存又稍有空闲时，再重新调入内存等待运行。引入中级调度的主要目的是为了提高内存利用率。</p><blockquote><p>早期计算机中普遍采用，目前广泛采用虚拟内存技术，中级调度已不再使用。</p></blockquote><h3 id="3-2-调度队列模型"><a href="#3-2-调度队列模型" class="headerlink" title="3.2 调度队列模型"></a>3.2 调度队列模型</h3><p>1）仅有进程调度的调度队列模型</p><img src="/cs-cource/operating-system/image-20250422203600272.png" alt="image-20250422203600272" style="zoom: 50%;"><p>2）具有高级和低级调度的调度队列模型</p><img src="/cs-cource/operating-system/image-20250422203648144.png" alt="image-20250422203648144" style="zoom:67%;"><p>区别：A.就绪队列的形式和进程来源， 采用高优先权优先调度算法。B.设置多个阻塞队列。</p><p>3）同时具有三级调度的调度队列模型</p><img src="/cs-cource/operating-system/image-20250422203702520.png" alt="image-20250422203702520" style="zoom:67%;"><p>区别：引入中级调度，把就绪状态分为内存就绪和外存就绪。类似地，也可把阻塞状态进一步分成内存阻塞和外存阻塞。</p><h3 id="3-3-调度准则"><a href="#3-3-调度准则" class="headerlink" title="3.3 调度准则"></a>3.3 调度准则</h3><p>1）面向用户的准则：</p><p>​A.周转时间短（常用于批处理系统）；B.响应时间快（常用于分时系统）；</p><p>​C.截止时间的保证（常见于实时系统）。D.优先权准则（含义：让某些紧急的作业能得到及时处理）</p><p>2）面向系统的准则：</p><p>​A.系统吞吐量高（用于批处理系统）；B.各类资源的平衡利用（保持系统中各类资源都处于忙碌状态）；</p><p>​C.处理机利用率好</p><h3 id="3-4-调度算法"><a href="#3-4-调度算法" class="headerlink" title="3.4 调度算法"></a>3.4 调度算法</h3><h3 id="3-5-死锁产生原因和条件"><a href="#3-5-死锁产生原因和条件" class="headerlink" title="3.5 死锁产生原因和条件"></a>3.5 死锁产生原因和条件</h3><p>1）原因：</p><p>​A.竞争资源：系统中供多个进程共享的资源的数目不足以满足诸进程的需要。</p><p>​B.进程间推进顺序不当：进程在运行过程中，请求和释放资源的顺序不合理。</p><p>2）条件：<br>A.互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用（临界资源）。</p><p>​B.请求和保持条件：指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p><p>​C.不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p><p>​D.环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链。</p><h3 id="3-6-预防死锁"><a href="#3-6-预防死锁" class="headerlink" title="3.6 预防死锁"></a>3.6 预防死锁</h3><p>预防死锁指的是：通过设置某些限制条件，去<strong>破坏产生死锁的四个必要条件</strong>中的至少一个，来预防发生死锁。</p><p>预防死锁是一种较易实现的方法，以降低系统资源利用率和系统吞吐量为代价，已被广泛使用。</p><p>1）摒弃“请求和保持”条件</p><p>​系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。</p><p>​缺点：进程是一次性地获得其整个运行过程所需的全部资源的，且独占资源，其中可能有些资源很少使用，甚至在整个运行期间都未使用，这就<strong>严重地恶化了系统资源的利用率</strong>。此外，进程也延迟运行。仅当进程在获得了其所需的全部资源后，才能开始运行。</p><p>2）摒弃“不剥夺”条件</p><p>​缺点：一个资源在使用一段时间后，它的被迫释放可能会造成前段工作的失效。即使是采取了某些防范措施，也还会使进程前后两次运行的信息不连续。</p><p>3）摒弃“环路等待”条件</p><p>​所有进程对资源的请求必须严格按照资源序号递增的次序提出，这样，在所形成的资源分配图中，不可能再出现环路。这种预防死锁的策略与前两种策略比较，其资源利用率和系统吞吐量都有较明显的改善。</p><p>​缺点：系统中各类资源的序号必须相对稳定，这就限制了新类型设备的增加，也必然会限制用户简单、自主地编程。</p><h3 id="3-7-银行家算法"><a href="#3-7-银行家算法" class="headerlink" title="3.7 银行家算法"></a>3.7 银行家算法</h3><p><a href="https://www.bilibili.com/video/BV18M4m1f76s?vd_source=5f2b68719bbd3751e445c4e25eb9e7ae">https://www.bilibili.com/video/BV18M4m1f76s?vd_source=5f2b68719bbd3751e445c4e25eb9e7ae</a></p><h3 id="3-8-死锁的检测与解除"><a href="#3-8-死锁的检测与解除" class="headerlink" title="3.8 死锁的检测与解除"></a>3.8 死锁的检测与解除</h3><p>资源分配图：e&#x3D;{pi，rj}是资源请求边，由进程pi指向资源rj，它表示进程pi请求一个单位的rj资源。e&#x3D;{rj，pi}是资源分配边，由资源rj指向进程pi，它表示把一个单位的资源rj分配给进程pi。</p><img src="/cs-cource/operating-system/image-20250422222049730.png" alt="image-20250422222049730" style="zoom:67%;"><p>S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。该充分条件被称为死锁定理。</p><h2 id="4-存储器管理"><a href="#4-存储器管理" class="headerlink" title="4 存储器管理"></a>4 存储器管理</h2><h3 id="4-1-层次结构"><a href="#4-1-层次结构" class="headerlink" title="4.1 层次结构"></a>4.1 层次结构</h3><img src="/cs-cource/operating-system/image-20250423232812874.png" alt="image-20250423232812874" style="zoom:67%;"><p>1）寄存器：</p><p>​寄存器是真正完成运算的地方，访问速度最快，完全能与CPU协调工作，但价格却十分昂贵。</p><p>2）主存储器：</p><p>​CPU的控制部件只能从主存储器中取得指令和数据。</p><p>​数据能够从主存储器读取并将它们装入到寄存器中，或者从寄存器存入到主存储器。</p><blockquote><p>由于主存储器的访问速度远低于CPU执行指令的速度，为缓和这一矛盾，在计算机系统中引入了寄存器和高速缓存。</p></blockquote><h3 id="4-2-程序执行的步骤"><a href="#4-2-程序执行的步骤" class="headerlink" title="4.2 程序执行的步骤"></a>4.2 程序执行的步骤</h3><p>在多道程序环境下，将一个用户源程序变为一个可在内存中执行的程序，通常都要经过以下几个步骤：</p><p>​编译：由编译程序，将用户源代码编译成若干个目标模块。</p><p>​链接：由链接程序，将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成完整程序。</p><p>​装入：由装入程序，将装入模块装入内存。</p><img src="/cs-cource/operating-system/image-20250424143625742.png" alt="image-20250424143625742" style="zoom:67%;"><h3 id="4-3-程序链接"><a href="#4-3-程序链接" class="headerlink" title="4.3 程序链接"></a>4.3 程序链接</h3><p>根据链接时间的不同，可以将程序链接分为3种：静态链接、</p><p>1）静态链接</p><p>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块（可执行文件），以后不再拆开。</p><p>这种事先进行链接的方式称为静态链接方式。</p><p>2）装入时动态链接</p><p>将用户源程序编译后所得到的一组目标模块，<strong>在装入内存时，采用边装入边链接</strong>的链接方式。</p><p>优点：A.便于修改和更新；B.便于实现对目标模块的共享。</p><p>3）运行时动态链接</p><p>对某些目标模块的链接，是<strong>在程序执行中，需要该目标模块时，才进行链接。</strong></p><blockquote><p>运行时动态链接的原因？</p><p>在一些情况下，事先无法知道本次要运行哪些模块，故只能是将所有可能要运行到的模块都全部装入内存。但这种做法十分低效。所以，当发现一个被调用模块尚未装入内存时，应该立即由OS去找到该模块并将之装入内存，把它链接到调用者模块上。这种做法就是运行时动态链接。</p></blockquote><h3 id="4-4-程序装入"><a href="#4-4-程序装入" class="headerlink" title="4.4 程序装入"></a>4.4 程序装入</h3><p>1）绝对装入方式</p><p>在编译时，如果<strong>知道程序将驻留在内存的什么位置</strong>，那么，编译程序将产生绝对地址的目标代码。最后，按照装入模块中的地址，将程序和数据装入内存。</p><blockquote><p>早期DOS系统、单道批处理系统即采用这种方式</p></blockquote><p>2）可重定向装入方式</p><p>在<strong>多道程序环境下，编译程序不可能预知所编译的目标模块应放在内存的何处</strong>，因此绝对装入方式只适用于单道程序环境。</p><p>可重定向装入方式下，由OS决定应用程序在内存中的位置。</p><p>3）动态运行时装入方式</p><p>可重定位装入方式方式并不允许程序运行时在内存中移动位置。</p><p>在运行过程中<strong>程序在内存中的位置可能经常要改变</strong>，此时就应采用动态运行时装入的方式。</p><h3 id="4-5-内存分配"><a href="#4-5-内存分配" class="headerlink" title="4.5 内存分配"></a>4.5 内存分配</h3><p>1）单一连续分配</p><p>这是最简单的一种存储管理方式，但只能用于<strong>单用户、单任务</strong>的操作系统中。</p><p>把内存分为系统区和用户区两部分，系统区仅提供给OS使用，用户区仅提供给用户使用。</p><p>2）固定分区分配</p><p>将内存的用户空间划分为若干个固定大小（或不同大小）的分区。</p><p>有一用户程序要装入时，由内存分配程序从中找出一个能满足要求的、尚未分配的分区，将之分配给该程序。</p><img src="/cs-cource/operating-system/image-20250424145439671.png" alt="image-20250424145439671" style="zoom:67%;"><p>3）动态分区分配</p><p>动态分区分配是根据进程的实际需要，动态地为之分配内存空间。</p><p>A.首次适应算法（FF）(first fit)</p><p>​在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止；<br>​然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中；<br>​若从链首直至链尾都不能找到一个能满足要求的分区，则此次内存分配失败，返回。</p><p>B.循环首次适应算法(next fit)</p><p>​该算法是由首次适应算法演变而成的。</p><p>​每次不再从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到能满足要求的空闲分区。</p><p>​使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区</p><p>C.最佳适应算法(best fit)</p><p>​每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业。</p><p>​会留下许多难以利用的小空闲区。</p><p>D.最坏适应算法(worst fit)</p><p>​每次为作业分配内存时，总是把能满足要求、又是最大的空闲分区分配给作业。</p><p>​查找效率高，但是会缺乏较大的空闲区。</p><p>E.快速适应算法(quick fit)</p><p>​该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。</p><p>​查找效率高， 但算法复杂，系统开销较大。</p><p>4）动态重定位分区分配</p><p>动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，增加了紧凑的功能。</p><p>如果在系统中只有不相邻接的若干小分区，即使它们容量的总和大于要装入的程序，也无法把该程序装入内存。</p><img src="/cs-cource/operating-system/image-20250424150821879.png" alt="image-20250424150821879" style="zoom:67%;"><p>这种通过移动内存中作业的位置，以把原来多个分散的小分区拼接成一个大分区的方法，称为拼接或紧凑。</p><h3 id="4-6-分页"><a href="#4-6-分页" class="headerlink" title="4.6 分页"></a>4.6 分页</h3><p>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为<strong>页面或页</strong>。</p><p>相应地，也把内存空间分成与页面相同大小的若干个存储块，称为<strong>物理块或页框</strong>。</p><p>在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。</p><p>页面大小由<strong>CPU</strong>决定（在设计CPU时已经确定），操作系统无法改变。</p><p>1）地址计算：</p><img src="/cs-cource/operating-system/image-20250424192302623.png" alt="image-20250424192302623" style="zoom:67%;"><p>2）页表：</p><p>​系统又为每个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号。页表的作用是实现从页号到物理块号的地址映射。</p><img src="/cs-cource/operating-system/image-20250424192426552.png" alt="image-20250424192426552" style="zoom:67%;"><p>3）快表：</p><p>由于页表是存放在内存中的，这使CP在每存取一个数据时，都要两次访问内存。第一次是访问内存中的页表。第二次访问内存时，才是从第一次所得地址中获得所需数据。因此，采用这种方式将使计算机的处理速度降低近1&#x2F;2。为了提高地址变换速度，可在地址变换机构中增设一个特殊高速缓冲寄存器，又称为“联想寄存器”，或称为“快表”</p><p>4）两级&#x2F;多级页表：</p><img src="/cs-cource/operating-system/image-20250424192927286.png" alt="image-20250424192927286" style="zoom:50%;"><p>现代的大多数计算机系统，都支持非常大的逻辑地址空间。在这样的环境下，页表就变得非常大。</p><p>对于32位的机器，采用两级页表结构是合适的；但对于64位的机器，必须采用多级页表（三级页表），将外层页表再进行分页。</p><h3 id="4-7-虚拟内存"><a href="#4-7-虚拟内存" class="headerlink" title="4.7 虚拟内存"></a>4.7 虚拟内存</h3><p>1）常规存储器：</p><p>​一次性：常规的存储管理方式中，都要求<strong>将作业全部装入内存后方能运行</strong>。有些程序每次运行时，并非其全部程序和数据都要用到，这是一种对内存空间的浪费。</p><p>​驻留性：<strong>作业装入内存后，便一直驻留在内存中，直至作业运行结束</strong>。进程会因阻塞而长时间等待，程序有些模块或数据用过一次可能就不再需要了，但它们都仍将继续占用宝贵的内存资源。</p><p>2）分页式虚拟存储系统</p><p>分页式虚拟存储系统是在分页系统的基础上，增加了请求调页功能和页面置换功能所形成的。</p><p>允许装入少数页面的程序(及数据)，便启动运行。以后再通过<strong>调页功能及页面置换功能</strong>，陆续地把随后运行所需的页面调入内存，同时把暂不运行的页面置换到外存上，置换时以页面为单位。</p><p>3）缺页性能影响计算：</p><img src="/cs-cource/operating-system/image-20250424201712290.png" alt="image-20250424201712290" style="zoom:67%;"><h3 id="4-8-物理块的分配策略"><a href="#4-8-物理块的分配策略" class="headerlink" title="4.8 物理块的分配策略"></a>4.8 物理块的分配策略</h3><p>1）固定分配局部置换</p><p>为每个进程分配固定数目的物理块，在整个运行期间都不再改变。</p><p>如果进程在运行中发现缺页，只能从进程在内存的n个页面中选出一页换出，然后再调入新页。</p><p>缺点：应为每个进程分配多少个物理块难以确定。若太少，会频繁地出现缺页中断，会大大降低性能；若太多，浪费，使内存中驻留的进程数目减少，可能造成CPU或其它资源空闲。</p><p>2）可变分配全局置换</p><p>先为系统中的每个进程分配一定数目的物理块，OS自身也保持一个空闲物理块队列。</p><p>当某进程发现缺页时，由系统从空闲物理块队列中取出一个物理块分配给该进程。</p><p>仅当空闲物理块队列中的物理块用完时，OS才能从内存中选择一页调出，可以是系统中任一进程的页（物理块）。</p><p>3）可变分配局部置换</p><p>在1）的基础上，增加如下策略：如果进程在运行中频繁地发生缺页中断，则系统为该进程追加若干数量的物理块，使进程的缺页率减少；反之，若进程在运行过程中的缺页率特别低，则可适当减少分配给该进程的物理块数，但以不引起其缺页率的明显增加为准。</p><h3 id="4-9-页面置换算法"><a href="#4-9-页面置换算法" class="headerlink" title="4.9 页面置换算法"></a>4.9 页面置换算法</h3><p>1）最佳置换算法</p><p>一种理论上的算法。其所选择的被淘汰页面，将是以后永不使用的，或者是在最长时间内不再被访问的页面。</p><blockquote><p>目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的。</p></blockquote><img src="/cs-cource/operating-system/image-20250424201857669.png" alt="image-20250424201857669" style="zoom:67%;"><p>2）先进先出(FIFO)页面置换算法</p><p>最早出现的置换算法。总是淘汰最先进入内存的页面，选择在内存中驻留时间最久的页面予以淘汰。</p><img src="/cs-cource/operating-system/image-20250424201946849.png" alt="image-20250424201946849" style="zoom:67%;"><p>优点：容易实现。</p><p>缺点：性能较差，因为页面调入的先后并不能反映页面的使用情况。</p><p>3）最近最久未使用(LRU)置换算法</p><p>LRU置换算法是选择<strong>最近最久未使用</strong>的页面予以淘汰。</p><img src="/cs-cource/operating-system/image-20250424202138540.png" alt="image-20250424202138540" style="zoom:67%;"><h2 id="5-设备管理"><a href="#5-设备管理" class="headerlink" title="5 设备管理"></a>5 设备管理</h2><h3 id="5-1-设备管理的任务"><a href="#5-1-设备管理的任务" class="headerlink" title="5.1 设备管理的任务"></a>5.1 设备管理的任务</h3><blockquote><p>什么是设备管理？</p></blockquote><h3 id="5-2-I-O系统的组成"><a href="#5-2-I-O系统的组成" class="headerlink" title="5.2 I&#x2F;O系统的组成"></a>5.2 I&#x2F;O系统的组成</h3><p>I&#x2F;O系统包括：设备、控制器 和 总线（或 通道）</p><h3 id="5-3-I-O设备"><a href="#5-3-I-O设备" class="headerlink" title="5.3 I&#x2F;O设备"></a>5.3 I&#x2F;O设备</h3><p>1）存储设备（外存，辅存）</p><p>是计算机系统用以存储信息的主要设备。该类设备存取速度较内存慢，但容量比内存大得多，相对价格也便宜。</p><p>2）输入&#x2F;输出设备（包括输入设备、输出设备和交互式设备）</p><p>输入设备用来接收外部信息，如键盘、鼠标、扫描仪、视频摄像、各类传感器等。输出设备是用于将计算机加工处理后的信息送向外部的设备，如打印机、绘图仪、显示器、数字视频显示设备、音响输出设备等。交互式设备则是集成上述两类设备，利用输入设备接收用户命令信息，并通过输出设备(主要是显示器)同步显示用户命令以及命令执行的结果。如现在的显示屏（触摸屏） 。</p><h3 id="5-4-I-O控制方式"><a href="#5-4-I-O控制方式" class="headerlink" title="5.4 I&#x2F;O控制方式"></a>5.4 I&#x2F;O控制方式</h3><p>1）程序I&#x2F;O方式</p><p>处理机对I&#x2F;O设备的控制采取程序I&#x2F;O(Programmed I&#x2F;O，忙-等待）方式。在处理机向控制器发出一条I&#x2F;O指令启动输入设备输入数据时，要同时把状态寄存器中的忙&#x2F;闲标志busy置为1，然后不断地循环测试busy。当busy&#x3D;1时，表示输入机尚未输完一个字(符)，处理机应继续对该标志进行测试。直至busy&#x3D;0，表明输入机已将输入数据送入控制器的数据寄存器中。然后处理机才能将数据寄存器中的数据取出，送入内存指定单元中，这样便完成了一个字(符)的I&#x2F;O。</p><p>2）中断驱动I&#x2F;O控制方式</p><p>即当某进程要启动某个I&#x2F;O设备工作时，便由CPU向相应的设备控制器发出一条I&#x2F;O命令，CPU不等待I&#x2F;O完成，CPU与I&#x2F;O设备并行操作。以输入为例，设备控制器收到CPU发来的读命令后，便去控制相应的输入设备读数据。一旦数据进入数据寄存器，控制器便通过控制线向CPU发送一中断信号，由CPU检查输入过程中是否出错，若无错，便从控制器发送取走数据的信号。</p><p>优点：使CPU和I&#x2F;O设备都处于忙碌状态，从而提高了整个系统的资源利用率及吞吐量。</p><p>3）直接存储器访问(DMA)I&#x2F;O控制方式</p><p>引入：中断驱动I&#x2F;O已经很有效，但它<strong>仍是以字（字节）为单位进行I&#x2F;O</strong>的，每当完成一个字(节)的I&#x2F;O时，控制器便要向CPU请求一次中断。对于块设备的I&#x2F;O，显然是极其低效的。</p><p>DMA的特征：</p><p>A.CPU与I&#x2F;O设备之间数据传输的基本单位是数据块；</p><p>B.数据从设备直接送入内存的，或者相反；</p><p>C.仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。</p><p>4）I&#x2F;O通道控制方式</p><p>引入：DMA方式中，CPU每发出一条I&#x2F;O指令，也只能去读(或写)一个连续的数据块。而当我们需要一次去读多个数据块且将它们分别传送到不同的内存区域，或者相反时，则须由CPU分别发出多条I&#x2F;O指令及进行多次中断处理才能完成。</p><p>I&#x2F;O通道方式是DMA方式的发展。当CPU只需向I&#x2F;O通道发送一条I&#x2F;O指令，以给出其所要执行的通道程序的首址和要访问的I&#x2F;O设备，通道接到该指令后，通过执行通道程序便可完成指定I&#x2F;O任务。 </p><blockquote><p>总结：</p><p>程序控制：CPU控制下完成整个I&#x2F;O过程，I&#x2F;O过程中CPU必须等待。</p><p>中断控制：CPU不干预I&#x2F;O过程，完成后再由中断通知。注意，一次只能完成一个数的I&#x2F;O。</p><p>DMA控制：控制器自主依次完成多个字节（数据块），每次执行一个I&#x2F;O指令，控制器可以直接访问内存，有计数器。</p><p>I&#x2F;O通道：通道本身是一个特殊的处理器，可以执行多个指令，完成多个数据块的I&#x2F;O。</p></blockquote><h3 id="5-5-缓冲"><a href="#5-5-缓冲" class="headerlink" title="5.5 缓冲"></a>5.5 缓冲</h3><p>目的：缓和CPU与I&#x2F;O设备间速度不匹配的矛盾；减少对CPU中断处理的紧迫性；提高CPU和I&#x2F;O设备之间的并行性。</p><p>原理：<br>1）单缓冲</p><p>每当用户进程发出一I&#x2F;O请求时，操作系统便在主存中为之分配一缓冲区。</p><p>在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理(计算)的时间为C。由于T和C是可以并行的，处理时间表示为Max(C，T)+M。</p><p>2）双缓冲</p><p>为了加快输入和输出速度，提高设备利用率，人们又引入了双缓冲区机制。双缓冲通常能消除用户的等待时间，即用户在输入完第一行之后，在CPU执行第一行中的命令时，用户可继续向第二缓冲区输入下一行数据。</p><p>3）循环缓冲</p><p>输入循环缓冲，可使输入进程和计算进程并行执行。</p><h3 id="5-6-设备分配"><a href="#5-6-设备分配" class="headerlink" title="5.6 设备分配"></a>5.6 设备分配</h3><p>设备分配考虑因素：</p><p>A.设备的固有属性；B.设备分配算法；C.设备分配时的安全性；D.设备独立性。</p><p>设备独立性：</p><p>　　为了提高OS的可适应性和可扩展性，在现代OS中都毫无例外地实现了设备独立性，也称为设备无关性。</p><p>​基本含义是：应用程序独立于具体使用的物理设备。</p><p>​优点：A.设备分配时的灵活性（若进程能以逻辑设备名称来请求某类设备时，系统可立即将该类设备中的任一台分配给进程，仅当所有此类设备已全部分配完毕时，进程才会阻塞）B.易于实现I&#x2F;O重定向（所谓I&#x2F;O重定向，是指用于I&#x2F;O操作的设备可以更换(即重定向)，而不必改变应用程序）</p><h3 id="5-7-SPOOLing技术"><a href="#5-7-SPOOLing技术" class="headerlink" title="5.7 SPOOLing技术"></a>5.7 SPOOLing技术</h3><p>SPOOLing技术包括如下三个部分：</p><p>1）输入井和输出井。在磁盘上开辟的两个专用的存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I&#x2F;O设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。</p><p>2）输入缓冲区和输出缓冲区。为了缓和CPU和磁盘之间速度不匹配的矛盾，在内存中要开辟两个缓冲区：输入缓冲区和输出缓冲区。</p><p>3）输入进程SPi和输出进程SPo。用两个进程来模拟脱机I&#x2F;O时的外围控制机。进程SPi模拟脱机输入的外围机，将用户要求的数据从输入机通过输入缓冲区再送到输入井；进程SPo模拟脱机输出的外围机，把用户要求输出的数据先从内存送到输出井。</p><img src="/cs-cource/operating-system/image-20250424212450141.png" alt="image-20250424212450141" style="zoom:67%;"><h2 id="6-文件管理"><a href="#6-文件管理" class="headerlink" title="6 文件管理"></a>6 文件管理</h2><h3 id="6-1-文件管理的任务"><a href="#6-1-文件管理的任务" class="headerlink" title="6.1 文件管理的任务"></a>6.1 文件管理的任务</h3><p>1）存储空间的管理（分配与回收）</p><p>2）目录管理（数据存取）</p><p>3）文件共享</p><p>4）文件安全性与保护</p><h3 id="6-2-文件"><a href="#6-2-文件" class="headerlink" title="6.2 文件"></a>6.2 文件</h3><p>目前实际的操作系统中，基本只使用两种类型的文件：</p><p>A.文本格式：（行格式，差别）</p><p>B.二进制流：一个简单的内存信息保存。操作系统不做任何格式处理，信息的解释（处理）完全由用户（应用程序）自定。</p><p>文本的属性包括：</p><p>A.类型：可以从不同的角度来规定文件的类型，如源文件、目标文件及可执行文件等。</p><p>B.长度：文件长度指文件的当前长度，长度的单位可以是字节、字或块。</p><p>C.物理位置：该项属性通常是用于指示文件在哪一个设备上及在该设备的哪个位置的指针。</p><p>D.时间信息：建立、修改时间、访问时间。</p><h3 id="6-3-外存分配方式"><a href="#6-3-外存分配方式" class="headerlink" title="6.3 外存分配方式"></a>6.3 外存分配方式</h3><p>1）连续分配</p><p>把逻辑文件中的记录顺序地存储到邻接的各物理盘块中。</p><p>随着文件建立时空间的分配和文件删除时空间的回收，较小的连续区已难于用来存储文件，此即外存碎片。同样，我们也可以利用紧凑的方法，将盘上所有的文件紧靠在一起。</p><p>优点：顺序访问容易，速度快。</p><p>缺点：A.要求有连续的存储空间。因此产生的大量碎片，严重地降低了外存空间的利用率；B.必须事先知道文件的长度；C.对于那些动态增长的文件，需要预分配空间，很低效。</p><p>2）隐式链接分配</p><p>在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针；在每个盘块中也都含有一个指向下一个盘块的指针。</p><p>缺点：它只适合于顺序访问，它对随机访问是极其低效的。</p><p>3）显式链接分配</p><p>把用于链接文件各物理块的指针，全部显式地（集中）存放在硬盘的一个特定的地方，也就是把链表指针集中存放。</p><p>由于查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且大大减少了访问磁盘的次数。</p><p>4）索引分配</p><p>引入：链接分配方式虽然解决了连续分配方式所存在的问题，但又出现了下述另外两个问题。</p><p>A.不能支持高效的直接存取（要对一个较大的文件进行直接存取，须首先在FAT中顺序地查找许多盘块号）；</p><p>B.FAT本身需占用较大的内存空间；</p><p>事实上，在打开某个文件时，只需把该文件占用的盘块的编号调入内存即可，完全没有必要将整个FAT调入内存。</p><p>为此，应将每个文件所对应的盘块号集中地放在一起。为每个文件分配一个索引块，再把分配给该文件的所有盘块号都记录在该索引块中。在建立一个文件时，只需在为之建立的目录项中填上指向该索引块的指针。</p><h3 id="6-4-目录管理"><a href="#6-4-目录管理" class="headerlink" title="6.4 目录管理"></a>6.4 目录管理</h3><p>文件目录是一种数据结构，用于标识系统中的文件及其物理地址，供检索时使用。</p><p>要求：</p><p>1）实现“按名存取”：用户只须向系统提供所需访问文件的名字，便能快速准确地找到指定文件在外存上的存储位置。这是目录管理中<strong>最基本的功能</strong>，也是文件系统向用户提供的最基本的服务。</p><p>2）提高对目录的检索速度：通过合理地组织目录结构的方法，可加快对目录的检索速度，从而提高对文件的存取速度。这是在设计一个大、中型文件系统时所追求的主要目标。</p><p>3）文件共享：在多用户系统中，应<strong>允许多个用户共享一个文件</strong>。这样就须在外存中只保留一份该文件的副本，供不同用户使用，以节省大量的存储空间，并方便用户和提高文件利用率。</p><p>4）允许文件重名：系统应允许不同用户对不同文件采用相同的名字，以便于用户按照自己的习惯给文件命名和使用文件。</p>]]></content>
    
    
    <categories>
      
      <category>专业课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛模拟：2024年校赛</title>
    <link href="/competition/GPLT/2024-school/"/>
    <url>/competition/GPLT/2024-school/</url>
    
    <content type="html"><![CDATA[<h1 id="gplt团体程序设计天梯赛模拟2024年校赛">GPLT团体程序设计天梯赛模拟：2024年校赛</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>分值</th><th>知识点</th></tr></thead><tbody><tr><td>涂色难题</td><td>25</td><td>图论</td></tr><tr><td>幸运数字2</td><td>25</td><td>哈希优化</td></tr><tr><td>保守秘密</td><td>25</td><td>并查集</td></tr><tr><td>博弈大王</td><td>30</td><td>博弈论</td></tr><tr><td>双向奔赴</td><td>30</td><td>Dijkstra最短路</td></tr></tbody></table><h2 id="涂色难题">涂色难题</h2><h3 id="题目描述">题目描述</h3><p>在迷雾山脉的一处洞穴旁发现了一个扭曲的身影。这个生物，名为古鲁姆，拥有着滑腻的灰色皮肤和一对大而凸出的眼睛，这双眼睛在黑暗中闪烁着疯狂和渴望的光芒。他的身体瘦弱，几乎如同骨架包裹在湿冷的皮肤下，每一个动作都透露出狡猾和绝望。古鲁姆看见你们，说：“我守住魔戒数百年了，但是一直得不到它的认可，如果你们能解开魔戒给我出的涂色难题，也许它会跟你们走吧。”魔戒说它会考验你们<code>t</code>次，每次会给出一颗由<code>n</code>个点（不保证每次<code>n</code>的值相同）组成的树，初始情况所有点都是没有颜色的，随后你们任意选择一个点作为树的根节点，随后给所有的点依次涂上颜色，并遵循以下规则：</p><ul><li><p>任意两个相同颜色的点，在只经过同颜色点的情况下，相互可达</p></li><li><p>不可以存在：两个同颜色的点具有相同的深度（深度：当前点距离根节点的距离）</p><p>魔戒希望最后树中的颜色种类最少，请回答每个树在满足涂色规则的前提下需要的最少颜色种类数。</p><h3 id="输入格式">输入格式</h3><p>第一行 输入1个整数：<code>t</code>，表示有<code>t</code>次考验（<code>t</code>组数据）每个考验的第一行是 1 个整数：<code>n</code>，表示树的顶点数目。接下来一行会给出<code>n-1</code>个整数，第<code>i</code>个数表示点<code>i+1</code>和这个数字存在一条边，保证给出的信息可以构建联通所有点的树结构。数据范围：1≤<em>t</em>≤104，1≤<em>n</em>≤106，保证测试数据中的所有<code>n</code>之和不超过106。</p><h3 id="输出格式">输出格式</h3><p>输出<code>t</code>行，每行一个整数，表示要最少使用的颜色种类数目。</p></li></ul><h3 id="输入样例1">输入样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">2<br>5<br>1 1 3 1<br>4<br>1 2 3<br></code></pre></td></tr></table></figure><h3 id="输出样例1">输出样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">2<br>1<br></code></pre></td></tr></table></figure><h3 id="样例解释">样例解释</h3><p><img src="/competition/GPLT/2024-school/3226e1c3-324c-49ee-b081-247402a45db1.png" alt="img_001.PNG"> 样例 1 构造出的树结构如上，我们可以选择 2作为根节点，然后给<code>[2 1 5]</code>涂一个颜色、给<code>[3 4]</code>涂另一个颜色即可。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> t;<br><span class="hljs-type">int</span> ind[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;cin&gt;&gt;n;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">memset</span>(ind,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(ind));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> x;cin&gt;&gt;x;<br>ind[x]++;<br>ind[i<span class="hljs-number">+1</span>]++;<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(ind[i] == <span class="hljs-number">1</span>)&#123;<br>ans++;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="幸运数字2">幸运数字2</h2><h3 id="题目描述-1">题目描述</h3><p>“大部分人的幸运数字是7，而我的幸运数字是2！”一个小男孩摆弄着他手中的数字。接下来男孩会给你们<code>n</code>个整数，如果某 2 个整数相加的和是 2的幂，则称其为幸运对。请输出这<code>n</code>个整数中的幸运对数目。</p><h3 id="输入格式-1">输入格式</h3><p>第一行 输入 1 个整数：<code>n</code>，表示有<code>n</code>个整数。第二行会给出<code>n</code>个整数。数据范围：1≤<em>n</em>≤106，1≤整数大小≤109</p><h3 id="输出格式-1">输出格式</h3><p>输出一个整数，表示输出这<code>n</code>个整数中的幸运对数目。</p><h3 id="输入样例1-1">输入样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">4 <br>7 3 2 1<br></code></pre></td></tr></table></figure><h3 id="输出样例1-1">输出样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">2<br></code></pre></td></tr></table></figure><h3 id="输入样例2">输入样例#2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">3 <br>1 1 1<br></code></pre></td></tr></table></figure><h3 id="输出样例2">输出样例#2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">3<br></code></pre></td></tr></table></figure><h3 id="样例解释-1">样例解释</h3><p>样例 1 可以选择下标<code>(1, 4)</code>和<code>(2, 4)</code>。 样例 2可以选择下标<code>(1, 2)</code>、<code>(1, 3)</code>、<code>(2, 3)</code></p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>ll n,ans;<br>unordered_map&lt;ll, ll &gt; mp; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>ll x;cin&gt;&gt;x;<br>mp[x]++;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">2</span> ; i &lt;= <span class="hljs-number">2e9</span> ; i*=<span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it: mp)&#123;<br>ll k = it.first;<br>ll v = it.second; <br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(i-k))&#123;<br><span class="hljs-keyword">if</span>(k &lt; i/<span class="hljs-number">2</span>)&#123;<br>ans += v*mp[i-k];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == i/<span class="hljs-number">2</span>)&#123;<br>ans += v*(v<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="保守秘密">保守秘密</h2><h3 id="题目描述-2">题目描述</h3><p>在遥远的西西里岛上，这里住着<code>n</code>个岛民。你们得知不久后西西里岛将会被毁灭，善良你和Blice希望将这个消息赶紧告诉全部岛民，且越早越好。由于你们通知岛民需要时间，通知第<code>i</code>个岛民的时间需要*t**i*​​分钟。原本你们需要挨个通知所有岛民，不过幸好，部分岛民之间可以通过电话进行联系。假设岛民之间的相互通知时间可以忽略不计。输出所有岛民都得到消息的最少花费时间（分钟数）。</p><p><strong>注意</strong>：如果你和 Blice希望通知多个岛民，你们需要挨个通知，这意味花费的时间是相加的，而非同时通知取大值。</p><h3 id="输入格式-2">输入格式</h3><p>第一行输入 2个整数：<code>n m</code>，表示有<code>n</code>个岛民，其中<code>m</code>对岛民之间可以直接相互通知。第二行输入<code>n</code>个整数，第<code>i</code>个整数表示你们通知第<code>i</code>个岛民的时间需要<em>t<strong>i<em>​分钟。接下来<code>m</code>行每行会给出两个整数，表示这两个村民之间可以进行通知。（保证无重边、自环）数据范围：1≤</em>n<em>≤106，0≤</em>m<em>≤106，1≤</em>t</strong>i</em>​≤109</p><h3 id="输出格式-2">输出格式</h3><p>输出一个整数，表示最少花费时间。</p><h3 id="输入样例1-2">输入样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs in">5 2<br>2 5 3 4 8<br>1 4<br>4 5<br></code></pre></td></tr></table></figure><h3 id="输出样例1-2">输出样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">10<br></code></pre></td></tr></table></figure><h3 id="输入样例2-1">输入样例#2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">10 0<br>1 2 3 4 5 6 7 8 9 10<br></code></pre></td></tr></table></figure><h3 id="输出样例2-1">输出样例#2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">55<br></code></pre></td></tr></table></figure><h3 id="样例解释-2">样例解释</h3><p>样例 1：仅需通知岛民<code>[1, 2, 3]</code>，他们就会将消息传给所有人，且这样花费时间是最少的。样例 2 ：你们不得不自己通知所有岛民。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br>ll n,m;<br>ll pre[maxn],tim[maxn],ans;<br><br><span class="hljs-function">ll <span class="hljs-title">find</span><span class="hljs-params">(ll x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(pre[x] == x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(ll x, ll y)</span></span>&#123;<br>ll fx = <span class="hljs-built_in">find</span>(x);<br>ll fy = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(fx != fy)&#123;<br><span class="hljs-keyword">if</span>(tim[fx] &lt; tim[fy]) pre[fy] = fx;<br><span class="hljs-keyword">else</span> pre[fx] = fy;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>pre[i] = i;<br>cin&gt;&gt;tim[i];<br>&#125; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br>ll a,b; cin&gt;&gt;a&gt;&gt;b;<br><span class="hljs-built_in">join</span>(a,b);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(pre[i] == i)&#123;<br>ans += tim[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="博弈大王">博弈大王</h2><h3 id="题目描述-3">题目描述</h3><p>Wow！运气真不错，你和 Blice成功从千年一遇的大门进入了异世界，祝贺你们！但是异世界并非什么善良和平之地，在这里有更厉害的情景等待你们去挑战，挑战成功后也许会得到一些奇怪的东西。当心，你们可能会失败！穿过大门，在那有个脑袋是显示器的人形机器人。它自称是“博弈大王”，它要和你们进行博弈游戏。在机器人的脑袋上，显示出了<code>n</code>个顺序排列的格子，每个格子里都有一个数字。规则是这样的，首先会<strong>完全随机</strong>选择一个格子放置旗帜，然后由你们先手，博弈大王后手，双方轮流行动，规则如下：</p><ul><li>必须移动旗帜，如果无法移动旗帜就意味输掉比赛</li><li>若希望旗帜从第<code>j</code>个格子移动到第<code>i</code>个格子，则必须保证<code>i&lt;j</code>并且<code>第i个格子的数字 &lt; 第j个格子的数字</code></li></ul><p>注意：在这个游戏里，你和 Blice 看作一个玩家，共同对抗博弈大王；已知博弈大王和你都十分聪明不会失误，在你看到<code>n</code>个格子中的数字后，请给出你们的获胜概率乘以<code>n</code>。当然，为了防止聪明的参赛者挨个输入值获取分数，这样的游戏会玩<code>t</code>轮。</p><h3 id="输入格式-3">输入格式</h3><p>第一个 1 个整数：<code>t</code>，表示一共<code>t</code>轮游戏。每轮游戏包含两行输入： 第一行 输入1个整数：<code>n</code>，表示游戏里一共有<code>n</code>个格子。第二行输入<code>n</code>个整数，其中第<code>i</code>个数字表示第<code>i</code>个格子里的数字。数据范围：1≤∑<em>i</em>=1<em>t</em>​<em>n</em>≤106，1≤具体数字≤109</p><h3 id="输出格式-3">输出格式</h3><p>输出获胜概率乘以<code>n</code>，显然是一个整数。</p><h3 id="输入样例1-3">输入样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">2<br>3<br>2 1 3<br>2<br>2 1<br></code></pre></td></tr></table></figure><h3 id="输出样例1-3">输出样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">1<br>0<br></code></pre></td></tr></table></figure><h3 id="样例解释-3">样例解释</h3><p>样例 1 的第一轮游戏，如果旗帜初始被放置在下标 3的位置，你们可以将其移动至下标 1位置，这样博弈大王就无法移动，输掉了比赛。其他两种情况都无法获胜，所以胜率是31，乘以<code>n=3</code>得到1 。 样例 1 的第二轮游戏，没有一种情况可以胜利，自然胜率是 0 。</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;cin&gt;&gt;n;<br><span class="hljs-type">int</span> min_ = INT_MAX;<br><span class="hljs-type">int</span> ans = n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> x;cin&gt;&gt;x;<br><span class="hljs-keyword">if</span>(x &lt; min_)&#123;<br>min_ = x;<br>ans --;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="双向奔赴">双向奔赴</h2><h3 id="题目描述-4">题目描述</h3><p>很不幸，当前挑战地图是一个由<code>n</code>个点组成的<strong>无向连通图</strong>，你初始在1 点，Blice初始在<code>n</code>点。情况紧急，你们需要在一起才能更好地发挥实力。现实情况总是要复杂一些，你和 Blice都是正常的人类，自然会有体力上限。你至多可以移动<code>a</code>距离、Blice至多可以移动<code>b</code>距离。你们决定选择某个点作为见面点，若双方可达，使得两人走过的距离之和最小，并输出这个最小的距离和的值。如果图中没有双方均可达的点，请直接输出<code>(T_T)</code>。</p><blockquote><p>注：不可以在边上见面！</p></blockquote><h3 id="输入格式-4">输入格式</h3><p>第一行 4个整数：<code>n m a b</code>，分别表示：图有<code>n</code>个顶点、图有<code>m</code>条边（不会出现重边自环）、你能行走的最远距离、Blice能行走的最远距离。 接下来的<code>m</code>行，每行输入3个整数<code>u v w</code>，表示<code>u</code>点和<code>v</code>的距离值为<code>w</code>。数据范围：2≤<em>n</em>≤106、0≤<em>m</em>≤106、1≤<em>a</em>,<em>b</em>,<em>w</em>≤109</p><h3 id="输出格式-4">输出格式</h3><p>若存在双方均可达的见面点，输入最小距离和，否则输出(T-T)。</p><h3 id="输入样例1-4">输入样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">4 5 3 5<br>1 2 2<br>2 3 10<br>2 4 5<br>1 3 5<br>3 4 1<br></code></pre></td></tr></table></figure><h3 id="输出样例1-4">输出样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">7<br></code></pre></td></tr></table></figure><h3 id="输入样例1-5">输入样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">2 1 1 1<br>1 2 2<br></code></pre></td></tr></table></figure><h3 id="输出样例1-5">输出样例#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">(T_T)<br></code></pre></td></tr></table></figure><h3 id="样例解释-4">样例解释</h3><p><img src="/competition/GPLT/2024-school/9443f959-b228-42fe-a395-7ca37bda7905.png" alt="img_002.PNG"> 样例 1：其图结构如上，你只可能抵达<code>1</code>或<code>2</code>点，Blice只可能抵达<code>4</code>、<code>3</code>、<code>2</code>点，所以你们仅可以在<code>2</code>点相见。两人路程和为7。 样例 2 ：显然不可行（不可以在边上见面)。</p><h3 id="代码-4">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>; <br><span class="hljs-type">const</span> ll inf = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">2e6</span> + <span class="hljs-number">10</span>;<br><br>ll n,m,a,b;<br>ll idx;<br>ll head[maxn],d1[maxn],d2[maxn];<br><span class="hljs-type">bool</span> vis1[maxn],vis2[maxn];<br>priority_queue&lt;pair&lt;ll,ll&gt;,vector&lt;pair&lt;ll,ll&gt; &gt;, greater&lt;pair&lt;ll,ll&gt; &gt; &gt; pq1,pq2; <br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>ll to,nex,w;<br>&#125;e[maxm];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll from, ll to, ll w)</span></span>&#123;<br>e[idx].to = to;<br>e[idx].w = w;<br>e[idx].nex = head[from];<br>head[from] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>d1[i] = inf;<br>&#125; <br>d1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pq<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(&#123;d1[<span class="hljs-number">1</span>],<span class="hljs-number">1</span>&#125;);<br><span class="hljs-keyword">while</span>(!pq<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = pq<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>().second;<br>pq<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(vis1[f]) <span class="hljs-keyword">continue</span>;<br>vis1[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = head[f] ; j != <span class="hljs-number">-1</span> ; j = e[j].nex)&#123;<br><span class="hljs-type">int</span> to = e[j].to;<br><span class="hljs-keyword">if</span>(!vis1[to] &amp;&amp; d1[to] &gt; d1[f] + e[j].w)&#123;<br>d1[to] = d1[f] + e[j].w;<br>pq<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(&#123;d1[to], to&#125;);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 2</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>d2[i] = inf;<br>&#125; <br>d2[n] = <span class="hljs-number">0</span>;<br>pq<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(&#123;d2[n],n&#125;);<br><span class="hljs-keyword">while</span>(!pq<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = pq<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>().second;<br>pq<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(vis2[f]) <span class="hljs-keyword">continue</span>;<br>vis2[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = head[f] ; j != <span class="hljs-number">-1</span> ; j = e[j].nex)&#123;<br><span class="hljs-type">int</span> to = e[j].to;<br><span class="hljs-keyword">if</span>(!vis2[to] &amp;&amp; d2[to] &gt; d2[f] + e[j].w)&#123;<br>d2[to] = d2[f] + e[j].w; <br>pq<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(&#123;d2[to], to&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b;<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">add_edge</span>(x,y,w);<br><span class="hljs-built_in">add_edge</span>(y,x,w);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>();<br>ll ans = inf; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(d1[i] &lt;= a &amp;&amp; d2[i] &lt;= b)&#123;<br>ans = <span class="hljs-built_in">min</span>(ans, d1[i] + d2[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ans == inf)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;(T_T)&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;ans;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>校内模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPLT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛模拟：2025年分组赛</title>
    <link href="/competition/GPLT/2025-group-match/"/>
    <url>/competition/GPLT/2025-group-match/</url>
    
    <content type="html"><![CDATA[<h1 id="gplt团体程序设计天梯赛模拟2025年分组赛">GPLT团体程序设计天梯赛模拟：2025年分组赛</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>分值</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P4711">P4711「化学」相对分子质量 - 洛谷</a></td><td>25</td><td>字符串处理</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1922">P1922女仆咖啡厅桌游吧 - 洛谷</a></td><td>25</td><td>树形DP</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/B4219">B4219 数学作业 -洛谷</a></td><td>25</td><td>DFS剪枝</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P1194">P1194 买礼物 -洛谷</a></td><td>25</td><td>最小生成树</td></tr></tbody></table><h2 id="相对分子质量">相对分子质量</h2><p>字符串模拟</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s;<br><span class="hljs-type">double</span> sum;<br>unordered_map&lt;string, <span class="hljs-type">double</span>&gt; mp;<br><br><span class="hljs-comment">// 初始化哈希表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_mp</span><span class="hljs-params">()</span></span>&#123;<br>mp[<span class="hljs-string">&quot;H&quot;</span>] = <span class="hljs-number">1</span>;<br>mp[<span class="hljs-string">&quot;C&quot;</span>] = <span class="hljs-number">12</span>;<br>mp[<span class="hljs-string">&quot;N&quot;</span>] = <span class="hljs-number">14</span>;<br>mp[<span class="hljs-string">&quot;O&quot;</span>] = <span class="hljs-number">16</span>;<br>mp[<span class="hljs-string">&quot;F&quot;</span>] = <span class="hljs-number">19</span>;<br>mp[<span class="hljs-string">&quot;Na&quot;</span>] = <span class="hljs-number">23</span>;<br>mp[<span class="hljs-string">&quot;Mg&quot;</span>] = <span class="hljs-number">24</span>;<br>mp[<span class="hljs-string">&quot;Al&quot;</span>] = <span class="hljs-number">27</span>;<br>mp[<span class="hljs-string">&quot;Si&quot;</span>] = <span class="hljs-number">28</span>;<br>mp[<span class="hljs-string">&quot;P&quot;</span>] = <span class="hljs-number">31</span>;<br>mp[<span class="hljs-string">&quot;S&quot;</span>] = <span class="hljs-number">32</span>;<br>mp[<span class="hljs-string">&quot;Cl&quot;</span>] = <span class="hljs-number">35.5</span>;<br>mp[<span class="hljs-string">&quot;K&quot;</span>] = <span class="hljs-number">39</span>;<br>mp[<span class="hljs-string">&quot;Ca&quot;</span>] = <span class="hljs-number">40</span>;<br>mp[<span class="hljs-string">&quot;Mn&quot;</span>] = <span class="hljs-number">55</span>;<br>mp[<span class="hljs-string">&quot;Fe&quot;</span>] = <span class="hljs-number">56</span>;<br>mp[<span class="hljs-string">&quot;Cu&quot;</span>] = <span class="hljs-number">64</span>;<br>mp[<span class="hljs-string">&quot;Zn&quot;</span>] = <span class="hljs-number">65</span>;<br>mp[<span class="hljs-string">&quot;Ag&quot;</span>] = <span class="hljs-number">108</span>;<br>mp[<span class="hljs-string">&quot;I&quot;</span>] = <span class="hljs-number">127</span>;<br>mp[<span class="hljs-string">&quot;Ba&quot;</span>] = <span class="hljs-number">137</span>;<br>mp[<span class="hljs-string">&quot;Hf&quot;</span>] = <span class="hljs-number">178.5</span>;<br>mp[<span class="hljs-string">&quot;Pt&quot;</span>] = <span class="hljs-number">195</span>;<br>mp[<span class="hljs-string">&quot;Au&quot;</span>] = <span class="hljs-number">197</span>;<br>mp[<span class="hljs-string">&quot;Hg&quot;</span>] = <span class="hljs-number">201</span>;<br>&#125;<br><br><span class="hljs-comment">// 读取数字，直到i不是数字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_num</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; i)</span></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> ; i++)&#123;<br>res = (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + res*<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 读取下一个元素，及其后缀_&#123;n&#125;</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">read_elem</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; i)</span></span>&#123;<br>string t = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)&#123;<br>t += s[i]; i++;<br><span class="hljs-keyword">if</span>(i &lt; s.<span class="hljs-built_in">length</span>() &amp;&amp; s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)&#123;<br>t += s[i]; i++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;_&#x27;</span>)&#123;<br>i += <span class="hljs-number">2</span>;<br>num = <span class="hljs-built_in">read_num</span>(i);<br>i ++;<br>&#125;<br><span class="hljs-keyword">return</span> mp[t]*num;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br><span class="hljs-built_in">init_mp</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>(); )&#123;<br><span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)&#123;<br>sum += <span class="hljs-built_in">read_elem</span>(i);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br><span class="hljs-type">double</span> k = <span class="hljs-number">0</span>; i++;<br><span class="hljs-keyword">while</span>(s[i] != <span class="hljs-string">&#x27;)&#x27;</span>) k += <span class="hljs-built_in">read_elem</span>(i);<br>i += <span class="hljs-number">3</span>;<br>sum += k*<span class="hljs-built_in">read_num</span>(i);<br>i++;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;~&#x27;</span>)&#123;<br>i++;<br><span class="hljs-type">int</span> num = (s[i] == <span class="hljs-string">&#x27;H&#x27;</span> ? <span class="hljs-number">1</span>: <span class="hljs-built_in">read_num</span>(i));<br>sum += num*(mp[<span class="hljs-string">&quot;H&quot;</span>]*<span class="hljs-number">2</span> + mp[<span class="hljs-string">&quot;O&quot;</span>]);<br>i += <span class="hljs-number">6</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>i++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(sum == <span class="hljs-built_in">int</span>(sum)) cout&lt;&lt;<span class="hljs-built_in">int</span>(sum);<br><span class="hljs-keyword">else</span> cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">1</span>)&lt;&lt;sum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="女仆咖啡厅桌游吧">女仆咖啡厅桌游吧</h2><p>给一棵树，要对树的节点进行涂色，允许涂两种颜色，要求每个子树的两种颜色数相同，求单一颜色的最大个数。</p><p>我们设 红色为1，蓝色为-1，即每个子树的总和为0；</p><p>假设节点x的每个子节点已经合法涂色，因为每个子节点代表的子树总和都为0，现在可以考虑的只有叶子节点和父节点。</p><p>那么x代表的子树对总和的贡献为 （叶子节点个数 + 1）/ 2。</p><p>由此可以得到递推关系： <span class="math display">\[dp[i] = \sum_{j}^{son[i]}dp[j] + cnt/2\]</span> 这里的son[i]表示非叶子节点，cnt 表示 叶子节点 + 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,dp[maxn],d[maxn];<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it != f)&#123;<br><span class="hljs-built_in">dfs</span>(it, x);<br>dp[x] += dp[it];<br><span class="hljs-keyword">if</span>(d[it] == <span class="hljs-number">1</span>) cnt++;<br>&#125;<br>&#125;<br>dp[x] += cnt/<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> u, v; cin&gt;&gt;u&gt;&gt;v;<br>e[u].<span class="hljs-built_in">push_back</span>(v);<br>e[v].<span class="hljs-built_in">push_back</span>(u);<br>d[v]++;d[u]++;<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>cout&lt;&lt;dp[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数学作业">数学作业</h2><p>给定一个数字n，求 &lt; n 的斐波那契数中，能构成n的组合有几种。</p><p>题目给定n的最大值为10^12，斐波那契数最多有58个，而朴素遍历的时间复杂度为O(2^n)。一定会超时。</p><p>我们考虑使用前缀和进行优化：</p><p>若当前和 + 此后所有数的和 &lt; n，退出循环；</p><p>若当前和 &gt; n，退出循环；</p><p>注意，对于合法的斐波那契数，我们要从大到小进行遍历，可以极大优化剪枝过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>ll n,l,ans;<br>ll dp[<span class="hljs-number">100</span>],pre[<span class="hljs-number">100</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll d, ll sum)</span></span>&#123;<br><span class="hljs-keyword">if</span>(sum + pre[d] &lt; n) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(sum &gt; n) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(d == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(sum == n) ans++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">dfs</span>(d<span class="hljs-number">-1</span>, sum + dp[d]);<br><span class="hljs-built_in">dfs</span>(d<span class="hljs-number">-1</span>, sum);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br>dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>pre[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; dp[i<span class="hljs-number">-1</span>] &lt;= n ; i ++)&#123;<br>dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>pre[i] += pre[i<span class="hljs-number">-1</span>] + dp[i];<br>l = i;<br>&#125;<br><span class="hljs-built_in">dfs</span>(l<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="买礼物">买礼物</h2><p>Kruskal最小生成树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> w;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> edge &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> w &lt; rhs.w;<br>&#125;<br>&#125;;<br>vector&lt;edge&gt; v;<br><br><span class="hljs-type">int</span> p, n;<br><span class="hljs-type">int</span> fa[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;p&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) fa[i] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>edge e;  e.x = i; e.y = j; <br>cin&gt;&gt;e.w;<br><span class="hljs-keyword">if</span>(e.w == <span class="hljs-number">0</span> || e.w &gt; p) e.w = p;<br>v.<span class="hljs-built_in">push_back</span>(e);<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() &amp;&amp; cnt &lt; n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(v[i].x);<br><span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(v[i].y);<br><span class="hljs-keyword">if</span>(fx == fy) <span class="hljs-keyword">continue</span>;<br>fa[fx] = fy;<br>sum += v[i].w;<br>cnt++;<br>&#125;<br>cout&lt;&lt;sum+p;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>校内模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPLT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成与体系结构</title>
    <link href="/cs-cource/computer-organization/"/>
    <url>/cs-cource/computer-organization/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><h2 id="冯诺依曼和哈佛体系结构"><a href="#冯诺依曼和哈佛体系结构" class="headerlink" title="冯诺依曼和哈佛体系结构"></a>冯诺依曼和哈佛体系结构</h2><h3 id="冯诺依曼体系结构包括哪些组件？"><a href="#冯诺依曼体系结构包括哪些组件？" class="headerlink" title="冯诺依曼体系结构包括哪些组件？*"></a>冯诺依曼体系结构包括哪些组件？*</h3><p>运算器、控制器、存储器、输入设备和输出设备</p><h3 id="各自的特点？"><a href="#各自的特点？" class="headerlink" title="各自的特点？*"></a>各自的特点？*</h3><p>冯·诺伊曼体系结构的特点</p><p>​A.使用二进制数存储程序</p><p>​B.存储程序按地址顺序依次执行</p><p>​C.把程序及其操作数据一同存储 </p><p>哈佛体系结构的特点</p><p>​把程序与其操作数据分开存储</p><h3 id="不同点？前者继承了后者那些特点？"><a href="#不同点？前者继承了后者那些特点？" class="headerlink" title="不同点？前者继承了后者那些特点？*"></a>不同点？前者继承了后者那些特点？*</h3><p>不同点：二者都将数据和指令存储在计算机的存储器中，但前者共同存储，后者分开存储。</p><p>哈佛体系结构将指令和数据完全在物理上分离；</p><p>冯诺依曼体系结构的高速缓存Cache中，指令存储在Flash（只读），数据在RAM中，物理分离；</p><p>冯诺依曼体系结构中，地址总线和数据总线也是物理上分离。</p><h3 id="冯诺依曼体系结构怎么区分指令和数据？"><a href="#冯诺依曼体系结构怎么区分指令和数据？" class="headerlink" title="冯诺依曼体系结构怎么区分指令和数据？*"></a>冯诺依曼体系结构怎么区分指令和数据？*</h3><p>时间上，取指周期取出的是指令，执行周期取出的是数据；</p><p>空间上，从存储器流向控制器的是指令，从存储器流向运算器的是数据。</p><blockquote><p>（必考，10分）</p></blockquote><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>反码的唯一意义是作为计算补码的中间过程，本身不参与任何运算。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码*"></a>补码*</h3><p>计算机采用补码表示进行存储和运算，因为补码符号位可以直接参与运算，无论数是正，还是负，计算机总是做加法运算。</p><p>补码可以确定$2^n$个二进制数，原码只能确定$2^n - 1$(-0和+0是同一个数) *。</p><blockquote><p>为什么补码的符号位可以参与运算？*</p><p>补码 天然满足 加法循环群 的概念，包含三大性质 （单位元、结合律 和 逆元）</p><p>本质上，补码的第一位并不是符号位，而是数值位。</p><p>只是构造完成后，最高位能显示正负（01），和原码中符号位的定义一致。</p></blockquote><p>正数原码的补码就是本身；负数原码的补码 是 原码的反码 + 1；</p><blockquote><p>怎么理解 负数原码的补码 是 原码的反码 + 1？</p><p>我们以-7为例子，设 X 为 -7</p><p>X + 0111( &#x3D; 7) &#x3D; 0000，</p><p>-&gt; X &#x3D; 0000 - 0111</p><p>-&gt; X &#x3D; 1 + (1111 - 0111)</p><p>1111 + 0111 就是 0111取反 + 1</p></blockquote><h3 id="移码"><a href="#移码" class="headerlink" title="移码*"></a>移码*</h3><p>移码的定义：移码是一种用于表示有符号数的编码方式。</p><blockquote><p>移码的存在目的是为了进行数的比较操作，以及简化计算机中有符号数的表示*</p><p>移码通过在原码的基础上加上一个偏移量K，来表示有符号整数。</p><p>在IEEE754标准中，移码被用于浮点数的指数表示。</p></blockquote><p>移码的基本原理：将每个数值加上一个固定的偏移量，使其范围从负数变为非负数。</p><p>移码的计算：移码等于补码的符号（第一位数字）位取反。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数*"></a>浮点数*</h3><p>计算机中常用的数据表示格式有两种，定点和浮点：</p><p>​定点数中，一个数中小数点的位置是固定的；定点格式可表示的数值的范围有限，但要求的处理硬件简单。</p><p>​浮点数中，一个数中小数点的位置是浮动的； 浮点格式可表示的数值的范围很大，但要求的处理硬件复杂。</p><p>浮点数的表示：<br>$$<br>{S(1):E(m):M(n)} &#x3D;&#x3D; \pm1.M*2^{E}<br>$$<br>​浮点数采用二进制科学计数法表示。 </p><p>​S为尾数的符号位，用01表示正负，占1位；</p><p>​E为阶码，用移码表示，紧跟在符号位之后，占m位；</p><p>​M为尾数，用原码表示，放在低位部分，占n位；</p><blockquote><p>IEEE754标准中，为什么指数的偏移量不选128？*</p><p>当阶码E为全0且尾数M也为全0时，表示的真值X为零， 结合符号位S为0或1，有正零和负零之分</p><p>当阶码E为全1且尾数M也为全0时，表示的真值X为无穷大（∞），结合符号位S为0或1，有+∞和-∞之分</p><p>这样，在32位浮点数表示中，要除去E用全0和全1（ 255）表示零和无穷大的特殊情况，因此，阶码E的取值范围变为1～254，指数的偏移量不选128（ 10000000B），而选127（01111111B） </p><p>对于32位规格化浮点数，真正的指数值e为-126～+127</p></blockquote><p>浮点数的规格化：</p><p>​为了提高数据的表示精度，需要充分利用尾数的有效位数；当尾数的值不为0时，尾数域的最高有效位应为1， 否则就要用修改阶码同时左右移动小数点的办法，使其变成符合这一要求的表示形式。</p><h3 id="定点加、减法运算"><a href="#定点加、减法运算" class="headerlink" title="定点加、减法运算"></a>定点加、减法运算</h3><p><strong>补码加&#x2F;减</strong></p><p>加法：<br>$$<br>[x]补+[y]补&#x3D;[x+y]补 （mod 2）\<br>$$<br>当两数以补码形式相加时，运算的结果将直接得到两数之和的补码。</p><p>符号位可以作为数据的一部分参加运算而不用单独处理，有进位也只要丢弃即可。</p><p>减法：<br>$$<br>[x-y]补&#x3D;[x+(-y)]补&#x3D;[x]补+[-y]补 （mod 2）<br>$$<br> 补码定点减法和补码定点加法在本质上是相同的，减法运算可以转换成加法运算。</p><p>只需要将[y]补连同符号位取反且最低位加1，即可得到[-y]补。</p><p><strong>溢出判断</strong></p><p>双符号位法：</p><p>​如果两个数相加后，其结果的两个符号位一致（00 或11），则没有发生溢出；</p><p>​如果两个符号位不一致（10或01），则发生溢出；</p><p>​两个正数的首位都为00，若不溢出，仍然为00，否则为01（正溢）；</p><p>​两个负数的首位都为11，若不溢出，仍然为11，否则为10（负溢）；</p><p>​但是不论溢出与否，运算结果的最高符号位始终指示正确的符号。</p><h3 id="浮点运算器"><a href="#浮点运算器" class="headerlink" title="浮点运算器"></a>浮点运算器</h3><p>浮点加减法运算规则：</p><p>$$<br>x\pm y&#x3D;2^{E_x}\times M_x\pm2^{E_y}\times M_y&#x3D;\begin{cases}(M_x\times2^{E_x-E_y}\pm M_y)\times2^{E_y}&amp;\mathrm{(Ex&lt;&#x3D;Ey)}\(M_x\pm M_y\times2^{E_y-E_x})\times2^{E_x}&amp;\mathrm{(Ex&gt;Ey)}&amp;\end{cases}<br>$$</p><blockquote><p>为什么对阶必须遵循“小阶向大阶靠拢”的原则：*</p><p>尾数的左右移都会造成有效数据的移出与丢失，但是右移丢失的是最低有效位，而左移丢失的却是最高有效位。</p><p>显然，若小阶向大阶靠拢，数据误差更小。</p></blockquote><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h3 id="随机读写存储器"><a href="#随机读写存储器" class="headerlink" title="随机读写存储器*"></a>随机读写存储器*</h3><p>按保存数据的机理分为：</p><p>​1）静态存储器（SRAM）：双稳态触发器存储。集成度低，成本高，功耗较大；通常作为Cache的存储体。</p><p>​2）动态存储器（DRAM）：电容存储。电路简单，集成度高，成本低，功耗小；要不间断地进行刷新；作为主存的主体部分。</p><p>​3）增强型动态存储器（EDRAM）： 在DRAM芯片上集成一个高速小容量的SRAM芯片，起到高速缓存的作用， 性能得到显著改进。</p><blockquote><p>刷新操作通常是在哪个芯片上完成？ 为什么？*</p><p>DRAM；DRAM 使用电容存储数据，电容上的信息电荷会随时间逐渐泄漏，因此需要定期刷新（即重新写入数据）以维持数据完整性。</p></blockquote><h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><p>只读存储器ROM是一种存储固定信息的存储器。</p><p>其特点是在正常工作状态下只能读取数据，不能即时修改或重新写入数据。</p><p>ROM的最大优点是具有不易失性</p><p>只读存储器有两大类：</p><p>​1）不可重写只读存储器（MROM、PROM）；</p><p>​2）可重写只读存储器（EPROM、EEPROM、闪速存储器flash ROM等）；</p><h3 id="主存的拓展"><a href="#主存的拓展" class="headerlink" title="主存的拓展"></a>主存的拓展</h3><blockquote><p>主存为什么可以拓展？*</p><p>存储器芯片的容量是有限的，为了满足实际存储器的容量要求，</p><p>我们可以将存储芯片连在一起组成足够的容量，包括位拓展、字拓展和字位拓展。</p></blockquote><blockquote><p>什么情况下用位拓展法？字拓展法呢？*</p><p>1）位拓展法*（增加存储字长【访问数据位宽】）</p><p>地址范围不变，但每次访问的数据位数增加。</p><p>数据总线需要扩展，地址总线无需改变。</p><p>将多片存储芯片的相同地址线并联，数据线合并输出。</p><p>2）字拓展法（增加存储字【地址】的数量）</p><p>数据位宽不变，但地址空间翻倍。</p><p>地址总线需要扩展，数据总线无需改变。</p><p>通过译码器生成片选信号，区分芯片的具体地址。</p></blockquote><blockquote><p>不考虑成本，主存可以无限拓展吗？*</p><p>数据总线的数量决定了同单位时间能寻址的地址数量。</p><p>地址总线的数量决定了存储的地址空间数量。</p></blockquote><h3 id="高速缓冲存储器-Cache"><a href="#高速缓冲存储器-Cache" class="headerlink" title="高速缓冲存储器(Cache)"></a>高速缓冲存储器(Cache)</h3><blockquote><p>什么是Cache的命中率？*</p><p>Cache的命中率，用于描述CPU在Cache完成存取的占比。</p><p>cache(高速缓冲存储器)的数据是主存的一个子集，CPU访问存储器时会先访问cache，如果cache没有找到需要的数据，就会去主存找。</p></blockquote><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><blockquote><p>掌握直接寻址和间接寻址的区别？</p><p>直接寻址指令直接包含有操作数的有效地址。</p><p>间接寻址指令的操作数则通过存储器间接给出，指令地址存放的是操作数的地址，而不是操作数本身。</p></blockquote><blockquote><p>取指周期 取出的指令，流向了哪里？*</p><p>当执行一条指令时，首先把该指令从主存读取到<strong>数据寄存器</strong>中，判断是指令还是数据。</p><p>若是指令，将其传送至<strong>指令寄存器</strong>，使用<strong>指令译码器</strong>进行译码。</p><p>最后，向<strong>操作控制器</strong>发出具体操作的特定信号。</p></blockquote><h2 id="中央处理器（CPU）"><a href="#中央处理器（CPU）" class="headerlink" title="中央处理器（CPU）"></a>中央处理器（CPU）</h2><blockquote><p>控制器的实现方式？有什么区别？* </p><p>实现方式有两种，组合逻辑控制 和 微程序控制。</p><p>组合逻辑是用门电路直接生成控制信号。可能每个指令对应一系列的逻辑门组合，根据当前指令的操作码和其他状态（如条件码）来产生控制信号。</p><p>微指令控制器将一条指令拆分为微指令，而微指令事先存放在控制存储器中，解码后生成控制信号。</p><p>区别：</p><p>组合逻辑是纯硬件实现，而微程序介于软硬件之间。</p><p>组合逻辑设计复杂，电路一旦制造完成就难以调整，甚至无法修改。</p><p>微程序则更容易修改和扩展，但可能因为需要访问控制存储器而增加延迟。</p></blockquote><p>流水线技术需要掌握。</p><blockquote><p>指令流水线的五大步骤分别是？*</p><p>通常将指令的执行过程划分为取指令 、译码、执行、取数、写回 5个并行处理过程，并按流水方式组织起来。</p></blockquote><blockquote><p>流水线技术是时间并行还是空间并行？*</p><p>时间并行指的是时间重叠，空间并行指的是资源重复。</p><p>流水线技术是时间并行，将一个任务分解为不同阶段，在各个功能部件上并行执行。</p><p>超标量和超流水都是时间并行。</p></blockquote><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><blockquote><p>DMA和通道方式的区别？</p><p>1.相比DMA, 通道方式下CPU的干预更少，DMA则需要CPU来控制传输块的大小和位置。</p><p>2.通道是可编程的，可以灵活调整通道程序，而DMA无法。</p><p>3.通常来说，相比DMA，一个通道可以控制多台设备。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/cs-cource/data-structure/"/>
    <url>/cs-cource/data-structure/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构">数据结构</h1><h2 id="绪论">1 绪论</h2><h3 id="时间复杂度o">时间复杂度O</h3><p>f(x) = O(g(x)) 表示的含义是f(x)以g(x)为上界。</p><p>设问题规模为n，存在正常数c、n、n0，当 n&gt;n0 的时，任意的 f(n) 符合0 &lt;= f(n) &lt;= c.g(n)</p><figure><img src="/cs-cource/data-structure/2becf2eb18f2916f3eac7d8a1aa553a3.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="逻辑结构分类">逻辑结构分类</h3><figure><img src="/cs-cource/data-structure/image-20250705203649746.png" alt="image-20250705203649746"><figcaption aria-hidden="true">image-20250705203649746</figcaption></figure><h3 id="存储结构分类">存储结构分类</h3><p>顺序存储：随机存取，存储密度大，但删除、插入操作较耗时。</p><p>链式存储：删除、插入操作快，但无法随机存取，存储密度小。</p><p>索引存储：需要额外的索引表。</p><p>哈希存储（散列存储）：根据元素关键词得到存储下标。</p><h2 id="顺序表">2 顺序表</h2><figure><img src="/cs-cource/data-structure/image-20250705204501052.png" alt="image-20250705204501052"><figcaption aria-hidden="true">image-20250705204501052</figcaption></figure><h3 id="静态链表的优点">静态链表的优点</h3><p>顺序表和单链表的差别 就是 顺序存储和链式存储的差别。</p><p>静态链表融合了二者的优点，既能随机访问元素，又能快速插入、删除元素。</p><h3 id="头指针和头节点的区别">头指针和头节点的区别</h3><p>头指针：指向第一个节点存储位置的指针，具有标识作用；无论链表是否为空，头指针都是链表的必要元素。</p><p>头结点：放在第一个元素节点之前，便于在第一个元素节点之前进行插入和删除的操作；头结点不是链表的必须元素，不存储任何信息。</p><h3 id="判断链表有没有环">判断链表有没有环</h3><p>从头开始设置两个指针，快指针每次走2步，慢指针每次走1步，如果快指针先碰到尾，则无环，否则两个指针之后一定会重合，则有环。</p><h2 id="栈队列和数组">3 栈、队列和数组</h2><figure><img src="/cs-cource/data-structure/image-20250705212958914.png" alt="image-20250705212958914"><figcaption aria-hidden="true">image-20250705212958914</figcaption></figure><h3 id="什么是共享栈">什么是共享栈？</h3><figure><img src="/cs-cource/data-structure/image-20250705213034368.png" alt="image-20250705213034368"><figcaption aria-hidden="true">image-20250705213034368</figcaption></figure><p>利用栈底位置相对不变的特性，让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。这样能够更有效的利用存储空间，防止上溢。</p><h2 id="串">4 串</h2><h3 id="kmp">KMP</h3><p>基于 next数组（最长公共前后缀），让子串和主串的每个字符进行匹配，当出现匹配失败时，如果已匹配相等的序列中有某个后缀正好是子串的前缀，那么可以直接将子串滑动到与这些相等字符对齐的位置，使得主串指针无须回溯。</p><p>BF暴力匹配算法的时间复杂度为 O(mn)，而 KMP 的时间复杂度仅为O(m+n)</p><h2 id="树">5 树</h2><h3 id="基本概念">基本概念</h3><p>满二叉树：除叶子结点外，每个结点的度都为 2 的二叉树</p><p>完全二叉树：除了最后一层外，其他层的每个结点的度都为 2，且最后一层也只是在最右侧缺少节点</p><p>线索二叉树：将二叉树中所有为空的左、右指针指向某种遍历次序下该节点的直接前驱、直接后继结点，则得到的就是线索二叉树。</p><ul><li>优点：用空指针域来存储结点之间前趋和后继关系，既不增加空间，还能加快查找结点的前驱和后继</li></ul><p>双亲表示法、孩子表示法、孩子兄弟表示法；</p><h3 id="哈夫曼树">哈夫曼树</h3><p>哈夫曼树又叫最优二叉树，在含有 n个带权叶子结点的二叉树中，所有叶子结点的带权路径长度之和最小的二叉树是哈夫曼树。</p><p>构建过程：</p><p>1.在 n个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</p><p>2.在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2个权值的行列中；</p><p>3.重复 1 和 2，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</p><p>哈夫曼编码：</p><p>从根往下走，往左为0，往右为1，由此可以得到一组无公共前缀的01编码，频率越高的字符，编码长度越短。</p><h2 id="图">6 图</h2><h3 id="存储方法">存储方法</h3><p>邻接矩阵法：空间复杂度高，便于判断两点是否相连，不利于查找出度。</p><p>邻接表法：空间复杂度低，利于查找出边，不利于判断两点是否相连。</p><p>十字链表法：利于查找出边/入边，不利于判断两点是否相连。</p><h3 id="最小生成树">最小生成树</h3><p>Prim算法：</p><p>​ 任选一点作为初始点，加入集合；</p><p>​ 找到与当前集合距离最近的顶点，将该点和对应的边加入集合；</p><p>​ 重复上述过程，直至将所有顶点都加入集合；</p><p>Kruskal算法：</p><p>​ 对连通图的所有边按权值排序；</p><p>​ 取权值最小的边，按权重从小到大选边；</p><p>​ 若加入该边后不构成回路，则取之，否则弃之；</p><p>​ 重复上述过程，直至边数=顶点数-1为止。</p><h3 id="最短路径问题">最短路径问题</h3><p>Dijkstra：</p><p>​ 求解单源最短路径的贪心算法，要求边权不为负;</p><p>​ O（N^2）堆优化后，复杂度O（N*logN）</p><p>Floyd 算法：</p><p>​ 求解多源图最短路径的动态规划算法</p><p>​ 时间复杂度为 O(N^3)，空间复杂度为 O(N^2)</p><h3 id="拓扑排序">拓扑排序</h3><p>扑排序的使用对象是有向无环图（DAG）。</p><p>算法描述：从图中选择入度为 0的顶点输出，并删除该点和所有以它为起点的边，重复该过程，直到图为空。</p><h2 id="查找">7 查找</h2><h3 id="基本概念-1">基本概念</h3><p>二分查找：递归地在相应的半部分查找，O(logn)</p><p>分块查找：查找时先用索引表找到位于哪个块，再在块内进行顺序查找。子表间有序，而子表内无序。</p><p>二叉搜索树（二叉排序树）：左子树上所有节点的值都小于根节点的值，右子树上所有节点的值都大于根节点的值，它的左右子树也分别为二叉搜索树。</p><p>平衡二叉树：是一种特别的二叉排序树，它的左右子树的高度差的绝对值不超过1</p><p>红黑树：红黑树是一种自平衡的二叉搜索树，保证时间复杂度为 O(logn)</p><p>B 树：B 树是所有结点的平衡因子均等于 0 的多路平衡查找树</p><p>B+ 树：对 B 树的改进，MySQL 种用的就是 B+树。叶子结点直接有指针，构成了一个链表，这个链表是有序的，即可以直接通过遍历链表进行区间查找</p><p>哈希表（散列表）：通过哈希函数将查找表中的关键字映射成一个地址来加快查找速度</p><h3 id="红黑树的原理-todo">红黑树的原理 TODO</h3><p>平衡二叉树为了保持平衡，需要通过频繁的旋转操作来调整树的结构，比较费时，而红黑树进一步放宽平衡条件，实际效率更高。</p><h3 id="哈希表的构造">哈希表的构造</h3><p>直接定址法：取关键字的某个线性函数值作为地址，适用于关键字分布均匀的情况</p><p>除留余数法：取关键字对某个数取余的值作为地址</p><p>数字分析法：当关键字位数很大时，取分布均匀的任意几位作为地址</p><p>平方取中法：取关键字的平方的中间几位作为地址</p><h3 id="怎么解决哈希冲突">怎么解决哈希冲突？</h3><p>哈希冲突指的是两个不同的数经过哈希函数计算后得到了同一个地址。</p><p>开放定址法：遇到哈希冲突时，去寻找一个新的空闲的哈希地址</p><p>链接法：将所有哈希地址相同的记录都链接在同一链表中</p><p>再哈希法：构造多个哈希函数，如果发生哈希冲突时就使用另外的哈希函数计算</p><p>溢出表法：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中</p><h2 id="排序">8 排序</h2><h3 id="基本概念-2">基本概念</h3><p>冒泡排序：通过遍历所有的相邻的两个数，如果他们逆序了，就交换位置，依次确定数组中的每个位置；</p><p>选择排序：通过遍历所有数，找到第 k 小的数，即数组中位置 k的元素；</p><p>插入排序：就像打扑克时边抓牌边理牌一样，先把第1个数当成已排序序列，第2个数就插到合理位置；再把第1,2个数当成已排序序列，第3个数就插到合理位置；依次类推即可</p><h3 id="快速排序">快速排序</h3><h3 id="归并排序">归并排序</h3><h3 id="堆排序">堆排序</h3><p>把所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，</p><p>如果父结点的值比子结点大，则是大根堆；如果父结点的值比子结点小，则是小根堆。</p><h3 id="为什么快排比归并好">为什么快排比归并好</h3><h3 id="排序稳定性">排序稳定性</h3><p>排序算法的稳定性：数组中值相等的元素，在排序后其相对次序若能保持不变，则算法是稳定的</p><p>稳定的算法：冒泡、插入、归并</p><p>不稳定的算法：选择、快排</p><h3 id="外排序">外排序</h3><p>之前的排序都是内排序，即在内存中完成的；</p><p>而对于大数据集，内存是一次性存不下的，需要在内存和磁盘上进行多次数据交换。</p>]]></content>
    
    
    <categories>
      
      <category>专业课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯软件赛C++A组省赛真题训练：2021年</title>
    <link href="/competition/lanqiao/2021/"/>
    <url>/competition/lanqiao/2021/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯软件赛ca组省赛真题训练2021年">蓝桥杯软件赛C++A组省赛真题训练：2021年</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P8740">P8740 [蓝桥杯 2021省 A] 填空问题 - 洛谷</a>（卡片）</td><td>模拟</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8740">P8740 [蓝桥杯 2021省 A] 填空问题 - 洛谷</a>（直线）</td><td>计算几何</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8740">P8740 [蓝桥杯 2021省 A] 填空问题 - 洛谷</a>（货物摆放）</td><td>数学</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8740">P8740 [蓝桥杯 2021省 A] 填空问题 - 洛谷</a>（路径）</td><td>Floyd最短路</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8740">P8740 [蓝桥杯 2021省 A] 填空问题 - 洛谷</a>（回路计数）</td><td>状压DP</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8742">P8742 [蓝桥杯 2021省 AB] 砝码称重 - 洛谷</a></td><td>背包问题</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8743">P8743 [蓝桥杯 2021省 A] 异或数列 - 洛谷</a></td><td>博弈论，位运算</td></tr></tbody></table><h2 id="卡片">卡片</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// ans = 3181</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">9</span> ; i ++)&#123;<br>a[i] = <span class="hljs-number">2021</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; ; i ++)&#123;<br><span class="hljs-type">int</span> x = i;<br><span class="hljs-keyword">while</span>(x)&#123;<br><span class="hljs-keyword">if</span>(a[x%<span class="hljs-number">10</span>] == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>a[x%<span class="hljs-number">10</span>]--;<br>x /= <span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="直线">直线</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-comment">// y1 = k*x1 + b;</span><br><span class="hljs-comment">// y2 = k*x2 + b;</span><br><span class="hljs-comment">// k = (y1 - y2)/(x1 - x2);</span><br><span class="hljs-comment">// b = y1 - k*x1;</span><br><br>vector&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">double</span>&gt; &gt; v;<br><span class="hljs-comment">// 40257</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(ll x1, ll y1, ll x2, ll y2)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x1 == x2 || y1 == y2) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// x = t 和 y = t的情况单独计算</span><br><span class="hljs-type">double</span> k = <span class="hljs-number">1.0</span>*(y1 - y2)/(x1 - x2);<br><span class="hljs-type">double</span> b = <span class="hljs-number">1.0</span>*y1 - k*x1;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123; <span class="hljs-comment">// 去重</span><br><span class="hljs-type">double</span> ki = it.first;<br><span class="hljs-type">double</span> bi = it.second;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(ki - k) &lt;= <span class="hljs-number">1e-8</span> &amp;&amp; <span class="hljs-built_in">fabs</span>(bi - b) &lt;= <span class="hljs-number">1e-8</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>v.<span class="hljs-built_in">push_back</span>(&#123;k, b&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>(ll x1 = <span class="hljs-number">0</span> ; x1 &lt; <span class="hljs-number">20</span> ; x1 ++)&#123;<br><span class="hljs-keyword">for</span>(ll y1 = <span class="hljs-number">0</span> ; y1 &lt; <span class="hljs-number">21</span> ; y1 ++)&#123;<br><span class="hljs-keyword">for</span>(ll x2 = <span class="hljs-number">0</span> ; x2 &lt; <span class="hljs-number">20</span> ; x2 ++)&#123;<br><span class="hljs-keyword">for</span>(ll y2 = <span class="hljs-number">0</span> ; y2 &lt; <span class="hljs-number">21</span> ; y2 ++)&#123;<br><span class="hljs-built_in">solve</span>(x1, y1, x2, y2);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;v.<span class="hljs-built_in">size</span>() + <span class="hljs-number">20</span> + <span class="hljs-number">21</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="货物摆放">货物摆放</h2><p><span class="math inline">\(O（\sqrt{n}*n^{1/4}）\)</span>的时间复杂度是可以接受的，暴力遍历所有组合即可。注意用排序和Set去重。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-comment">// n = 1 -&gt; 1x1x1 -&gt; 1种</span><br><span class="hljs-comment">// n = 2 -&gt; 2x1x1, 1x2x1, 1x1x2 -&gt; 3种</span><br><span class="hljs-comment">// n = 3 -&gt; 3x1x1, 1x3x1, 1x1x3 -&gt; 4种</span><br><span class="hljs-comment">// n = 4 -&gt; 4*1*1, 1*4*1, 1*1*4; 2*2*1, 2*1*2, 1*2*2 -&gt; 6种</span><br><span class="hljs-comment">// n = 5 -&gt; 5*1*1, 1*5*1, 1*1*5; -&gt; 3种</span><br><span class="hljs-comment">// n = 6 -&gt; 5*1*1, 1*5*1, 1*1*5; 2*3*1, 2*1*3, 1*2*3(+3) -&gt; 9种</span><br><br>ll ans; <span class="hljs-comment">// 2430</span><br>set&lt;pair&lt; pair&lt;ll, ll&gt;, ll &gt; &gt; st;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x, ll y, ll z)</span></span>&#123;<br>ll a[<span class="hljs-number">3</span>]; a[<span class="hljs-number">0</span>] = x; a[<span class="hljs-number">1</span>] = y; a[<span class="hljs-number">2</span>] = z;<br><span class="hljs-built_in">sort</span>(a, a<span class="hljs-number">+3</span>); <span class="hljs-comment">// 对输入的x, y, z排序, 去重</span><br>st.<span class="hljs-built_in">insert</span>(&#123;&#123;a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>]&#125;, a[<span class="hljs-number">2</span>]&#125;);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ll n = <span class="hljs-number">2021041820210418</span>;<br><span class="hljs-keyword">for</span>(ll x = <span class="hljs-number">1</span> ; x*x &lt;= n; x ++)&#123;<br><span class="hljs-keyword">if</span>(n % x == <span class="hljs-number">0</span>)&#123;<br>ll y = n/x;<br><span class="hljs-keyword">for</span>(ll z = <span class="hljs-number">1</span> ; z*z &lt;= x ; z ++)&#123;<br><span class="hljs-keyword">if</span>(x % z == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">add</span>(z, x/z, y);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll z = <span class="hljs-number">1</span> ; z*z &lt;= y ; z ++)&#123;<br><span class="hljs-keyword">if</span>(y % z == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">add</span>(z, y/z, x);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : st)&#123;<br>ll x = it.first.first;<br>ll y = it.first.second;<br>ll z = it.second;<br><span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;&quot; * &quot;&lt;&lt;y&lt;&lt;&quot; * &quot;&lt;&lt;z&lt;&lt;&quot; == &quot;&lt;&lt;n&lt;&lt;&quot;\n&quot;;</span><br><span class="hljs-keyword">if</span>(x == y &amp;&amp; y == z)&#123;<br>ans += <span class="hljs-number">1</span>; <span class="hljs-comment">// 1</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x == y || y == z || x == z)&#123;<br>ans += <span class="hljs-number">3</span>; <span class="hljs-comment">// Cn^1</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>ans += <span class="hljs-number">6</span>; <span class="hljs-comment">// A3^3</span><br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路径">路径</h2><p>弗洛伊德算法求无向图最短路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll inf = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<br><br><span class="hljs-comment">// 对于两个不同的结点 a, b，如果 a 和 b 的差的绝对值大于 21</span><br><span class="hljs-comment">// 则两个结点 之间没有边相连；</span><br><span class="hljs-comment">// 如果 a 和 b 的差的绝对值小于等于 21</span><br><span class="hljs-comment">// 则两个点之间有一条 长度为 a 和 b 的最小公倍数的无向边相连。</span><br><br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll x, ll y)</span></span>&#123;<br><span class="hljs-keyword">return</span> y == <span class="hljs-number">0</span> ? x : <span class="hljs-built_in">gcd</span>(y, x%y);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">lcm</span><span class="hljs-params">(ll x, ll y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x*y/<span class="hljs-built_in">gcd</span>(x,y);<br>&#125;<br><br>ll e[<span class="hljs-number">3000</span>][<span class="hljs-number">3000</span>];<br><span class="hljs-comment">// ans = 10266837</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ll n = <span class="hljs-number">2021</span>;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(ll j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>e[i][j] = inf;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(ll j = i<span class="hljs-number">+1</span> ; j &lt;= n ; j ++)&#123;<br>ll gap = <span class="hljs-built_in">llabs</span>(i-j);<br><span class="hljs-keyword">if</span>(gap &lt;= <span class="hljs-number">21</span>)&#123;<br>e[i][j] = e[j][i] = <span class="hljs-built_in">lcm</span>(i,j);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// floyd</span><br><span class="hljs-keyword">for</span>(ll k = <span class="hljs-number">1</span> ; k &lt;= n ; k ++)&#123;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(e[i][k] == inf) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(ll j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>e[i][j] = <span class="hljs-built_in">min</span>(e[i][j], e[i][k] + e[k][j]);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;e[<span class="hljs-number">1</span>][<span class="hljs-number">2021</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回路计数">回路计数</h2><p>状态压缩DP求最短哈密顿回路（TSP）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">22</span>;<br><br>ll dp[maxn<span class="hljs-number">+1</span>][<span class="hljs-number">1</span>&lt;&lt;(maxn)];<br>ll n,ans;<br>vector&lt;ll &gt; e[maxn];<br><span class="hljs-comment">// ans = 881012367360</span><br><br><span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll x, ll y)</span></span>&#123;<br><span class="hljs-keyword">return</span> y == <span class="hljs-number">0</span> ? x : <span class="hljs-built_in">gcd</span>(y, x%y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(ll j = i<span class="hljs-number">+1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">gcd</span>(i, j) == <span class="hljs-number">1</span>)&#123;<br>e[i].<span class="hljs-built_in">push_back</span>(j);<br>e[j].<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>&#125;<br>&#125;<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(ll s = <span class="hljs-number">0</span>; s &lt;= (<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span> ; s ++)&#123;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>((s &gt;&gt; (i<span class="hljs-number">-1</span>)) &amp; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[i])&#123;<br>dp[i][s] += dp[it][s &amp; ~(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[<span class="hljs-number">1</span>])&#123;<br>ans += dp[it][(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>];<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="砝码称重">砝码称重</h2><p>DFS(7/15)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">2e5</span>;<br><br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> n, ans;<br><span class="hljs-type">bool</span> vis[maxm];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> d)</span></span>&#123;<br><span class="hljs-keyword">if</span>(d == n<span class="hljs-number">+1</span>)&#123;<br><span class="hljs-keyword">if</span>(l &gt; <span class="hljs-number">0</span> &amp;&amp; !vis[l])&#123;<br>vis[l] = <span class="hljs-literal">true</span>;<br>ans++;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>    <span class="hljs-comment">// 朴素枚举3种状态</span><br><span class="hljs-built_in">dfs</span>(l+a[d], d<span class="hljs-number">+1</span>);<br><span class="hljs-built_in">dfs</span>(l, d<span class="hljs-number">+1</span>);<br><span class="hljs-built_in">dfs</span>(l-a[d], d<span class="hljs-number">+1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>, a<span class="hljs-number">+1</span>+n);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>DP(15/15)</p><p>设<span class="math inline">\(dp[i][j]\)</span>为使用[1,i]区间内的砝码，能不能称出重量j。</p><p>状态转移方程： <span class="math display">\[dp[i][j] = dp[i-1][j] \space | \space dp[i-1][j+a[i]] \space | \spacedp[i-1][abs(j-a[i])]\]</span> 三种状态分别为：不使用砝码i | j为i砝码i和之前某一重量之和 |j为砝码i的之前某一重量之差。</p><p>这里用 |j-a[i]| 的原因是，虽然j-a[i]为负，但 |j-a[i]|仍然合法，将第i个砝码作为较重的一侧即可。</p><p>此外，这里不能用一维数组优化的原因是，涉及到 j+a[i] 和j-a[i]。因此，无论j从m到1，还是i到m，都会导致第i个砝码被复用的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">2e5</span>;<br><br><span class="hljs-type">bool</span> dp[maxn][maxm];<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> n, sum, ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>sum += a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= sum ; j ++)&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] | dp[i<span class="hljs-number">-1</span>][j+a[i]] | dp[i<span class="hljs-number">-1</span>][<span class="hljs-built_in">abs</span>(j-a[i])];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= sum ; i ++)&#123;<br><span class="hljs-keyword">if</span>(dp[n][i]) ans++;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异或数列">异或数列</h2><p>将一个X用异或运算拆分为A和B，A和B的大小取决于它们的最高非零位；</p><p>这可以理解成一个贪心问题，我们需要从高位到地位依次判断：</p><p>设bits[i] 为所有数的第i位一共包含几个1。</p><p>若bits[i] == 1，那么Alice的这一位一定为1，Bob这一位一定为0，Alice胜；</p><p>若bit[i] != 1且为奇数，先手必胜。但还需要考虑0位的个数，0位可以改变先后手顺序。若0位个数为偶数，Alice胜，否则Bob胜；</p><p>若bits[i]为偶数，那么该位无论怎么划分，Alice和Bob的这一位一定相同，考虑下一位；</p><p>若所有bits[i]都为偶数，二者平局。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> t;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> bits[<span class="hljs-number">30</span>]; <span class="hljs-comment">// 第i位一共包含几个1</span><br><br><span class="hljs-comment">// 统计 x 的每个为1的二进制位</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> bit = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br><span class="hljs-keyword">if</span>(x &amp; <span class="hljs-number">1</span>) bits[bit]++;<br>bit++;<br>x &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(bits,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(bits));<br><span class="hljs-type">int</span> n; cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br><span class="hljs-built_in">getBits</span>(a[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">21</span>; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>(bits[i] == <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;1\n&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(bits[i] &amp; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>((n - bits[i]) &amp; <span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;-1\n&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;1\n&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;0\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>蓝桥杯</category>
      
      <category>真题模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组">树状数组</h1><table><thead><tr><th>类型</th><th>下标修改</th><th>区间和查询</th></tr></thead><tbody><tr><td>普通数组</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(N)\)</span></td></tr><tr><td>前缀和数组</td><td><span class="math inline">\(O(N)\)</span></td><td><span class="math inline">\(O(1)\)</span></td></tr><tr><td>树状数组</td><td><span class="math inline">\(O(logN)\)</span></td><td><span class="math inline">\(O(logN)\)</span></td></tr></tbody></table><p>对于普通数组，区间和查询的复杂度较高；</p><p>前缀和数组虽然能优化区间和查询，但是下标修改的复杂度较高；</p><p>树状数组是一种居中策略，两种操作复杂度都为O(logN)。</p><figure><img src="/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/fenwick-tree-8.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>（图片来源：<a href="https://www.acwing.com/blog/content/80/">树状数组学习笔记 -AcWing</a>）</p><p>设 树状数组 为 c，c[i]表示[i - lowbit(i) + 1, i]区间的和。</p><p>1）更新数组：对a[i]更新k，对i 不断加上lowbit(i)，更新每个对应的c[i],直到上界N；</p><p>2）查询区间和： [1, i ]的区间和，依次减去lowbit(i),直到i等于0即可；</p><p>模板题：<a href="https://www.luogu.com.cn/problem/P3374">P3374【模板】树状数组 1 - 洛谷</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[maxn],f[maxn]; <span class="hljs-comment">// 注意a数组不是必要的</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">// return x &amp; (~x + 1)</span><br><span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-comment">// a[x] += k, 并更新f数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span>&#123;<br>a[x] += k;<br><span class="hljs-keyword">while</span>(x &lt;= n)&#123;<br>f[x] += k;<br>x += <span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 求a[1-x]的和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>res += f[x];<br>x -= <span class="hljs-built_in">lowbit</span>(x);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> v; cin&gt;&gt;v;<br><span class="hljs-built_in">update</span>(i, v);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> op; cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">int</span> x, k; cin&gt;&gt;x&gt;&gt;k;<br><span class="hljs-built_in">update</span>(x, k);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> x, y; cin&gt;&gt;x&gt;&gt;y;<br>cout&lt;&lt;<span class="hljs-built_in">getSum</span>(y) - <span class="hljs-built_in">getSum</span>(x<span class="hljs-number">-1</span>)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ST表维护区间最值</title>
    <link href="/algorithm/%E5%88%86%E6%B2%BB/ST%E8%A1%A8/"/>
    <url>/algorithm/%E5%88%86%E6%B2%BB/ST%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="st表维护区间最值">ST表维护区间最值</h1><figure><img src="/algorithm/%E5%88%86%E6%B2%BB/ST%E8%A1%A8/5b35091851d33f0dabd3f244201c5b41.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>（图片来源：<a href="https://blog.csdn.net/a1130683021/article/details/132729361">ST表（保姆级，简单易懂）-CSDN博客</a>）</p><p>ST表可以用上面这张图来理解。</p><p>要求长度为2^N的区间最值，就是在求左右两个2^N-1区间最值中较大的那个。</p><p>依次类推，预处理所有2倍数长度区间最值的复杂度将为O(logN*N)。</p><p>要求[L，R]区间的最大值，等效于分别求 [L, L+2^K - 1] 和 [R - 2^K + 1,R]这两个区间的最值。</p><p>每次查询的复杂度为O(1)。</p><p>模板题：<a href="https://www.luogu.com.cn/problem/P3865">P3865【模板】ST 表 &amp;&amp; RMQ 问题 - 洛谷</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> lg[maxn],st[maxn][<span class="hljs-number">30</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;st[i][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">// lg[1] = 0;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>lg[i] = lg[i/<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// cout&lt;&lt;&quot;log2^&quot;&lt;&lt;i&lt;&lt;&quot; == &quot;&lt;&lt;lg[i]&lt;&lt;&quot;\n&quot;;</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= lg[n] ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j + (<span class="hljs-number">1</span>&lt;&lt;i) - <span class="hljs-number">1</span> &lt;= n ; j ++)&#123;<br>st[j][i] = <span class="hljs-built_in">max</span>(st[j][i<span class="hljs-number">-1</span>], st[j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> l, r; cin&gt;&gt;l&gt;&gt;r;<br><span class="hljs-type">int</span> k = lg[r - l + <span class="hljs-number">1</span>];<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(st[l][k], st[r-(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">+1</span>][k])&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-built_in">solve</span>(); <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经典例题：<a href="https://www.luogu.com.cn/problem/P3865">P3865【模板】ST 表 &amp;&amp; RMQ 问题 - 洛谷</a></p><p>要求一个[L,R]区间内的极差，就是查询该区间的最大值 -最小值，可使用ST表解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e4</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, q;<br><span class="hljs-type">int</span> lg[maxn], st_min[maxn][<span class="hljs-number">30</span>], st_max[maxn][<span class="hljs-number">30</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>lg[i] = lg[i/<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;st_min[i][<span class="hljs-number">0</span>];<br>st_max[i][<span class="hljs-number">0</span>] = st_min[i][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= lg[n] ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j + (<span class="hljs-number">1</span>&lt;&lt;i) - <span class="hljs-number">1</span> &lt;= n ; j ++)&#123;<br>st_max[j][i] = <span class="hljs-built_in">max</span>(st_max[j][i<span class="hljs-number">-1</span>], st_max[j + (<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>]);<br>st_min[j][i] = <span class="hljs-built_in">min</span>(st_min[j][i<span class="hljs-number">-1</span>], st_min[j + (<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a, b; cin&gt;&gt;a&gt;&gt;b;<br><span class="hljs-type">int</span> k = lg[b-a<span class="hljs-number">+1</span>];<br><span class="hljs-type">int</span> max_ = <span class="hljs-built_in">max</span>(st_max[a][k], st_max[b-(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">+1</span>][k]);<br><span class="hljs-type">int</span> min_ = <span class="hljs-built_in">min</span>(st_min[a][k], st_min[b-(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">+1</span>][k]);<br>cout&lt;&lt;max_ - min_&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(q--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>分治</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯软件赛C++A组省赛真题训练：2022年</title>
    <link href="/competition/lanqiao/2022/"/>
    <url>/competition/lanqiao/2022/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯软件赛ca组省赛真题训练2022年">蓝桥杯软件赛C++A组省赛真题训练：2022年</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/solution/P8770">P8770[蓝桥杯 2022 省 A] 填空问题 - 洛谷</a></td><td>找规律</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/solution/P8770">P8770[蓝桥杯 2022 省 A] 填空问题 - 洛谷</a></td><td>博弈论</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8772">P8772 [蓝桥杯 2022省 A] 求和 - 洛谷</a></td><td>前缀和</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/solution/P8773">P8773[蓝桥杯 2022 省 A] 选数异或 - 洛谷</a></td><td>ST表</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8775">P8775 [蓝桥杯 2022省 A] 青蛙过河 - 洛谷</a></td><td>前缀和，二分</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P8778">P8778 [蓝桥杯 2022省 A] 数的拆分 - 洛谷</a></td><td>数论</td></tr></tbody></table><h2 id="裁纸刀">裁纸刀</h2><p>无论哪种裁法，需要的次数都相同。</p><p>从一张无界的纸上上裁剪出n行m列等大的正方形，需要至少裁剪4 + (n-1) +n*(m-1)次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-comment">// 443</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br>cout&lt;&lt;<span class="hljs-number">4</span> + (n<span class="hljs-number">-1</span>) + n*(m<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="灭鼠先锋">灭鼠先锋</h2><p>分析情况1</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">X000</span><br><span class="hljs-number">0000</span><br></code></pre></td></tr></table></figure><p>枚举后手下两个的所有情况，都必输</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">XXX0</span> X0XX X000 X000<br><span class="hljs-attribute">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0</span>XX0 XX00<br></code></pre></td></tr></table></figure><p>枚举后手下一个的所有情况，都必输</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp">XX<span class="hljs-number">00</span> X0X<span class="hljs-number">0</span> X00X <span class="hljs-keyword">X</span><span class="hljs-number">000</span> <span class="hljs-keyword">X</span><span class="hljs-number">000</span> <span class="hljs-keyword">X</span><span class="hljs-number">000</span> <span class="hljs-keyword">X</span><span class="hljs-number">000</span><br><span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-keyword">X</span><span class="hljs-number">000</span> <span class="hljs-number">0X00</span> <span class="hljs-number">00</span><span class="hljs-keyword">X</span><span class="hljs-number">0</span> <span class="hljs-number">000</span><span class="hljs-keyword">X</span><br></code></pre></td></tr></table></figure><p>后续情况依次类推，得到结果为LLLV</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;LLLV&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求和">求和</h2><p>给定 <em>n</em> 个整数 a1,a2,⋯,an, 求它们两两相乘再相加的和。</p><p>相当于从2遍历到n，结果累加a[i]依次乘上a[1 - i-1]的值之和。</p><p>使用前缀和优化这个累加过程即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br>ll a[maxn],pre[maxn];<br>ll n,sum;<br><br><span class="hljs-comment">// a1*a[2-n]</span><br><span class="hljs-comment">// a2*a[3-n]</span><br><span class="hljs-comment">// an*a[n-n]</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>pre[i] = pre[i<span class="hljs-number">-1</span>] + a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>sum += a[i]*(pre[n] - pre[i]);<br>&#125;<br>cout&lt;&lt;sum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选数异或">选数异或</h2><p>设 a^b = x，可得 b = a^x</p><p>设f[i] 表示 [1, i] 区间内最大的 b 下标。</p><p>在遍历a[i]数组时，更新这个值，后续只要查询f[r] 是否 &gt;=l，即可判断是否存在a[i]^a[j] = x。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br>unordered_map&lt;ll, ll&gt; mp;<br><br>ll n, m, x;<br>ll a[maxn], f[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>f[i] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>], mp[a[i]^x]);<br>mp[a[i]] = i;<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>ll l, r; cin&gt;&gt;l&gt;&gt;r;<br>cout&lt;&lt;(f[r] &lt; l ? <span class="hljs-string">&quot;no\n&quot;</span>:<span class="hljs-string">&quot;yes\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="青蛙过河">青蛙过河</h2><p>若直接使用二分法，check遍历判断会导致超时，只能拿到部分分。</p><p>但可以用前缀和对二分法的check函数进行优化。</p><p>首先，青蛙 从左岸到右岸 和 从右岸到左岸没有区别；青蛙跳的2*x条路径的顺序也不影响结果。</p><p>因此，可以将原题看作是2x只青蛙同时从左岸跳到右岸。</p><p>然后，可以进一步看作是 2*x 只青蛙依次从[1, y]区间移动到[2, y+1],再依次移动到[n-y, n-1]。</p><p>等效于：每个[i, y+i-1] 的高度和 &gt;= 2*x。</p><p>暴力解法（60/100）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, x;<br><span class="hljs-type">int</span> h[maxn],t[maxn],mh;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> jp)</span></span>&#123;<br><span class="hljs-built_in">memcpy</span>(t,h,<span class="hljs-built_in">sizeof</span>(h));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= x ; i ++)&#123;<br><span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(now + jp &lt; n)&#123;<br><span class="hljs-type">int</span> nex = now + jp;<br><span class="hljs-keyword">while</span>(nex &gt; now &amp;&amp; t[nex] == <span class="hljs-number">0</span>) nex--;<br><span class="hljs-keyword">if</span>(nex &lt;= now) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>now = nex;<br>t[now]--;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;x;<br>x *= <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;h[i];<br>&#125;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = n;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;r;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前缀和优化（100/100）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, x;<br><span class="hljs-type">int</span> h[maxn], pre[maxn];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> jp)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i+jp<span class="hljs-number">-1</span> &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(pre[i+jp<span class="hljs-number">-1</span>] - pre[i<span class="hljs-number">-1</span>] &lt; x)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;x;<br>x *= <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;h[i];<br>pre[i] = pre[i<span class="hljs-number">-1</span>] + h[i];<br>&#125;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = n;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;r;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数的拆分">数的拆分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>ll t;<br>vector&lt;ll&gt; is_prime, prime;<br><br><span class="hljs-comment">// 判断 x 是否为 立方数 / 平方数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll x)</span></span>&#123;<br>ll a = <span class="hljs-built_in">pow</span>(x, <span class="hljs-number">1.0</span>/<span class="hljs-number">2</span>);<br>ll b = <span class="hljs-built_in">pow</span>(x, <span class="hljs-number">1.0</span>/<span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span>(a*a == x || (a<span class="hljs-number">+1</span>)*(a<span class="hljs-number">+1</span>) == x || (a<span class="hljs-number">-1</span>)*(a<span class="hljs-number">-1</span>) == x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(b*b*b == x || (b<span class="hljs-number">+1</span>)*(b<span class="hljs-number">+1</span>)*(b<span class="hljs-number">+1</span>) == x || (b<span class="hljs-number">-1</span>)*(b<span class="hljs-number">-1</span>)*(b<span class="hljs-number">-1</span>) == x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求[1-n]内的质数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_prime</span><span class="hljs-params">(ll n)</span></span>&#123;<br>is_prime.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>, <span class="hljs-literal">true</span>);<br>is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(is_prime[i])&#123;<br>prime.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i*i ; j &lt;= n ; j += i)&#123;<br>is_prime[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x)</span></span>&#123;<br><span class="hljs-comment">// 情况1：x^2*y^3</span><br><span class="hljs-comment">// 所有 &gt; 1 的整数都可表示为 2A + 3B</span><br><span class="hljs-comment">// 因此，原题可规约为 x^2*y^3；</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : prime)&#123;<br>ll cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x % it == <span class="hljs-number">0</span>)&#123;<br>x /= it;<br>cnt++;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 情况2：x^2 * 1 或者 x^3 * 1</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(x)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-comment">// x^2*y^3中，x, y 的最小值为 10^(18/5) &lt; 4000</span><br><span class="hljs-built_in">init_prime</span>(<span class="hljs-number">4000</span>);<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br>ll x; cin&gt;&gt;x;<br>cout&lt;&lt;(<span class="hljs-built_in">check</span>(x) ? <span class="hljs-string">&quot;yes&quot;</span>:<span class="hljs-string">&quot;no&quot;</span>)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>蓝桥杯</category>
      
      <category>真题模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯软件赛C++A组省赛真题训练：2023年</title>
    <link href="/competition/lanqiao/2023/"/>
    <url>/competition/lanqiao/2023/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯软件赛ca组省赛真题训练2023年">蓝桥杯软件赛C++A组省赛真题训练：2023年</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P9230">P9230 [蓝桥杯 2023省 A] 幸运数 - 洛谷</a></td><td>模拟</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P9230">P9230 [蓝桥杯 2023省 A] 有奖问答 - 洛谷</a></td><td>DFS</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P9231">P9231 [蓝桥杯 2023省 A] 平方差 - 洛谷</a></td><td>数学</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P9232">P9232 [蓝桥杯 2023省 A] 更小的数 - 洛谷</a></td><td>区间DP</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P9234">P9234 [蓝桥杯 2023省 A] 买瓜 - 洛谷</a></td><td>折半搜索</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P9236">P9236 [蓝桥杯 2023省 A] 异或和之和 - 洛谷</a></td><td>位运算，前缀和</td></tr></tbody></table><h2 id="幸运数">幸运数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-comment">// 4430091</span><br>ll ans;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll x)</span></span>&#123;<br>ll len = <span class="hljs-number">0</span>;<br>ll a[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">while</span>(x)&#123;<br>a[++len] = x % <span class="hljs-number">10</span>;<br>x /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(len % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>ll s1 = <span class="hljs-number">0</span>, s2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i &lt;= len/<span class="hljs-number">2</span>) s1 += a[i];<br><span class="hljs-keyword">else</span> s2 += a[i];<br>&#125;<br><span class="hljs-keyword">return</span> s1 == s2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">100000000</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(i))&#123;<br>ans++;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有奖问答">有奖问答</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 8335366</span><br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> sco)</span></span>&#123;<br><span class="hljs-keyword">if</span>(sco == <span class="hljs-number">70</span>)&#123;<br>ans++;<br>&#125;<br><span class="hljs-keyword">if</span>(dep &gt; <span class="hljs-number">30</span> || sco &gt;= <span class="hljs-number">100</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>, sco<span class="hljs-number">+10</span>);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="平方差">平方差</h2><p>题目要求我们找[L,R]区间内所有能找到 (y + z)(y - z) == x 的x的个数。设 t = y + z ; y - z = t - 2<em>z</em></p><p>原条件等效于x = t*(t - 2*z)</p><p>对所有的奇数，都可以找到x = x*1；</p><p>对所有的偶数：</p><p>1）若x/2 == 偶数，都可以找到 x = (x/2)*(2);</p><p>2）若x/2 == 奇数，找不到解；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><br><span class="hljs-comment">// n == 1 -&gt; 1*(1 - 0)</span><br><span class="hljs-comment">// n == 2 -&gt; 无</span><br><span class="hljs-comment">// n == 3 -&gt; 3*(3 - 2)</span><br><span class="hljs-comment">// n == 4 -&gt; 2*(2 - 0)</span><br><span class="hljs-comment">// n == 5 -&gt; 5*(5 - 4)</span><br><span class="hljs-comment">// n == 6 -&gt; 无</span><br><span class="hljs-comment">// n == 7 -&gt; 7*(7 - 6)</span><br><span class="hljs-comment">// n == 8 -&gt; 4*(4 - 2)</span><br><span class="hljs-comment">// n == 10 -&gt; 无</span><br><span class="hljs-comment">// n == 11 -&gt; 11*(11 - 10)</span><br><span class="hljs-comment">// n == 12 -&gt; 6*(6 - 4)</span><br><span class="hljs-comment">// n == 13 -&gt; 13*(13 - 12)</span><br><span class="hljs-comment">// n == 14 -&gt; 无</span><br><br>ll l, r;<br>ll ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;l&gt;&gt;r;<br><span class="hljs-keyword">for</span>(ll i = l ; i &lt;= r ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; (i/<span class="hljs-number">2</span>) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>ans++;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="更小的数">更小的数</h2><p>区间DP求最长回文子串的变形。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e3</span> + <span class="hljs-number">10</span>;<br><br>string s;<br><span class="hljs-type">int</span> dp[maxn][maxn];<br><span class="hljs-comment">// -1 -&gt; l &lt; r</span><br><span class="hljs-comment">//  0 -&gt; l == r</span><br><span class="hljs-comment">//  1 -&gt; l &gt; r</span><br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>s = <span class="hljs-string">&quot; &quot;</span> + s;<br>    <span class="hljs-comment">// 初始化长度为1和2的情况</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= len ; i ++)&#123;<br>dp[i][i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(i<span class="hljs-number">+1</span> &lt;= len)&#123;<br><span class="hljs-keyword">if</span>(s[i] &lt; s[i<span class="hljs-number">+1</span>]) dp[i][i<span class="hljs-number">+1</span>] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == s[i<span class="hljs-number">+1</span>]) dp[i][i<span class="hljs-number">+1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span>&#123;<br>dp[i][i<span class="hljs-number">+1</span>] = <span class="hljs-number">1</span>;<br>ans++;<br>&#125;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// dp递归</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">3</span> ; t &lt;= len ; t ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i + t - <span class="hljs-number">1</span> &lt;= len ; i ++)&#123;<br><span class="hljs-type">int</span> l = i;<br><span class="hljs-type">int</span> r = i+t<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(s[l] &lt; s[r]) dp[l][r] = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[l] &gt; s[r])dp[l][r] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[l] == s[r]) dp[l][r] = dp[l<span class="hljs-number">+1</span>][r<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(dp[l][r] == <span class="hljs-number">1</span>) ans++;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="买瓜">买瓜</h2><p>直接进行DFS搜索的时间复杂度为O(3^n)，这一复杂度是不可接受的。</p><p>进行折半搜索，复杂度为O(3^n/2)：先查找前一半的组合，存入哈希表，再查找后一半的组合。</p><p>此外，还要对原数组进行排序，以优化DFS的剪枝效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll maxn = <span class="hljs-number">50</span>;<br><br>ll n, nh, m, ans;<br>ll a[maxn];<br>unordered_map&lt;ll, ll&gt; mp;<br><br><span class="hljs-comment">// 找前一半的瓜的所有重量和</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(ll d, ll cnt, ll sum)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cnt &gt; ans || sum &gt; m) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 剪枝</span><br><span class="hljs-keyword">if</span>(sum == m)&#123; <span class="hljs-comment">// 若已经满足条件，更新ans</span><br>ans = <span class="hljs-built_in">min</span>(ans, cnt);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(d == nh + <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 若找完前一半还未满足条件，记录状态到mp</span><br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(sum))&#123;<br>mp[sum] = <span class="hljs-built_in">min</span>(mp[sum], cnt);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>mp[sum] = cnt;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">dfs1</span>(d<span class="hljs-number">+1</span>, cnt, sum); <span class="hljs-comment">// 拿，不劈</span><br><span class="hljs-built_in">dfs1</span>(d<span class="hljs-number">+1</span>, cnt, sum + a[d]); <span class="hljs-comment">// 拿，劈</span><br><span class="hljs-built_in">dfs1</span>(d<span class="hljs-number">+1</span>, cnt<span class="hljs-number">+1</span>, sum + a[d]/<span class="hljs-number">2</span>); <span class="hljs-comment">// 不拿</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(ll d, ll cnt, ll sum)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cnt &gt; ans || sum &gt; m) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(sum == m)&#123;<br>ans = <span class="hljs-built_in">min</span>(ans, cnt);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(d == n<span class="hljs-number">+1</span>)&#123; <span class="hljs-comment">// 更新ans</span><br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(m - sum))&#123;<br>ans = <span class="hljs-built_in">min</span>(ans, mp[m-sum] + cnt);<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">dfs2</span>(d<span class="hljs-number">+1</span>, cnt, sum);<br><span class="hljs-built_in">dfs2</span>(d<span class="hljs-number">+1</span>, cnt, sum + a[d]);<br><span class="hljs-built_in">dfs2</span>(d<span class="hljs-number">+1</span>, cnt<span class="hljs-number">+1</span>, sum + a[d]/<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br>m *= <span class="hljs-number">2</span>;<br>nh = n/<span class="hljs-number">2</span>;<br>ans = INT_MAX;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i]; a[i] *= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>, a<span class="hljs-number">+1</span>+n); <span class="hljs-comment">// 排序，提高剪枝效率</span><br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">dfs2</span>(nh<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>cout&lt;&lt;(ans == INT_MAX ? <span class="hljs-number">-1</span> : ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异或和之和">异或和之和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>ll n,ans;<br>ll a[maxn], pre[maxn], cnt[<span class="hljs-number">50</span>][<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>pre[i] = pre[i<span class="hljs-number">-1</span>]^a[i];<br>&#125;<br>    <span class="hljs-comment">//for(ll i = 1 ; i &lt;= n ; i ++)&#123;</span><br>    <span class="hljs-comment">//for(ll j = 1 ; j &lt;= i ; j ++)&#123;</span><br>    <span class="hljs-comment">//ans += pre[i]^pre[j-1];</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">// 上式可以进行优化</span><br>    <span class="hljs-comment">// 对于所有pre中第j位，它对结果的贡献为 所有第j位0的个数 * 所有第j位1的个数 * (2^i)</span><br>    <span class="hljs-comment">// 即：共有多少种(i,j)组合，使得这一位的异或和为1</span><br>    <span class="hljs-comment">// 累加所有位【0-20】，即可得到总和</span><br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">0</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(ll j = <span class="hljs-number">20</span> ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>cnt[j][(pre[i]&gt;&gt;j)&amp;<span class="hljs-number">1</span>]++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">20</span> ; i ++)&#123;<br>ans += cnt[i][<span class="hljs-number">0</span>]*cnt[i][<span class="hljs-number">1</span>]*(<span class="hljs-number">1</span>&lt;&lt;i);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>蓝桥杯</category>
      
      <category>真题模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯软件赛C++A组省赛真题训练：2024年</title>
    <link href="/competition/lanqiao/2024/"/>
    <url>/competition/lanqiao/2024/</url>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯软件赛ca组省赛真题训练2024年">蓝桥杯软件赛C++A组省赛真题训练：2024年</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>知识点</th></tr></thead><tbody><tr><td><a href="https://www.luogu.com.cn/problem/P10385">P10385 [蓝桥杯2024 省 A] 艺术与篮球 - 洛谷</a></td><td>日期，模拟</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P10386">P10386 [蓝桥杯2024 省 A] 五子棋对弈 - 洛谷</a></td><td>模拟</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P10387">P10387 [蓝桥杯2024 省 A] 训练士兵 - 洛谷</a></td><td>前缀和</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P10388">P10388 [蓝桥杯2024 省 A] 团建 - 洛谷</a></td><td>多重DFS 求 树的最长公共路径</td></tr><tr><td><a href="https://www.luogu.com.cn/problem/P10389">P10389 [蓝桥杯2024 省 A] 成绩统计 - 洛谷</a></td><td>前缀和、二分答案</td></tr></tbody></table><h2 id="艺术与篮球">艺术与篮球</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> c[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> monthDays[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">31</span>, <span class="hljs-number">28</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>&#125;;<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-comment">// 闰年判断</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLuckyYear</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">return</span> (y % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> || (y % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; y % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>));<br>&#125;<br><br><span class="hljs-comment">// 得到一个月的日数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDay</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m)</span></span>&#123;<br><span class="hljs-keyword">if</span>(m == <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">isLuckyYear</span>(y))&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">29</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> monthDays[m];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 笔画数是否超过50</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>&#123;<br><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">sprintf</span>(str,<span class="hljs-string">&quot;%04d%02d%02d&quot;</span>,y,m,d);<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">8</span> ; i ++)&#123;<br>sum += c[(str[i] - <span class="hljs-string">&#x27;0&#x27;</span>)];<br>&#125;<br><span class="hljs-keyword">return</span> sum &gt; <span class="hljs-number">50</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-comment">//2000 年 1 月 1 日 到 2023 年 12 月 31 日</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">2000</span> ; y &lt;= <span class="hljs-number">2023</span> ; y ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m = <span class="hljs-number">1</span> ; m &lt;= <span class="hljs-number">12</span> ; m ++)&#123;<br><span class="hljs-type">int</span> D = <span class="hljs-built_in">getDay</span>(y,m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d = <span class="hljs-number">1</span> ; d &lt;= D ; d ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(y,m,d)) ans++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 2024 年 1 月 1 日 到 2024 年 4 月 13 日</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m = <span class="hljs-number">1</span> ; m &lt;= <span class="hljs-number">4</span> ; m ++)&#123;<br><span class="hljs-type">int</span> D = <span class="hljs-built_in">getDay</span>(<span class="hljs-number">2024</span>, m);<br><span class="hljs-keyword">if</span>(m == <span class="hljs-number">4</span>) D = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d = <span class="hljs-number">1</span> ; d &lt;= D ; d ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(<span class="hljs-number">2024</span>,m,d)) ans++;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五子棋对弈">五子棋对弈</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 易错：白/黑的比例应该是13/12</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">5</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">5</span> ; j ++)&#123;<br>sum += a[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(sum != <span class="hljs-number">13</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">bool</span> f;<br><span class="hljs-comment">// 行</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">5</span> ; i ++)&#123;<br>f = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 是否相同</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> ; j &lt;= <span class="hljs-number">5</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j] != a[i][j<span class="hljs-number">-1</span>])&#123;<br>f = <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(f) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">5</span> ; i ++)&#123;<br>f = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 是否相同</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> ; j &lt;= <span class="hljs-number">5</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[j][i] != a[j<span class="hljs-number">-1</span>][i])&#123;<br>f = <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(f) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 主对角线</span><br>f = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= <span class="hljs-number">5</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(a[i][i] != a[i<span class="hljs-number">-1</span>][i<span class="hljs-number">-1</span>])&#123;<br>f = <span class="hljs-literal">false</span>; <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(f) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 副对角线</span><br>f = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= <span class="hljs-number">5</span> ; i ++)&#123;<br><span class="hljs-type">int</span> x = i; <span class="hljs-type">int</span> y = <span class="hljs-number">5</span> - i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[x][y] != a[x<span class="hljs-number">-1</span>][y<span class="hljs-number">+1</span>])&#123;<br>f = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(f) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == <span class="hljs-number">5</span> &amp;&amp; y == <span class="hljs-number">5</span>)&#123;<br>a[x][y] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>()) ans++;<br>a[x][y] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>()) ans++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>a[x][y] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">5</span>) <span class="hljs-built_in">dfs</span>(x, y<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">dfs</span>(x<span class="hljs-number">+1</span>, <span class="hljs-number">1</span>);<br>a[x][y] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">5</span>) <span class="hljs-built_in">dfs</span>(x, y<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">dfs</span>(x<span class="hljs-number">+1</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="训练士兵">训练士兵</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll maxm = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br>ll n, s, max_c;<br>ll p[maxn], c[maxn];<br>ll ans, now;<br>ll sum[maxm],cnt[maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;p[i]&gt;&gt;c[i];<br>cnt[c[i]] += p[i]; <span class="hljs-comment">// cnt[i] == 总共需要训练次数为i的所有士兵的代价和</span><br>max_c = <span class="hljs-built_in">max</span>(c[i], max_c);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = max_c ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br>sum[i] = sum[i<span class="hljs-number">+1</span>] + cnt[i]; <span class="hljs-comment">// sum[i] == cnt[i]的后缀和</span><br>&#125;<br>now = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(sum[now] != <span class="hljs-number">0</span>)&#123;<br>ans += <span class="hljs-built_in">min</span>(s, sum[now]);<br>now++;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="团建">团建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m,ans;<br><span class="hljs-type">int</span> a[maxn],b[maxn];<br>vector&lt;<span class="hljs-type">int</span>&gt; e[maxn],d[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy)</span></span>&#123;<br>ans = <span class="hljs-built_in">max</span>(dep, ans);<br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it != fx)&#123;<br>mp[a[it]] = it;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : d[y])&#123;<br><span class="hljs-keyword">if</span>(it != fy)&#123;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(b[it]))&#123;<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>, mp[b[it]], it, x, y);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br>cin&gt;&gt;b[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;<br>e[u].<span class="hljs-built_in">push_back</span>(v);<br>e[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;<br>d[u].<span class="hljs-built_in">push_back</span>(v);<br>d[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>]) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="成绩统计">成绩统计</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>ll n, k, t;<br>ll a[maxn],b[maxn],sum[maxn],sum2[maxn];<br><br><span class="hljs-comment">// 方差等于均方值减去均值的平方</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">get_std</span><span class="hljs-params">(ll l, ll r)</span></span>&#123;<br><span class="hljs-type">double</span> avg = <span class="hljs-number">1.0</span>*(sum[r] - sum[l<span class="hljs-number">-1</span>])/k;<br><span class="hljs-type">double</span> avg2 = <span class="hljs-number">1.0</span>*(sum2[r] - sum2[l<span class="hljs-number">-1</span>])/k;<br><span class="hljs-keyword">return</span> avg2 - avg*avg;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= x ; i ++)&#123;<br>b[i] = a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(b<span class="hljs-number">+1</span>, b<span class="hljs-number">+1</span>+x);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= x ; i ++)&#123;<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + b[i];<br>sum2[i] = sum2[i<span class="hljs-number">-1</span>] + b[i]*b[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k ; i &lt;= x ; i ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">get_std</span>(i-k<span class="hljs-number">+1</span>, i) &lt; <span class="hljs-number">1.0</span>*t)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k&gt;&gt;t;<br><span class="hljs-keyword">if</span>(k &gt; n)&#123;<br>cout&lt;&lt;<span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>ll l = k<span class="hljs-number">-1</span>;<br>ll r = n;<br>ll ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br>ll mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>r = mid;<br>ans = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>l = mid;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>蓝桥杯</category>
      
      <category>真题模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛模拟：2025年校赛</title>
    <link href="/competition/GPLT/2025-school/"/>
    <url>/competition/GPLT/2025-school/</url>
    
    <content type="html"><![CDATA[<h1 id="gplt团体程序设计天梯赛模拟2025年校赛">GPLT团体程序设计天梯赛模拟：2025年校赛</h1><h2 id="摘要">摘要</h2><table><thead><tr><th>题目</th><th>分值</th><th>知识点</th></tr></thead><tbody><tr><td>竞赛</td><td>10</td><td>容斥原理</td></tr><tr><td>盒子游戏</td><td>15</td><td>博弈论</td></tr><tr><td>游戏机前的队伍</td><td>25</td><td>模拟、数据结构</td></tr><tr><td>国家管理</td><td>25</td><td>DFS</td></tr><tr><td>灯</td><td>25</td><td>二分答案</td></tr><tr><td>科技树</td><td>30</td><td>树上背包</td></tr></tbody></table><h2 id="l4-竞赛">L4 竞赛</h2><blockquote><p>Alice的班级有50名学生参与三种学科竞赛：数学、物理和化学。已知：</p><ul><li>参加数学竞赛的有25人，物理竞赛28人，化学竞赛20人；</li><li>同时参加数学和物理的有12人，同时参加数学和化学的有8人，同时参加物理和化学的有10人；</li><li>同时参加所有三种竞赛的有5人。</li></ul><p><strong>问题：</strong></p><ol type="1"><li>至少参加一项竞赛的学生有多少人？</li><li>恰好参加两种竞赛的学生有多少人？</li></ol></blockquote><p>Alice很快解决了该问题，于是其他班级的同学也向Alice求助，请你写个程序来自动解决这类问题：给出8个数字，分别代表学生总数<em>n</em> 、数学竞赛的人数 <em>a</em> 、参加物理竞赛的人数 <em>b</em>、参加化学竞赛的人数 <em>c</em> 、同时参加数学和物理的人数 <em>ab</em>、同时参加数学和化学的人数 *a**c* 、同时参加物理和化学的人数 *b**c*、同时参加所有三种竞赛的人数 *ab**c*，问至少参加一项竞赛的学生有多少人？恰好参加两种竞赛的学生有多少人？</p><h3 id="输入格式">输入格式：</h3><p>输入一行，给出八个均不超过 100 的整数<em>n</em>,<em>a</em>,<em>b</em>,<em>c</em>,<em>ab</em>,<em>a<strong>c<em>,</em>b</strong>c</em>,*ab**c*，含义同题目描述。</p><h3 id="输出格式">输出格式：</h3><p>在一行中输出用空格间隔的两个正整数<em>an<strong>s<em>1,</em>an</strong>s</em>2 ，其中 <em>an<strong>s<em>1代表至少参加一项竞赛的学生人数，</em>an</strong>s</em>2代表恰好参加两种竞赛的学生人数。</p><h3 id="输入样例">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">50 25 28 20 12 8 10 5<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">48 15<br></code></pre></td></tr></table></figure><h3 id="题解">题解：</h3><figure><img src="/competition/GPLT/2025-school/incexcp.png" alt="容斥原理 - venn 图示例"><figcaption aria-hidden="true">容斥原理 - venn 图示例</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,a,b,c,ab,ac,bc,abc;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;ab&gt;&gt;ac&gt;&gt;bc&gt;&gt;abc;<br>cout&lt;&lt;a+b+c - ab - ac - bc + abc&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;(ab+bc+ac - <span class="hljs-number">3</span>*abc);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="l5-盒子游戏">L5 盒子游戏</h2><p>有两个相同的盒子，其中一个装了 n 个球，另一个装了一个球。 Alice 和Bob 发明了一个游戏，规则如下：</p><p>Alice 和 Bob 轮流操作， Alice先操作。每次操作时，游戏者先看看哪个盒子里的球的数目比较少（数量相同就随便选一个盒子），然后清空这个盒子（盒子里的球直接扔掉），然后把另一个盒子里的球拿一些到这个盒子中，使得两个盒子都至少有一个球。如果一个游戏者无法进行操作（无法使得两个盒子都至少有一个球），他（她）就输了。下面一行是一个<em>n</em>=6 的游戏：</p><p>Alice先操作，分为 (3,3) Bob操作，丢弃 3 ，剩下 3 ，分为 (1,2)Alice操作，丢弃 1 ，剩下 2 ，分为 (1,1) Bob操作， 丢弃 1 ，剩下 1 Bob无法继续操作，因此 Alice 获胜。</p><p>你的任务是找出谁会获胜。假定两人都很聪明，总是采取最优策略。</p><h3 id="输入格式-1">输入格式：</h3><p>输入最多包含 300 组测试数据。每组数据仅一行，包含一个整数 <em>n</em>(2≤<em>n</em>≤109) 。输入结束标志为 <em>n</em>=0 。</p><h3 id="输出格式-1">输出格式：</h3><p>对于每组数据，输出胜者的名字。</p><h3 id="输入样例-1">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs in">2<br>3<br>4<br>0<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">Alice<br>Bob<br>Alice<br></code></pre></td></tr></table></figure><h3 id="题解-1">题解：</h3><p>根据题意， 谁先拿到1，无法分解就lose。</p><p>n = 1，Alice(1) lose</p><p>n = 2，Alice(2) -&gt; Bob(1) win</p><p>n = 3，Alice(3) -&gt; Bob(2) -&gt; Alice(1) lose</p><p>n = 4，Alice(4) -&gt; Bob(3) win</p><p>这里4一定分解为3,1。若将4分解为2,2，Bob拿到2，Alice就会输；若将4分解为3,1，Bob拿到3，根据n=3的结果，先拿到3的人将lose，所以Alice是必胜；</p><p>根据上述情况递推，可以得到 1，3，7，15的情况【2^n -1】，Alice会输，否则会赢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>set&lt;<span class="hljs-type">int</span> &gt; st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-type">int</span> t = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(t &lt;= <span class="hljs-number">1e9</span>)&#123;<br>st.<span class="hljs-built_in">insert</span>(t<span class="hljs-number">-1</span>);<br>t *= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;x, x)&#123;<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(x))&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Bob\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Alice\n&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="m1-游戏机前的队伍"><strong>M1</strong> 游戏机前的队伍</h2><p><strong>补充说明：这里的排队和传统的排队有出入。正在游玩的人为队列的前两位，所以正在游玩视为正在排队。</strong></p><p>机厅里有一台游戏机，每次可供最多两人同时游玩。但是来玩的人显然不止两个！这个时候他们就需要排队了，而你需要写一个程序维护这个队列，并在他人游玩结束后通知接下来上场的人。在整个过程中，有以下几种事件可能发生：</p><ul><li><code>start</code>：一局游戏开始。若这不是第一局游戏，则上一局的参与者<strong>在这一局游戏开始前一瞬间</strong>按照原本的顺序回到队尾。此时你应该按在队列中的顺序输出这一局上场的人的名字（正常来讲是队列前两位或者唯一一个人），若有两个则以空格分割。若这一局无人上场，则输出<code>Error</code> 并忽略这条事件。</li><li><code>arrive x</code>：<em>x</em> 到达机厅并且将自己加入队尾，此时<em>x</em> 不应该在排队，否则输出 <code>Error</code>并忽略这条事件。若该事件成功执行则输出 <code>OK</code>。</li><li><code>leave x</code>：<em>x</em> 离开机厅并离开队列。此时 <em>x</em>应该在排队但不应该在游玩，否则输出 <code>Error</code>并忽略这条事件。若该事件成功执行则输出 <code>OK</code>。</li></ul><p>你需要维护队列信息，并输出上述事件中要求的输出。</p><h3 id="输入格式-2">输入格式</h3><p>第一行一个整数<em>n</em>(1≤<em>n</em>≤1<em>e</em>5)，表示事件条数。</p><p>接下来 <em>n</em> 行，每行表示一条事件。</p><h3 id="输出格式-2">输出格式</h3><p>按照题目要求输出 <em>n</em> 行，表示程序对事件的响应。</p><h3 id="输入样例1">输入样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs in">14<br>start<br>arrive A<br>start<br>arrive B<br>arrive C<br>arrive D<br>start<br>leave C<br>leave D<br>start<br>arrive A<br>arrive D<br>leave E<br>start<br></code></pre></td></tr></table></figure><h3 id="输出样例1">输出样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs out">Error<br>OK<br>A<br>OK<br>OK<br>OK<br>B C<br>Error<br>OK<br>A B<br>Error<br>OK<br>Error<br>C D<br></code></pre></td></tr></table></figure><h3 id="输入样例2">输入样例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>arrive A<br>arrive B<br>arrive C<br></code></pre></td></tr></table></figure><h3 id="输出样例2">输出样例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">OK<br>OK<br>OK<br></code></pre></td></tr></table></figure><h3 id="说明提示">说明/提示</h3><p><strong>【样例说明】</strong></p><p>样例 1 中发生了如下的事件：</p><ul><li>第一次 <code>start</code> 时队列并没有任何人，输出<code>Error</code>。</li><li><code>A</code> 随即加入队列。</li><li>第二次 <code>start</code> 时仅有 <code>A</code> 一个人，所以输出<code>A</code>。</li><li><code>B, C, D</code> 随即依次加入队列。</li><li>第三次 <code>start</code> 时 <code>B, C</code> 上场。</li><li><code>C</code> 试图离开，但是他在游玩。所以输出<code>Error</code>。</li><li><code>D</code> 成功离开。</li><li>第四次 <code>start</code> 时 <code>A, B</code> 上场。</li><li><code>A</code> 试图加入队列，但是他已经在队列中。输出<code>Error</code>。</li><li><code>D</code> 重新加入队列。</li><li><code>E</code> 试图离开，但是他根本不在排队，输出<code>Error</code>。</li><li>第五次 <code>start</code> 时 <code>C, D</code> 上场。</li></ul><p>样例 2 中，<code>A, B, C</code> 依次入队，操作合法，输出三个<code>OK</code>。</p><h3 id="题解-2">题解：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> string def = <span class="hljs-string">&quot;$$$$$$$&quot;</span>;<br><br>deque&lt;string &gt; q; <span class="hljs-comment">// 使用双端队列的原因是，相比queue, 可以使用erase函数，不用每次遍历整个队列</span><br>map&lt;string , <span class="hljs-type">bool</span>&gt; mp; <span class="hljs-comment">// 1 - 在排队，且在game； 0 - 在排队，但不在game； mp.count(x) = 0 - 不在排队 </span><br>string g[<span class="hljs-number">3</span>]; <span class="hljs-comment">// g[1], g[2] - 正在排队的2人；</span><br><span class="hljs-type">int</span> t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Erase_queue</span><span class="hljs-params">(deque&lt;string &gt; &amp; q, string re)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = q.<span class="hljs-built_in">begin</span>() ; it != q.<span class="hljs-built_in">end</span>() ; ++it)&#123;<br><span class="hljs-keyword">if</span>(*it == re)&#123;<br>q.<span class="hljs-built_in">erase</span>(it);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>string op; cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;start&quot;</span>)&#123;<br><span class="hljs-keyword">if</span>(g[<span class="hljs-number">1</span>] != def)&#123;<br>q.<span class="hljs-built_in">push_back</span>(g[<span class="hljs-number">1</span>]); mp[g[<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(g[<span class="hljs-number">2</span>] != def)&#123;<br>q.<span class="hljs-built_in">push_back</span>(g[<span class="hljs-number">2</span>]); mp[g[<span class="hljs-number">2</span>]] = <span class="hljs-number">0</span>;<br>&#125;<br>        <span class="hljs-comment">// 这里要先把在游戏2人加入队尾，再判断队列长度，否则会出错。</span><br><span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Error&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-keyword">return</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>g[<span class="hljs-number">1</span>] = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop_front</span>();<br>g[<span class="hljs-number">2</span>] = def;<br>mp[g[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>cout&lt;&lt;g[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>g[<span class="hljs-number">1</span>] = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop_front</span>();<br>g[<span class="hljs-number">2</span>] = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop_front</span>();<br>mp[g[<span class="hljs-number">1</span>]] = mp[g[<span class="hljs-number">2</span>]] = <span class="hljs-number">1</span>;<br>cout&lt;&lt;g[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;g[<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;arrive&quot;</span>)&#123;<br>string name;cin&gt;&gt;name;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(name))&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Error&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-keyword">return</span>;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;OK&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>mp[name] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push_back</span>(name);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;leave&quot;</span>)&#123;<br>string name;cin&gt;&gt;name;<br><span class="hljs-keyword">if</span>(!mp.<span class="hljs-built_in">count</span>(name))&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Error&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(name) &amp;&amp; mp[name] == <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Error&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-keyword">return</span>;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;OK&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>mp.<span class="hljs-built_in">erase</span>(name);<br><span class="hljs-built_in">Erase_queue</span>(q, name);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br>g[<span class="hljs-number">1</span>] = g[<span class="hljs-number">2</span>] = def;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="m2-国家管理">M2 国家管理</h2><p>Alice所在的国家中的城市通过道路连接起来，形成一颗<strong>树</strong>（全连通但无环），并且每个城市分为<strong>红派</strong>或者<strong>蓝派</strong>。</p><p>相邻的同派城市可以形成一个城市群，一个同派的城市群距离首都越远，并且城市群内的城市越多，对国家的威胁越大。</p><p>我们将一个城市群的威胁值表示为<strong>一个城市群内距离首都距离最近的城市相对于首都的距离</strong> 加上<strong>城市群内城市的数量</strong> 。</p><p>我们给城市编号 1 到 <em>n</em>，并假设首都的编号为 1 。</p><p>道路的长度均为 1 。</p><p>总统委托 Alice计算最大威胁值的城市群的威胁值为多少，你能写一个程序来帮帮她吗？</p><h3 id="输入格式-3">输入格式：</h3><p>第一行给出一个整数 <em>n</em> (1≤<em>n</em>≤1<em>e</em>5)，代表城市的总数。</p><p>第 2 到 <em>n</em> 行，每行给出两个整数 <em>u</em> 和 <em>v</em>，代表编号为 <em>u</em> 的城市与编号为 <em>v</em>的城市有道路相连（保证所给的图能形成一颗树）。</p><p>第 <em>n</em>+1 行，给出 <em>n</em> 个小于等于 1 的非负整数 *c**i*，如果 *c**i<em>=1 代表编号为 </em>i* 的城市为红派， *c**i<em>=0代表编号为 </em>i* 的城市为蓝派。</p><h3 id="输出格式-3">输出格式：</h3><p>输出一个整数，代表最大威胁值的城市群的威胁值为多少。</p><h3 id="输入样例-2">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">6<br>1 2<br>1 3<br>2 4<br>2 5<br>3 6<br>0 1 1 0 1 0<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">3<br></code></pre></td></tr></table></figure><figure><img src="/competition/GPLT/2025-school/e20f49db-3b50-471b-8104-c81b535ab8c9.png" alt="graph.png"><figcaption aria-hidden="true">graph.png</figcaption></figure><ul><li>分为五个城市群，<code>&#123;1&#125;，&#123;2,5&#125;，&#123;3&#125;，&#123;4&#125;，&#123;6&#125;</code></li><li>威胁值分别为，1，3，2，3，3</li><li>最大值为 3 因此输出 3</li></ul><h3 id="题解-3">题解：</h3><p>以下两种写法时间上没有差异：</p><p>1）两次dfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n;<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><span class="hljs-type">bool</span> visited[maxn];<br><span class="hljs-type">int</span> depth[maxn],color[maxn];<br><span class="hljs-type">int</span> min_, sum, ans;<br><br><span class="hljs-comment">// 求出每个节点深度</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_depth</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it != <span class="hljs-number">1</span> &amp;&amp; depth[it] == <span class="hljs-number">0</span>)&#123;<br>depth[it] = depth[x] + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">get_depth</span>(it);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 计算相邻同色节点的数量和最小深度</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>min_ = <span class="hljs-built_in">min</span>(min_, depth[x]);<br>sum++;<br>visited[x] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(!visited[it] &amp;&amp; color[x] == color[it])&#123;<br><span class="hljs-built_in">dfs</span>(it);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> u, v; cin&gt;&gt;u&gt;&gt;v;<br>e[u].<span class="hljs-built_in">push_back</span>(v);<br>e[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;color[i];<br>&#125;<br><span class="hljs-built_in">get_depth</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[i])&#123;<br>min_ = INT_MAX;<br>sum = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">dfs</span>(i);<br>ans = <span class="hljs-built_in">max</span>(sum + min_, ans);<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）单次dfs（更简洁）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> color[maxn],num[maxn];<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f, <span class="hljs-type">int</span> d)</span></span>&#123;<br>num[x] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it != f)&#123;<br><span class="hljs-built_in">dfs</span>(it, x, d<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">if</span>(color[it] == color[x]) num[x] += num[it];<br>&#125;<br>&#125;<br>ans = <span class="hljs-built_in">max</span>(ans, num[x] + d);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> u, v; cin&gt;&gt;u&gt;&gt;v;<br>e[u].<span class="hljs-built_in">push_back</span>(v);<br>e[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;color[i];<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="m3-灯">M3 灯</h2><p>有 <em>n</em>盏灯排成一列，其中有些灯开着，有些灯关着。Alice希望灯是错落有致的，他定义一列灯的状态的不优美度为这些灯中最长的连续的开着或关着的灯的个数。小可可最多可以按开关<em>k</em>次，每次操作可以使该盏灯的状态取反：原来开着的就关着，反之开着。现在给出这些灯的状态，求操作后最小的不优美度。</p><h3 id="输入格式-4">输入格式：</h3><p>第一行两个整数 <em>n</em>,<em>k</em>(1≤<em>k</em>≤<em>n</em>≤2<em>e</em>5)，代表灯的总数为 <em>n</em>，最多可以按 <em>k</em> 次开关</p><p>第二行是一个长度为 <em>n</em>的字符串，其中有两种字符：<code>N</code> 和 <code>F</code>。其中<code>N</code> 表示该灯开着，<code>F</code> 表示该灯关着。</p><h3 id="输出格式-4">输出格式：</h3><p>输出一个整数，代表操作后最小的不优美度。</p><h3 id="输入样例-3">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">8 1<br>NNNFFNNN<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">3<br></code></pre></td></tr></table></figure><h3 id="题解-4">题解：</h3><p><a href="https://www.luogu.com.cn/problem/P3718">P3718AHOI2017初中组] alter - 洛谷</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,ans;<br>string s;<br><br><span class="hljs-comment">// A.i 号灯修改后和 (i+1) 号灯一样，那么应该修改 (i−1) 号灯。</span><br><span class="hljs-comment">// B.i 号灯修改后和 (i+1) 号灯不一样，那么就修改 i 号灯。</span><br><span class="hljs-comment">// 但是对于A，当x==1时， 修改i-1可能会导致前面连成2，需要特判</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>string t = s;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(t[i] != t[i<span class="hljs-number">-1</span>])&#123;<br>cnt = <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cnt++;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt &gt; x)&#123;<br><span class="hljs-keyword">if</span>(i<span class="hljs-number">+1</span> &lt;= n &amp;&amp; t[i<span class="hljs-number">+1</span>] == t[i]) t[i] = (t[i] == <span class="hljs-string">&#x27;N&#x27;</span> ? <span class="hljs-string">&#x27;F&#x27;</span>:<span class="hljs-string">&#x27;N&#x27;</span>);<br>sum++; cnt = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum &lt;= k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br>cin&gt;&gt;s;<br>s = <span class="hljs-string">&quot; &quot;</span> + s;<br><span class="hljs-comment">// 特判 x == 1 是否可行</span><br><span class="hljs-type">int</span> n1 = <span class="hljs-number">0</span>, n2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>s[i] == <span class="hljs-string">&#x27;N&#x27;</span> ? ++n1:++n2;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>s[i] == <span class="hljs-string">&#x27;F&#x27;</span> ? ++n1:++n2;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(n1 &lt;= k || n2 &lt;= k)&#123;<br>cout&lt;&lt;<span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> l = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> r = n;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>r = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>l = mid;<br>&#125;<br>&#125;<br>cout&lt;&lt;r;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="h1-科技树">H1 科技树</h2><p>如果我们想要解锁某种科技，必须解锁其前置科技，这种前置关系正好形成一棵树。</p><figure><img src="/competition/GPLT/2025-school/1_bb51ecbcd2-QQ图片20181018170337.png" alt="QQ图片20181018170337.png"><figcaption aria-hidden="true">QQ图片20181018170337.png</figcaption></figure><p>如果解锁科技 5 ，则必须解锁科技 1 和 2</p><p>解锁科技需要资源，同时会给一些科技点，Alice的资源有限，但她希望得到最多的科技点。</p><p>每项科技的编号为 <em>i</em> ，需要的资源为 *v**i* ，提供的科技点为*w**i* ，依赖的科技为 *p**i* 。科技的下标范围是 1...<em>N</em> 。</p><p>输出能获得的最多科技点。</p><h3 id="输入格式-5">输入格式：</h3><p>第一行有两个整数<em>N</em>，<em>V</em>，用空格隔开，分别表示科技个数和Alice初始拥有的资源。</p><p>接下来有 <em>N</em> 行数据，每行数据表示一个科技。 第 <em>i</em>行有三个整数<em>v<strong>i<em>,</em>w</strong>i</em>,<em>p<strong>i<em>，用空格隔开，分别表示解锁科技需要的资源、提供的科技点和依赖的科技编号。如果 </em>p</strong>i</em>=−1 ，表示根节点。<strong>数据保证所有科技构成一棵树。</strong></p><h3 id="输出格式-5">输出格式：</h3><p>输出一个整数，代表能获得的最多科技点。</p><h3 id="输入样例-4">输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">5 7<br>2 3 -1<br>2 2 1<br>3 5 1<br>4 7 2<br>3 6 2<br></code></pre></td></tr></table></figure><h3 id="输出样例-4">输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">11<br></code></pre></td></tr></table></figure><p>数据范围：</p><p>1≤<em>N</em>,<em>V</em>≤1001≤<em>v<strong>i<em>,</em>w</strong>i</em>≤100</p><p>父节点编号范围：</p><ul><li>内部结点：1≤*p**i<em>≤</em>N*;</li><li>根节点 *p**i*=−1;</li></ul><h3 id="题解-5">题解：</h3><p>（树上背包模板）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">1e3</span>;<br><br><span class="hljs-type">int</span> n,m,f,r;<br><span class="hljs-type">int</span> w[maxn],v[maxn];<br><span class="hljs-type">int</span> dp[maxn][maxm];<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-built_in">dfs</span>(it);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; j-k &gt;= w[x] ; k ++)&#123;<br>dp[x][j] = <span class="hljs-built_in">max</span>(dp[x][j], dp[x][j-k] + dp[it][k]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i]&gt;&gt;v[i]&gt;&gt;f;<br><span class="hljs-keyword">if</span>(f == <span class="hljs-number">-1</span>) r = i;<br><span class="hljs-keyword">else</span> e[f].<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = w[i]; j &lt;= m ; j ++)&#123;<br>dp[i][j] = v[i];<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(r);<br>cout&lt;&lt;dp[r][m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>校内模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPLT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛真题训练：2023年</title>
    <link href="/competition/GPLT/2023/"/>
    <url>/competition/GPLT/2023/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://pintia.cn/problem-sets/1891444689941872640/exam/problems/type/7">编程题- 题目列表 - 2023 天梯赛</a></p><table><thead><tr><th>题目</th><th>分值</th><th>知识点</th></tr></thead><tbody><tr><td>什么是机器学习</td><td>5</td><td>Hello World</td></tr><tr><td>程序员买包子</td><td>10</td><td>分支</td></tr><tr><td>进化论</td><td>10</td><td>分支</td></tr><tr><td>猜帽子游戏</td><td>15</td><td>分支</td></tr><tr><td>剪切粘贴</td><td>15</td><td>字符串处理</td></tr><tr><td>分寝室</td><td>20</td><td>简单模拟</td></tr><tr><td>谁管谁叫爹</td><td>20</td><td>简单模拟</td></tr><tr><td>堆宝塔</td><td>25</td><td>数据结构</td></tr><tr><td>天梯赛的赛场安排</td><td>25</td><td>简单模拟</td></tr><tr><td>锦标赛</td><td>25</td><td>二叉树</td></tr><tr><td>寻宝图</td><td>25</td><td>DFS</td></tr></tbody></table><h1 id="最好的文档">1-5 最好的文档</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Good code is its own best documentation.&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="什么是机器学习">2-5 什么是机器学习</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a, b;<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;a&gt;&gt;b;<br>ans = a + b;<br>cout&lt;&lt;ans<span class="hljs-number">-16</span>&lt;&lt;endl;<br>cout&lt;&lt;ans<span class="hljs-number">-3</span>&lt;&lt;endl;<br>cout&lt;&lt;ans<span class="hljs-number">-1</span>&lt;&lt;endl;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="程序员买包子">3-10 程序员买包子</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string x;<br><span class="hljs-type">int</span> n,m,k;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;x&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">if</span>(k == n)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;mei you mai &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; de&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == m)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;kan dao le mai &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; de&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;wang le zhao mai &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; de&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="进化论">4-10 进化论</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-keyword">if</span>(a*b == c)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Lv Yan\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a + b == c)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Tu Dou\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;zhe du shi sha ya!\n&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="猜帽子游戏">5-15 猜帽子游戏</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> n,t;<br><span class="hljs-type">int</span> a[maxn],b[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">bool</span> f = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;b[i];<br><span class="hljs-keyword">if</span>(b[i] != <span class="hljs-number">0</span>) f = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">if</span>(b[i] != <span class="hljs-number">0</span>) w += (b[i] != a[i]);<br>&#125;<br><span class="hljs-keyword">if</span>(f &amp;&amp; w == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Da Jiang!!!\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Ai Ya\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="剪切粘贴">6-15 剪切粘贴</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s;<br><span class="hljs-type">int</span> t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a, b; string l, r;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;l&gt;&gt;r;<br>string cut = s.<span class="hljs-built_in">substr</span>(a<span class="hljs-number">-1</span>, b-a<span class="hljs-number">+1</span>);<br>s.<span class="hljs-built_in">erase</span>(a<span class="hljs-number">-1</span>, b-a<span class="hljs-number">+1</span>);<br><span class="hljs-type">int</span> p = s.<span class="hljs-built_in">find</span>(l+r);<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">-1</span>)&#123;<br>s += cut;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// s.insert(p + l.size(), cut);</span><br>s = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, p + l.<span class="hljs-built_in">size</span>()) + cut + s.<span class="hljs-built_in">substr</span>(p+l.<span class="hljs-built_in">size</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br>cout&lt;&lt;s;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分寝室">7-20 分寝室</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n0,n1,n;<br><span class="hljs-type">int</span> mid,ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n0&gt;&gt;n1&gt;&gt;n;<br>mid = INT_MAX;<br>ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> a = i, b = n-i;<br><span class="hljs-keyword">if</span>(n0 % a == <span class="hljs-number">0</span> &amp;&amp; n1 % b == <span class="hljs-number">0</span> &amp;&amp; n0 != a &amp;&amp; n1 != b)&#123;<br><span class="hljs-type">int</span> new_mid = <span class="hljs-built_in">abs</span>(n0/a - n1/b);<br><span class="hljs-keyword">if</span>(new_mid &lt; mid)&#123;<br>mid = new_mid;<br>ans = i;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ans != <span class="hljs-number">-1</span>) cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;n-ans;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No Solution&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="谁管谁叫爹">8-20 谁管谁叫爹</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>res += x%<span class="hljs-number">10</span>;<br>x /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> na,nb;cin&gt;&gt;na&gt;&gt;nb;<br><span class="hljs-type">int</span> sa = <span class="hljs-built_in">getNum</span>(na);<br><span class="hljs-type">int</span> sb = <span class="hljs-built_in">getNum</span>(nb);<br><span class="hljs-keyword">if</span>(na % sb == <span class="hljs-number">0</span> &amp;&amp; nb % sa != <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;A&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(na % sb != <span class="hljs-number">0</span> &amp;&amp; nb % sa == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;B&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(na &gt; nb) cout&lt;&lt;<span class="hljs-string">&quot;A&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;B&quot;</span>;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆宝塔">9-25 堆宝塔</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span> &gt; a,b;<br>vector&lt;vector&lt;<span class="hljs-type">int</span> &gt; &gt; ans;<br><br><span class="hljs-type">int</span> t;<br><span class="hljs-type">int</span> h;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> x; cin&gt;&gt;x;<br><span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">empty</span>() || x &lt; a.<span class="hljs-built_in">back</span>())&#123;<br>a.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b.<span class="hljs-built_in">empty</span>() || x &gt; b.<span class="hljs-built_in">back</span>())&#123;<br>b.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>ans.<span class="hljs-built_in">push_back</span>(a);<br>a.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">while</span>(b.<span class="hljs-built_in">size</span>() &amp;&amp; b.<span class="hljs-built_in">back</span>() &gt; x)&#123;<br>a.<span class="hljs-built_in">push_back</span>(b.<span class="hljs-built_in">back</span>());<br>b.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>a.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">End</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>())&#123;<br>ans.<span class="hljs-built_in">push_back</span>(a);<br>a.<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(b.<span class="hljs-built_in">size</span>())&#123;<br>a.<span class="hljs-built_in">push_back</span>(b.<span class="hljs-built_in">back</span>());<br>b.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-keyword">if</span>(!a.<span class="hljs-built_in">empty</span>())&#123;<br>ans.<span class="hljs-built_in">push_back</span>(a);<br>a.<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : ans)&#123;<br>h = <span class="hljs-built_in">max</span>(h, (<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-built_in">End</span>();<br>cout&lt;&lt;ans.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;h&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="天梯赛的赛场安排">10-25 天梯赛的赛场安排</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, string&gt; &gt; pq;<br>map&lt;string, <span class="hljs-type">int</span>&gt; mp;<br>vector&lt;string &gt; out;<br><span class="hljs-type">int</span> n,c;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>string s; <span class="hljs-type">int</span> m;<br>cin&gt;&gt;s&gt;&gt;m;<br>pq.<span class="hljs-built_in">push</span>(&#123;m, s&#125;);<br>out.<span class="hljs-built_in">push_back</span>(s);<br>&#125;<br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> m = pq.<span class="hljs-built_in">top</span>().first;<br>string s = pq.<span class="hljs-built_in">top</span>().second;<br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(m &gt;= c)&#123;<br><span class="hljs-keyword">if</span>(m-c != <span class="hljs-number">0</span>) pq.<span class="hljs-built_in">push</span>(&#123;m-c, s&#125;);<br>v.<span class="hljs-built_in">push_back</span>(c);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">bool</span> f = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(m + v[i] &lt;= c)&#123;<br>v[i] += m;<br>f = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!f) v.<span class="hljs-built_in">push_back</span>(m);<br>&#125;<br>mp[s]++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s : out)&#123;<br>cout&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;mp[s]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>cout&lt;&lt;v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="锦标赛">11-25 锦标赛</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>);<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">game</span>&#123;<br><span class="hljs-type">int</span> win, lose;<br>&#125;g[maxn];<br><span class="hljs-type">int</span> k;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &gt;= (<span class="hljs-number">1</span>&lt;&lt;k)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(g[x].win &lt; g[x].lose) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>g[(x&lt;&lt;<span class="hljs-number">1</span>)].win = g[x].win;<br>g[(x&lt;&lt;<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>].win = g[x].lose;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(x&lt;&lt;<span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">judge</span>((x&lt;&lt;<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>g[(x&lt;&lt;<span class="hljs-number">1</span>)].win = g[x].lose;<br>g[(x&lt;&lt;<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>].win = g[x].win;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(x&lt;&lt;<span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">judge</span>((x&lt;&lt;<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>); j &lt; (<span class="hljs-number">1</span>&lt;&lt;i) ; j ++)&#123;<br>cin&gt;&gt;g[j].lose;<br>&#125;<br>&#125;<br>cin&gt;&gt;g[<span class="hljs-number">1</span>].win;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judge</span>(<span class="hljs-number">1</span>)) cout&lt;&lt;<span class="hljs-string">&quot;No Solution&quot;</span>;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = (<span class="hljs-number">1</span>&lt;&lt;(k<span class="hljs-number">-1</span>)) ; i &lt; (<span class="hljs-number">1</span>&lt;&lt;k) ; i ++)&#123;<br>cout&lt;&lt;g[i].win&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;g[i].lose&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="寻宝图">12-25 寻宝图</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>; <br><br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">char</span> &gt; v[maxm];<br>vector&lt;<span class="hljs-type">bool</span>&gt; vis[maxm];<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> cnt, ans;<br><span class="hljs-type">bool</span> ans_once;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>vis[x][y] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(v[x][y] &gt;= <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; v[x][y] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) ans_once = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">4</span> ; i ++)&#123;<br><span class="hljs-type">int</span> nx = x + dirx[i];<br><span class="hljs-type">int</span> ny = y + diry[i];<br><span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= m &amp;&amp; !vis[nx][ny] &amp;&amp; v[nx][ny] != <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br><span class="hljs-built_in">dfs</span>(nx, ny);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>v[i].<span class="hljs-built_in">resize</span>(m<span class="hljs-number">+1</span>);<br>vis[i].<span class="hljs-built_in">resize</span>(m<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;v[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!vis[i][j] &amp;&amp; v[i][j] != <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>ans_once = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">dfs</span>(i, j);<br>cnt++;<br><span class="hljs-keyword">if</span>(ans_once) ans++;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>真题模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPLT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛真题训练：2024年</title>
    <link href="/competition/GPLT/2024/"/>
    <url>/competition/GPLT/2024/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://pintia.cn/problem-sets/1889319954878181376/exam/problems/type/7">编程题- 题目列表 - 2024 天梯赛</a></p><h1 id="编程解决一切">1-5 编程解决一切</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Problem? The Solution: Programming.&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="再进去几个人">2-5 再进去几个人</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-type">int</span> a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br>cout&lt;&lt;b-a;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="帮助色盲">3-10 帮助色盲</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 输入在一行中给出两个数字 A 和 B，其间以空格分隔。</span><br><span class="hljs-comment">// 其中 A 是当前交通灯的颜色，取值为 0 表示红灯、1 表示绿灯、2 表示黄灯；</span><br><span class="hljs-comment">// B 是前方行人的状态，取值为 0 表示前方两米内没有同向行走的人、1 表示有。</span><br><br><span class="hljs-comment">// 根据输入的状态在第一行中输出提示音：</span><br><span class="hljs-comment">// dudu 表示前方为绿灯，可以继续前进；</span><br><span class="hljs-comment">// biii 表示前方为红灯，应该止步；</span><br><span class="hljs-comment">// - 表示不做提示。在第二行输出患者应该执行的动作：</span><br><span class="hljs-comment">// move 表示继续前进、stop 表示止步。</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-type">int</span> l,p;<br>cin&gt;&gt;l&gt;&gt;p;<br><span class="hljs-keyword">if</span>(l == <span class="hljs-number">2</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;-\n&quot;</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;stop&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;-\n&quot;</span>;<br><span class="hljs-keyword">if</span>(l == <span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;move&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;stop&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(l == <span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot;dudu\nmove&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;biii\nstop&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四项全能">4-10 四项全能</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m,sum;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> x;cin&gt;&gt;x;<br>sum += x;<br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, sum - (m<span class="hljs-number">-1</span>)*n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="别再来这么多猫娘了">5-15 别再来这么多猫娘了！</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,cnt;<br>vector&lt;string&gt; v;<br>string str;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(string s)</span></span>&#123;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; str.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i + len - <span class="hljs-number">1</span> &lt; str.<span class="hljs-built_in">length</span>() &amp;&amp; str.<span class="hljs-built_in">substr</span>(i, len) == s)&#123;<br>res += <span class="hljs-string">&quot;_&quot;</span>;<br>i = i+len<span class="hljs-number">-1</span>;<br>cnt++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>res += str[i];<br>&#125;<br>&#125;<br>str = res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>string s;cin&gt;&gt;s;<br>v.<span class="hljs-built_in">push_back</span>(s);<br>&#125;<br>cin&gt;&gt;k;<br><span class="hljs-built_in">getchar</span>();<br><span class="hljs-built_in">getline</span>(cin, str);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br><span class="hljs-built_in">solve</span>(it);<br>&#125;<br><span class="hljs-keyword">if</span>(cnt &gt;= k)&#123;<br>cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;He Xie Ni Quan Jia!&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : str)&#123;<br><span class="hljs-keyword">if</span>(it == <span class="hljs-string">&#x27;_&#x27;</span>) cout&lt;&lt;<span class="hljs-string">&quot;&lt;censored&gt;&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;it;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="兰州牛肉面">6-15 兰州牛肉面</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> n,cnt[maxn];<br><span class="hljs-type">double</span> sum,p[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;p[i];<br>&#125;<br><span class="hljs-type">int</span> t,num;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;t&gt;&gt;num, t != <span class="hljs-number">0</span>)&#123;<br>sum += p[t]*num;<br>cnt[t] += num;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;cnt[i]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>)&lt;&lt;sum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="整数的持续性">7-20 整数的持续性</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a, b;<br><span class="hljs-type">int</span> max_;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">10</span>)&#123;<br><span class="hljs-type">int</span> nex = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> temp = x;<br><span class="hljs-keyword">while</span>(temp &gt; <span class="hljs-number">0</span>)&#123;<br>nex *= temp%<span class="hljs-number">10</span>;<br>temp /= <span class="hljs-number">10</span>;<br>&#125;<br>x = nex;<br>cnt++;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;a&gt;&gt;b;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a ; i &lt;= b ; i ++)&#123;<br><span class="hljs-type">int</span> cnt_i = <span class="hljs-built_in">solve</span>(i);<br><span class="hljs-keyword">if</span>(cnt_i &gt; max_)&#123;<br>max_ = cnt_i;<br>ans.<span class="hljs-built_in">clear</span>();<br>ans.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt_i == max_)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>&#125;<br>cout&lt;&lt;max_&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; ans.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>cout&lt;&lt;ans[i]&lt;&lt;(i == ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;\n&quot;</span>:<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="九宫格">8-20 九宫格</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t, a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">9</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!(a[i][j] &gt;= <span class="hljs-number">1</span> &amp;&amp; a[i][j] &lt;= <span class="hljs-number">9</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">9</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(vis[a[i][j]]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>vis[a[i][j]] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">9</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(vis[a[j][i]]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>vis[a[j][i]] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">7</span> ; i += <span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">7</span> ; j += <span class="hljs-number">3</span>)&#123;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = i ; x &lt;= i + <span class="hljs-number">2</span> ; x ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = j ; y &lt;= j + <span class="hljs-number">2</span>; y ++)&#123;<br><span class="hljs-keyword">if</span>(vis[a[x][y]]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>vis[a[x][y]] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">9</span> ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>()) cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="鱼和熊掌">9-25 鱼和熊掌</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m,q;<br>vector&lt;<span class="hljs-type">int</span> &gt; v[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> k;cin&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= k ; j ++)&#123;<br><span class="hljs-type">int</span> x;cin&gt;&gt;x;<br>v[x].<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>&#125;<br>cin&gt;&gt;q;<br><span class="hljs-keyword">while</span>(q--)&#123;<br><span class="hljs-type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v[a])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> jt : v[b])&#123;<br><span class="hljs-keyword">if</span>(it == jt)&#123;<br>res++;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="懂蛇语">10-25 懂蛇语</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;string, vector&lt;string&gt; &gt; mp;<br><span class="hljs-type">int</span> n,q;<br><br><span class="hljs-function">string <span class="hljs-title">get_head</span><span class="hljs-params">(string s)</span></span>&#123;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br>string t = <span class="hljs-string">&quot; &quot;</span> + s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; t.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(t[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br><span class="hljs-keyword">while</span>(i &lt; t.<span class="hljs-built_in">length</span>() &amp;&amp; t[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>res += t[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>string s;<br><span class="hljs-built_in">getline</span>(cin, s);<br>string h = <span class="hljs-built_in">get_head</span>(s);<br>mp[h].<span class="hljs-built_in">push_back</span>(s);<br>&#125;<br>cin&gt;&gt;q;<br><span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(q--)&#123;<br>string s;<br><span class="hljs-built_in">getline</span>(cin, s);<br>string h = <span class="hljs-built_in">get_head</span>(s);<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(h) != <span class="hljs-number">0</span>)&#123;<br>vector&lt;string&gt; v = mp[h];<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>cout&lt;&lt;v[i]&lt;&lt;(i == v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;\n&quot;</span>: <span class="hljs-string">&quot;|&quot;</span>);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="满树的遍历">11-25 满树的遍历</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><span class="hljs-type">int</span> n,r,d;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= n &amp;&amp; e[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) i++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(e[j].<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span> &amp;&amp; e[j].<span class="hljs-built_in">size</span>() != e[i].<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x != r) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;x;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-built_in">dfs</span>(it);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> f;cin&gt;&gt;f;<br><span class="hljs-keyword">if</span>(f == <span class="hljs-number">0</span>) r = i;<br><span class="hljs-keyword">else</span> e[f].<span class="hljs-built_in">push_back</span>(i);<br>d = <span class="hljs-built_in">max</span>((<span class="hljs-type">int</span>)e[f].<span class="hljs-built_in">size</span>(), d);<br>&#125;<br>cout&lt;&lt;d&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;(<span class="hljs-built_in">judge</span>() ? <span class="hljs-string">&quot;yes\n&quot;</span>:<span class="hljs-string">&quot;no\n&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-built_in">sort</span>(e[i].<span class="hljs-built_in">begin</span>(), e[i].<span class="hljs-built_in">end</span>());<br>&#125;<br><span class="hljs-built_in">dfs</span>(r);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="吉利矩阵">12-25 吉利矩阵</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> l,n,ans;<br><span class="hljs-type">int</span> a[maxn][maxn], row[maxn], col[maxn];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(row[i] != l || col[i] != l) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(col[i] &gt; l || row[i] &gt; l) <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(x == n &amp;&amp; y == n)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l; i ++)&#123;<br>a[x][y] = i;<br>row[x] += i; col[y] += i;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>()) ans++;<br>row[x] -= i; col[y] -= i;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l; i ++)&#123;<br>a[x][y] = i;<br><span class="hljs-keyword">if</span>(y == n)&#123;<br>row[x] += i; col[y] += i;<br><span class="hljs-keyword">if</span>(row[x] == l) <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>row[x] -= i; col[y] -= i;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>row[x] += i; col[y] += i;<br><span class="hljs-keyword">if</span>(!(x == n &amp;&amp; col[y] != l)) <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>);<br>row[x] -= i; col[y] -= i;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;l&gt;&gt;n;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>真题模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPLT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛分类练习4：图</title>
    <link href="/competition/GPLT/GPLT-Graph/"/>
    <url>/competition/GPLT/GPLT-Graph/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://pintia.cn/problem-sets/1770719709958443008/exam/problems/type/7?problemSetProblemId=1770719733333303296&amp;page=0">L2-3深入虎穴 - 团体程序设计天梯赛练习4：图</a>：BFS求树的深度</p><p><a href="https://pintia.cn/problem-sets/1770719709958443008/exam/problems/type/7?problemSetProblemId=1770719733333303299&amp;page=0">L2-4网红点打卡攻略 - 团体程序设计天梯赛练习4：图</a>：哈密顿回路</p><p><a href="https://pintia.cn/problem-sets/1770719709958443008/exam/problems/type/7?problemSetProblemId=1770719733333303301&amp;page=0">7-6哲哲打游戏 - 团体程序设计天梯赛练习4：图</a>：模拟</p><p><a href="https://pintia.cn/problem-sets/1770719709958443008/exam/problems/type/7?problemSetProblemId=1770719733333303303&amp;page=0">7-8龙龙送外卖 - 团体程序设计天梯赛练习4：图</a>：树</p><p><a href="https://pintia.cn/problem-sets/1770719709958443008/exam/problems/type/7?problemSetProblemId=1770719733333303304&amp;page=0">7-9大众情人 - 团体程序设计天梯赛练习4：图</a>：弗洛伊德求最短路</p><h1 id="l2-3-深入虎穴">L2-3 深入虎穴</h1><p>使用BFS求出树的最大深度，同时记录一下该深度下的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span>;<br><br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><span class="hljs-type">bool</span> vis[maxn];<br><span class="hljs-type">int</span> n,ans,max_dep;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span> &gt; &gt; q;<br>q.<span class="hljs-built_in">push</span>(&#123;x, <span class="hljs-number">1</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>().first;<br><span class="hljs-type">int</span> d = q.<span class="hljs-built_in">front</span>().second;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(d &gt; max_dep)&#123;<br>ans = f;<br>d = max_dep;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[f])&#123;<br>q.<span class="hljs-built_in">push</span>(&#123;it, d<span class="hljs-number">+1</span>&#125;);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> k;cin&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= k ; j ++)&#123;<br><span class="hljs-type">int</span> s;cin&gt;&gt;s;<br>e[i].<span class="hljs-built_in">push_back</span>(s);<br>vis[s] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> r = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!vis[i])&#123;<br>r = i; <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">bfs</span>(r);<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l2-4-网红点打卡攻略">L2-4 网红点打卡攻略</h1><p>给一个N节点，M条边的无向图。</p><p>对K条通路进行判断，求出其中最短的哈密顿回路。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> e[maxn][maxn];<br><span class="hljs-type">int</span> min_,cnt,ans;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; v)</span></span>&#123;<br><span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>() != n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">bool</span> vis[maxn];<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>vis[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br><span class="hljs-keyword">if</span>(vis[it] || e[last][it] == inf) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>vis[it] = <span class="hljs-literal">true</span>;<br>last = it;<br>&#125;<br><span class="hljs-keyword">if</span>(e[v.<span class="hljs-built_in">back</span>()][<span class="hljs-number">0</span>] == inf) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_sum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; v)</span></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br>res += e[last][it];<br>last = it;<br>&#125;<br>res += e[v.<span class="hljs-built_in">back</span>()][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> res;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(e,inf,<span class="hljs-built_in">sizeof</span>(e));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b,w; cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>e[a][b] = e[b][a] = w;<br>&#125;<br>min_ = inf;<br>cin&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br><span class="hljs-type">int</span> t;cin&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= t ; j ++)&#123;<br><span class="hljs-type">int</span> x;cin&gt;&gt;x;<br>v.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(v))&#123;<br>cnt++;<br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">get_sum</span>(v);<br><span class="hljs-keyword">if</span>(sum &lt; min_)&#123;<br>min_ = sum;<br>ans = i;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;cnt&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;min_&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="哲哲打游戏">7-6 哲哲打游戏</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span>;<br><br><span class="hljs-type">int</span> n,m;<br>vector&lt;<span class="hljs-type">int</span>&gt; nex[maxn];<br><span class="hljs-type">int</span> back[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> k;cin&gt;&gt;k;<br>nex[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= k ; j ++)&#123;<br><span class="hljs-type">int</span> x; cin&gt;&gt;x;<br>nex[i].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> now = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> op;<br>cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> to;cin&gt;&gt;to;<br>now = nex[now][to];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">int</span> f;cin&gt;&gt;f;<br>back[f] = now;<br>cout&lt;&lt;now&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> f;cin&gt;&gt;f;<br>now = back[f];<br>&#125;<br>&#125;<br>cout&lt;&lt;now;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="龙龙送外卖">7-8 龙龙送外卖</h1><p>首先，使用dfs求出每个点的在树上的深度。</p><p>然后，原问题的最优解可转换为：累加所有涉及的边长度的两倍，然后减去一条最长的从根节点到需要到达的子节点的距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span>;<br><br><span class="hljs-type">int</span> n,r,m,ans;<br><span class="hljs-type">int</span> fa[maxn],dep[maxn],max_dist;<br><span class="hljs-type">bool</span> vis[maxn];<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span></span>&#123;<br>dep[x] = d;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-built_in">dfs</span>(it, d<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> f;cin&gt;&gt;f;<br><span class="hljs-keyword">if</span>(f == <span class="hljs-number">-1</span>) r = i;<br><span class="hljs-keyword">else</span>&#123;<br>fa[i] = f;<br>e[f].<span class="hljs-built_in">push_back</span>(i);<br>&#125; <br>&#125;<br><span class="hljs-built_in">dfs</span>(r, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> x;cin&gt;&gt;x;<br>max_dist = <span class="hljs-built_in">max</span>(dep[x],max_dist);<br><span class="hljs-keyword">while</span>(!vis[x] &amp;&amp; x != r)&#123;<br>ans += <span class="hljs-number">2</span>;<br>vis[x] = <span class="hljs-literal">true</span>;<br>x = fa[x];<br>&#125;<br>cout&lt;&lt;ans - max_dist&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="大众情人">7-9 大众情人</h1><p>给一张有向带权图，求每个点之间的最短距离。</p><p>每个人的异性缘是离自己最远的异性（从异性走到自己）的倒数。</p><p>求出2个性别的大众情人，即最远异性离自己最近的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">505</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> g[maxn];<br><span class="hljs-type">int</span> e[maxn][maxn],min_1,min_2;<br>vector&lt;<span class="hljs-type">int</span> &gt; ans_1,ans_2;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; k &lt;= n ; k ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(e[i][k] == inf) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>e[i][j] = <span class="hljs-built_in">min</span>(e[i][j], e[i][k] + e[k][j]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(e,inf,<span class="hljs-built_in">sizeof</span>(e));<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">char</span> c;cin&gt;&gt;c;<br>g[i] = (c == <span class="hljs-string">&#x27;M&#x27;</span>);<br><span class="hljs-type">int</span> k;cin&gt;&gt;k;<br><span class="hljs-keyword">while</span>(k--)&#123;<br><span class="hljs-type">int</span> x,d; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d&quot;</span>, &amp;x, &amp;d);<br>e[i][x] = d;<br>&#125;<br>&#125;<br>min_1 = min_2 = inf;<br><span class="hljs-built_in">floyd</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> d = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(g[i] != g[j])&#123;<br>d = <span class="hljs-built_in">max</span>(e[j][i], d);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!g[i] &amp;&amp; d &lt; min_1)&#123;<br>min_1 = d;<br>ans_<span class="hljs-number">1.</span><span class="hljs-built_in">clear</span>();<br>ans_<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!g[i] &amp;&amp; d == min_1)&#123;<br>ans_<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-keyword">if</span>(g[i] &amp;&amp; d &lt; min_2)&#123;<br>min_2 = d;<br>ans_<span class="hljs-number">2.</span><span class="hljs-built_in">clear</span>();<br>ans_<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[i] &amp;&amp; d == min_2)&#123;<br>ans_<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!ans_<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>()) cout&lt;&lt;ans_<span class="hljs-number">1.f</span>ront();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; ans_<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans_1[i];<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">if</span>(!ans_<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>()) cout&lt;&lt;ans_<span class="hljs-number">2.f</span>ront();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; ans_<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans_2[i];<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>分类练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>GPLT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛分类练习3：树</title>
    <link href="/competition/GPLT/GPLT-Tree/"/>
    <url>/competition/GPLT/GPLT-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://pintia.cn/problem-sets/1770719522162700288/exam/problems/type/7?problemSetProblemId=1770719547156533248&amp;page=0">L2-2小字辈 - 团体程序设计天梯赛练习3：树</a>：BFS求树的最大深度</p><p><a href="https://pintia.cn/problem-sets/1770719522162700288/exam/problems/type/7?problemSetProblemId=1770719547156533249&amp;page=0">L2-4秀恩爱分得快 - 团体程序设计天梯赛练习3：树</a>：模拟</p><p><a href="https://pintia.cn/problem-sets/1770719522162700288/exam/problems/type/7?problemSetProblemId=1770719547156533251&amp;page=0">L2-3完全二叉树的层序遍历 - 团体程序设计天梯赛练习3：树</a>：完全二叉树</p><p><a href="https://pintia.cn/problem-sets/1770719522162700288/exam/problems/type/7?problemSetProblemId=1770719547156533252&amp;page=0">7-5病毒溯源 - 团体程序设计天梯赛练习3：树</a>：DFS最小序列</p><h1 id="l2-2-小字辈">L2-2 小字辈</h1><p>有N个人，现在给定1-N个人各自的父亲。根的辈分为1，依次向下递增。</p><p>按递增顺序输出辈分最小的成员的编号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> idx,dep;<br>&#125;;<br><br><span class="hljs-type">int</span> n,root,max_;<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn],ans;<br>queue&lt;node&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> f;cin&gt;&gt;f;<br><span class="hljs-keyword">if</span>(f != <span class="hljs-number">-1</span>) e[f].<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">else</span> root = i;<br>&#125;<br>q.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">1</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> dep = q.<span class="hljs-built_in">front</span>().dep;<br><span class="hljs-type">int</span> idx = q.<span class="hljs-built_in">front</span>().idx;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(dep &gt; max_)&#123;<br>max_ = dep;<br>ans.<span class="hljs-built_in">clear</span>();<br>ans.<span class="hljs-built_in">push_back</span>(idx);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dep == max_)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(idx);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[idx])&#123;<br>q.<span class="hljs-built_in">push</span>(&#123;it, dep<span class="hljs-number">+1</span>&#125;);<br>&#125;<br>&#125;<br>cout&lt;&lt;max_&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">if</span>(!ans.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;ans[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; ans.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans[i];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l2-4-秀恩爱分得快">L2-4 秀恩爱分得快</h1><p>给定M张照片，每张照片上每对异性的亲密度为1/K。这里的K是照片上的人数。</p><p>给一对情侣，求这一对情侣是否是亲密度最高的。若不是，依次输出亲密度最高的异性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1050</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">double</span> val[maxn][maxn];<br><span class="hljs-type">bool</span> g[maxn];<br><span class="hljs-type">int</span> n,m;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; pic;<br>vector&lt;<span class="hljs-type">int</span> &gt; af,bf;<br>string s1,s2;<br><span class="hljs-type">int</span> a,b;<br><span class="hljs-type">double</span> max_a_f, max_b_f, max_a_b;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) s = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>);<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br>res = res*<span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> k;cin&gt;&gt;k;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br>string s; cin&gt;&gt;s;<br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">getInt</span>(s);<br>g[idx] = (s[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span>);<br>v.<span class="hljs-built_in">push_back</span>(idx);<br>&#125;<br>pic.<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;s1&gt;&gt;s2;<br>a = <span class="hljs-built_in">getInt</span>(s1);<br>b = <span class="hljs-built_in">getInt</span>(s2);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : pic)&#123;<br><span class="hljs-type">bool</span> ia = <span class="hljs-literal">false</span>;<br><span class="hljs-type">bool</span> ib = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br><span class="hljs-keyword">if</span>(it == a) ia = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(it == b) ib = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(ia)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br>val[a][it] += <span class="hljs-number">1.0</span>/v.<span class="hljs-built_in">size</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ib)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br>val[b][it] += <span class="hljs-number">1.0</span>/v.<span class="hljs-built_in">size</span>();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(g[i] != g[a])&#123;<br><span class="hljs-keyword">if</span>(val[a][i] &gt; max_a_f)&#123;<br>max_a_f = val[a][i];<br>af.<span class="hljs-built_in">clear</span>();<br>af.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val[a][i] == max_a_f)&#123;<br>af.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(g[i] != g[b])&#123;<br><span class="hljs-keyword">if</span>(val[b][i] &gt; max_b_f)&#123;<br>max_b_f = val[b][i];<br>bf.<span class="hljs-built_in">clear</span>();<br>bf.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val[b][i] == max_b_f)&#123;<br>bf.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">sort</span>(af.<span class="hljs-built_in">begin</span>(),af.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">sort</span>(bf.<span class="hljs-built_in">begin</span>(),bf.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">if</span>(val[a][b] == max_a_f &amp;&amp; val[a][b] == max_b_f)&#123;<br>cout&lt;&lt;s1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;s2;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : af)&#123;<br>cout&lt;&lt;s1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">if</span>(!g[it]) cout&lt;&lt;<span class="hljs-string">&#x27;-&#x27;</span>;<br>cout&lt;&lt;it&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : bf)&#123;<br>cout&lt;&lt;s2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">if</span>(!g[it]) cout&lt;&lt;<span class="hljs-string">&#x27;-&#x27;</span>;<br>cout&lt;&lt;it&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-built_in">print</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l2-3-完全二叉树的层序遍历">L2-3 完全二叉树的层序遍历</h1><p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p><p>tip：若使用数组存储，完全二叉树将完全填充于1-N的数组空间中，顺序输出后恰是层序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">50</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> tree[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &gt; n) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">create</span>(<span class="hljs-number">2</span>*x);<br><span class="hljs-built_in">create</span>(<span class="hljs-number">2</span>*x + <span class="hljs-number">1</span>);<br>cin&gt;&gt;tree[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-built_in">create</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;tree[i]&lt;&lt;(i != n ? <span class="hljs-string">&quot; &quot;</span>: <span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="病毒溯源">7-5 病毒溯源</h1><p>我们将所有病毒从 0 到 <em>N</em>−1 进行编号。</p><p>随后 <em>N</em> 行，每行按以下格式描述一种病毒的变异情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">k</span> 变异株<span class="hljs-number">1</span> …… 变异株k<br></code></pre></td></tr></table></figure><p>其中 <code>k</code> 是该病毒产生的变异毒株的种类数。</p><p>输出从源头开始最长变异链的长度。如果最长链不唯一，则输出最小序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> n,root,max_;<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn],v,ans;<br><span class="hljs-type">bool</span> ind[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(v.<span class="hljs-built_in">size</span>() &gt; max_)&#123;<br>max_ = v.<span class="hljs-built_in">size</span>();<br>ans = v;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br>v.<span class="hljs-built_in">push_back</span>(it);<br><span class="hljs-built_in">dfs</span>(it);<br>v.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> k; cin&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; k ; j ++)&#123;<br><span class="hljs-type">int</span> t; cin&gt;&gt;t;<br>e[i].<span class="hljs-built_in">push_back</span>(t);<br>ind[t] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-built_in">sort</span>(e[i].<span class="hljs-built_in">begin</span>(), e[i].<span class="hljs-built_in">end</span>());<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!ind[i])&#123;<br>root = i; <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(root);<br>cout&lt;&lt;max_<span class="hljs-number">+1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>cout&lt;&lt;root;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; ans.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans[i];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>分类练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPLT</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛分类练习2：排序+栈+队列</title>
    <link href="/competition/GPLT/GPLT-Sort-Stack-Queue/"/>
    <url>/competition/GPLT/GPLT-Sort-Stack-Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://pintia.cn/problem-sets/1770719321343606784/exam/problems/type/7?problemSetProblemId=1770719354130493440&amp;page=0">L2-3名人堂与代金券 - 团体程序设计天梯赛练习2：排序+栈+队列</a></p><p><a href="https://pintia.cn/problem-sets/1770719321343606784/exam/problems/type/7?problemSetProblemId=1770719354130493441&amp;page=0">L2-2冰岛人 - 团体程序设计天梯赛练习2：排序+栈+队列</a></p><p><a href="https://pintia.cn/problem-sets/1770719321343606784/exam/problems/type/7?problemSetProblemId=1770719354130493442&amp;page=0">L2-1简单计算器 - 团体程序设计天梯赛练习2：排序+栈+队列</a></p><p><a href="https://pintia.cn/problem-sets/1770719321343606784/exam/problems/type/7?problemSetProblemId=1770719354130493443&amp;page=0">7-4口罩发放 - 团体程序设计天梯赛练习2：排序+栈+队列</a></p><p><a href="https://pintia.cn/problem-sets/1770719321343606784/exam/problems/type/7?problemSetProblemId=1770719354130493444&amp;page=0">7-5包装机 - 团体程序设计天梯赛练习2：排序+栈+队列</a></p><p><a href="https://pintia.cn/problem-sets/1770719321343606784/exam/problems/type/7?problemSetProblemId=1770719354130493445&amp;page=0">7-6清点代码库 - 团体程序设计天梯赛练习2：排序+栈+队列</a></p><p><a href="https://pintia.cn/problem-sets/1770719321343606784/exam/problems/type/7?problemSetProblemId=1770719354130493446&amp;page=0">7-7插松枝 - 团体程序设计天梯赛练习2：排序+栈+队列</a></p><p><a href="https://pintia.cn/problem-sets/1770719321343606784/exam/problems/type/7?problemSetProblemId=1770719354130493447&amp;page=0">7-8老板的作息表 - 团体程序设计天梯赛练习2：排序+栈+队列</a></p><h1 id="l2-3-名人堂与代金券">L2-3 名人堂与代金券</h1><h2 id="题解">题解</h2><p>有N个人的邮箱 和 成绩，前K名可以进入名人堂。</p><p>总评分在 [G, 100] 区间内者，可以得到 50 元 PAT 代金券；在 [60, G)区间内者，可以得到 20 元PAT代金券。</p><p>求奖金总数 和 进入名人堂的名单。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 先按分数排序，再按名称排序</span><br><span class="hljs-comment">// first try：20min</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stu</span>&#123;<br>string name;<br><span class="hljs-type">int</span> sco,rk;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> stu &amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(sco != rhs.sco) <span class="hljs-keyword">return</span> sco &gt; rhs.sco;<br><span class="hljs-keyword">return</span> name &lt; rhs.name;<br>&#125;<br>&#125;s[maxn];<br><br><span class="hljs-type">int</span> n,g,k,sum;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;g&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;s[i].name&gt;&gt;s[i].sco;<br><span class="hljs-keyword">if</span>(s[i].sco &gt;= g &amp;&amp; s[i].sco &lt;= <span class="hljs-number">100</span>) sum += <span class="hljs-number">50</span>;<br><span class="hljs-keyword">if</span>(s[i].sco &gt;= <span class="hljs-number">60</span> &amp;&amp; s[i].sco &lt; g) sum += <span class="hljs-number">20</span>;<br>&#125;<br>cout&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">sort</span>(s<span class="hljs-number">+1</span>,s<span class="hljs-number">+1</span>+n);<br><span class="hljs-comment">// 求每个学生的rank</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br><span class="hljs-keyword">if</span>((i == <span class="hljs-number">1</span>) || (s[i].sco &lt; s[i<span class="hljs-number">-1</span>].sco)) s[i].rk = i;<br><span class="hljs-keyword">else</span> s[i].rk = s[i<span class="hljs-number">-1</span>].rk;<br>&#125;<br><span class="hljs-type">int</span> t = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(t &lt;= n &amp;&amp; s[t].rk &lt;= k)&#123;<br>cout&lt;&lt;s[t].rk&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;s[t].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;s[t].sco&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>t++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l2-2-冰岛人">L2-2 冰岛人</h1><h2 id="题解-1">题解</h2><p>根据冰岛人的姓，可以判断其 性别 和 父亲。</p><p>题目要求我们：</p><p>1）判断2人的性别相同/不同</p><p>2）判断2人是否五代之内有相同祖先。</p><p>用哈希表存储性别，进行判断1）；然后，根据每个人的父亲，构造一张谱系树图，进行判断2）。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span>;<br><br><span class="hljs-type">int</span> n,m,cnt;<br>unordered_map&lt;string, string&gt; pre;<br>unordered_map&lt;string, <span class="hljs-type">bool</span>&gt; g;<br>set&lt;string &gt; v;<br><br><span class="hljs-comment">// 我，父亲，爷爷，曾祖父</span><br><span class="hljs-comment">// 1 2 3 4</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string q1, string q2)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">4</span> ; i ++)&#123;<br>string temp = q2;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">if</span>(q2 == q1) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(!pre.<span class="hljs-built_in">count</span>(q2)) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span> q2 = pre[q2];<br>&#125;<br><span class="hljs-keyword">if</span>(!pre.<span class="hljs-built_in">count</span>(q1)) <span class="hljs-keyword">break</span>;<br>q1 = pre[q1];<br>q2 = temp;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>string q1,q2,str;<br>cin&gt;&gt;q1&gt;&gt;str&gt;&gt;q2&gt;&gt;str;<br><span class="hljs-keyword">if</span>(!v.<span class="hljs-built_in">count</span>(q1) || !v.<span class="hljs-built_in">count</span>(q2)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NA&quot;</span>;<br><span class="hljs-keyword">if</span>(g[q1] == g[q2]) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Whatever&quot;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(q1,q2) &amp;&amp; <span class="hljs-built_in">judge</span>(q2,q1)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-comment">// 坑点：一个人若不是维京人&#123;-m, -f&#125;；</span><br><span class="hljs-comment">// 他自己需要被算在谱系里，但他的父亲不能被算在谱系里。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>string s1,s2; cin&gt;&gt;s1&gt;&gt;s2;<br>v.<span class="hljs-built_in">insert</span>(s1);<br><span class="hljs-keyword">if</span>(s<span class="hljs-number">2.</span><span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;m&#x27;</span>)&#123;<br>g[s1] = <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s<span class="hljs-number">2.</span><span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;f&#x27;</span>)&#123;<br>g[s1] = <span class="hljs-literal">false</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s<span class="hljs-number">2.</span><span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;n&#x27;</span>)&#123;<br>g[s1] = <span class="hljs-literal">true</span>;<br>pre[s1] = s<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,s<span class="hljs-number">2.l</span>ength() - <span class="hljs-number">4</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s<span class="hljs-number">2.</span><span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;r&#x27;</span>)&#123;<br>g[s1] = <span class="hljs-literal">false</span>;<br>pre[s1] = s<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,s<span class="hljs-number">2.l</span>ength() - <span class="hljs-number">7</span>);<br>&#125;<br>&#125;<br>cin&gt;&gt;m;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>cout&lt;&lt;<span class="hljs-built_in">solve</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l2-1-简单计算器">L2-1 简单计算器</h1><h2 id="题解-2">题解</h2><p>题目要求我们构造2个栈，1个用来存储数字，1个用来存储运算符。</p><p>每次从栈1中取出2个数字，栈2中取出一个运算符，将结果存入栈1。</p><p>进行模拟，直到栈2为空，输出结果即可。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-type">int</span> &gt; s1;<br>stack&lt;<span class="hljs-type">char</span>&gt; s2;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">char</span> op)</span></span>&#123;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> a-b;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-keyword">return</span> a+b;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">return</span> a*b;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;ERROR: &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;/&quot;</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">return</span> a/b;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> t;cin&gt;&gt;t;<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(t);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">char</span> c;cin&gt;&gt;c;<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(c);<br>&#125;<br><span class="hljs-keyword">while</span>(!s<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> n1 = s<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>();s<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> n2 = s<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>();s<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();<br><span class="hljs-type">char</span> op = s<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>();s<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();<br>s<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(<span class="hljs-built_in">cal</span>(n2,n1,op));<br>&#125;<br>cout&lt;&lt;s<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="口罩发放">7-4 口罩发放</h1><h2 id="题解-3">题解</h2><p>题目的任务包括2个：</p><p>1）对于每天的申请列表，按题目给定顺序，输出合法的申请，即 满足A.身份证合法 B.间隔超过P天 的申请</p><p>2）按题目给定顺序，输出每个身体状况为1的病人名单。</p><p>注意：1）和2）要求的输出顺序规则不同。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">record</span>&#123;<br>string name,card,mm;<br><span class="hljs-type">int</span> sta,tim,idx;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> record &amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(tim != rhs.tim) <span class="hljs-keyword">return</span> tim &lt; rhs.tim;<br><span class="hljs-keyword">return</span> idx &lt; rhs.idx;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">person</span>&#123;<br>string name,card;<br>&#125;;<br><br><span class="hljs-type">int</span> d,p;<br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; lastDay;<br>vector&lt;person&gt; sick;<br><br><span class="hljs-comment">// 身份证判断</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge_card</span><span class="hljs-params">(string card)</span></span>&#123;<br><span class="hljs-keyword">if</span>(card.<span class="hljs-built_in">length</span>() != <span class="hljs-number">18</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">18</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!(card[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; card[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 时间转换</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_time</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> h = (s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span> + (s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-type">int</span> m = (s[<span class="hljs-number">3</span>] - <span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span> + (s[<span class="hljs-number">4</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">60</span>*h + m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_sick</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : sick)&#123;<br>cout&lt;&lt;it.name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.card&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span></span>&#123;<br><span class="hljs-type">int</span> t,s; cin&gt;&gt;t&gt;&gt;s;<br>vector&lt;record&gt; v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= t ; i ++)&#123;<br>record r;<br>cin&gt;&gt;r.name&gt;&gt;r.card&gt;&gt;r.sta&gt;&gt;r.mm;<br>r.idx = i;<br>r.tim = <span class="hljs-built_in">get_time</span>(r.mm);<br>v.<span class="hljs-built_in">push_back</span>(r);<br><span class="hljs-comment">// 统计病人【排序：列表顺序】</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge_card</span>(r.card) &amp;&amp; r.sta == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">bool</span> vis = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : sick)&#123;<br><span class="hljs-keyword">if</span>(it.card == r.card)&#123;<br>vis = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!vis) sick.<span class="hljs-built_in">push_back</span>(&#123;r.name, r.card&#125;);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 输出当天领取口罩列表【排序：出现时间 &gt; 列表顺序】</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge_card</span>(it.card))&#123;<br><span class="hljs-keyword">if</span>(s &gt; <span class="hljs-number">0</span> &amp;&amp; (!lastDay.<span class="hljs-built_in">count</span>(it.card) || day - lastDay[it.card] &gt; p))&#123;<br>cout&lt;&lt;it.name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.card&lt;&lt;endl;<br>lastDay[it.card] = day;<br>s--;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;d&gt;&gt;p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= d ; i ++)&#123;<br><span class="hljs-built_in">solve</span>(i);<br>&#125;<br><span class="hljs-built_in">print_sick</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="包装机">7-5 包装机</h1><h2 id="题解-4">题解</h2><p>题目给定了N个运输带，每个运输带上有M个物品，用字符表示，栈内最多存L个物品。</p><p>每次按下按钮，若按钮为0，从栈内取出1个物品；若按钮为其他数字，从该下标的运输带上取下物品，放入栈中。</p><p>栈内最多存放L个物品，若超过，先取出1个。</p><p>输出栈内取出的物品顺序。</p><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> n,m,l;<br>stack&lt;<span class="hljs-type">char</span>&gt; s;<br>queue&lt;<span class="hljs-type">char</span>&gt; q[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;l;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-type">char</span> t; cin&gt;&gt;t;<br>q[i].<span class="hljs-built_in">push</span>(t);<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> op;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;op, op != <span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;s.<span class="hljs-built_in">top</span>(); s.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(!q[op].<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &gt;= l)&#123;<br>cout&lt;&lt;s.<span class="hljs-built_in">top</span>(); s.<span class="hljs-built_in">pop</span>();<br>&#125;<br>s.<span class="hljs-built_in">push</span>(q[op].<span class="hljs-built_in">front</span>());<br>q[op].<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="清点代码库">7-6 清点代码库</h1><h2 id="题解-5">题解</h2><p>给定 N个 数组，每个数组包含M个整数。</p><p>我们需要求N个数组中的重复项，并按 重复数 &gt; 数组大小的规则输出。</p><p>注意：这里的数组大小不是长度，指的是vector的排序规则。</p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">record</span>&#123;<br><span class="hljs-type">int</span> cnt;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> record &amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(cnt != rhs.cnt) <span class="hljs-keyword">return</span> cnt &gt; rhs.cnt;<br><span class="hljs-keyword">return</span> v &lt; rhs.v;<br>&#125;<br>&#125;;<br><br>map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; mp;<br>vector&lt;record&gt; ans;<br><span class="hljs-type">int</span> n,m,idx;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-type">int</span> t;cin&gt;&gt;t;<br>v.<span class="hljs-built_in">push_back</span>(t);<br>&#125;<br><span class="hljs-keyword">if</span>(!mp.<span class="hljs-built_in">count</span>(v))&#123;<br>mp[v] = idx++;<br>ans.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">1</span>,v&#125;);<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>ans[mp[v]].cnt++;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; idx ; i ++)&#123;<br>cout&lt;&lt;ans[i].cnt;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ans[i].v)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插松枝">7-7 插松枝</h1><h2 id="题解-6">题解</h2><p>一个松枝 由 K 个 松枝片组成，松枝片长度必须从下到上依次递减。</p><p>工人每次从 N个物品的传送带上取下一个松枝片，插入当前的松枝干(不限数量)上。</p><p>此外，还有一个临时存放松枝片的小盒子，小盒子最多存放M个松枝片。小盒子上若有松枝片，优先级高于传送带。</p><p>将松枝放到成品篮，制作下一个松枝片 的情况如下：</p><p>（1）小盒子已经满了，但传送带上取到的松针仍然不满足要求。</p><p>（2）小盒子中最上面的松针不满足要求，但推送器上已经没有松针了。</p><p>（3）松枝干上松针数量达到K个。</p><h2 id="代码-6">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m,k;<br>vector&lt;vector&lt;<span class="hljs-type">int</span> &gt; &gt; ans;<br>vector&lt;<span class="hljs-type">int</span> &gt; temp;<br>stack&lt;<span class="hljs-type">int</span> &gt; s;<br>queue&lt;<span class="hljs-type">int</span> &gt; q;<br><br><span class="hljs-comment">// 判断插入松针片x是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(x &lt;= temp.<span class="hljs-built_in">back</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入松针片x到当前松枝干上</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>temp.<span class="hljs-built_in">push_back</span>(x);<br><span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(temp);<br>temp.<span class="hljs-built_in">clear</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 清理当前松枝干，存入答案列表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear_cur</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">empty</span>())&#123;<br>ans.<span class="hljs-built_in">push_back</span>(temp);<br>temp.<span class="hljs-built_in">clear</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : ans)&#123;<br><span class="hljs-keyword">if</span>(!v.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;v.<span class="hljs-built_in">front</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v[i];<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> t; cin&gt;&gt;t;<br>q.<span class="hljs-built_in">push</span>(t);<br>&#125;<br><span class="hljs-comment">// 推送器还有松针</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">judge</span>(s.<span class="hljs-built_in">top</span>()) )&#123;<br><span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">top</span>());<br>s.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">judge</span>(q.<span class="hljs-built_in">front</span>()))&#123;<br><span class="hljs-built_in">insert</span>(q.<span class="hljs-built_in">front</span>());<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; m)&#123;<br>s.<span class="hljs-built_in">push</span>(q.<span class="hljs-built_in">front</span>());<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">clear_cur</span>();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 清理小盒子里剩下的松针片</span><br><span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(s.<span class="hljs-built_in">top</span>()))&#123;<br><span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">top</span>()); s.<span class="hljs-built_in">pop</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">clear_cur</span>();<br>&#125;<br>&#125;<br><span class="hljs-built_in">clear_cur</span>();<br><span class="hljs-built_in">print</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="老板的作息表">7-8 老板的作息表</h1><h2 id="题解-7">题解</h2><p>给定一个作息表，格式如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">N<br><span class="hljs-symbol">hh:</span>mm:<span class="hljs-built_in">ss</span> - hh:mm:<span class="hljs-built_in">ss</span><br><span class="hljs-symbol">hh:</span>mm:<span class="hljs-built_in">ss</span> - hh:mm:<span class="hljs-built_in">ss</span><br>...<br><span class="hljs-symbol">hh:</span>mm:<span class="hljs-built_in">ss</span> - hh:mm:<span class="hljs-built_in">ss</span><br></code></pre></td></tr></table></figure><p>要求该作息表未涵盖的一天内的时间段【一天指的是00:00:00 -23:59:59】。</p><h2 id="代码-7">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">record</span>&#123;<br><span class="hljs-type">int</span> t1,t2;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> record &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> t1 &lt; rhs.t1;<br>&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> n;<br>deque&lt;record&gt; dq;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> t1, <span class="hljs-type">int</span> t2)</span></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d:%02d:%02d - %02d:%02d:%02d\n&quot;</span>,<br>t1/<span class="hljs-number">3600</span>,(t1%<span class="hljs-number">3600</span>)/<span class="hljs-number">60</span>,t1%<span class="hljs-number">60</span>, t2/<span class="hljs-number">3600</span>,(t2%<span class="hljs-number">3600</span>)/<span class="hljs-number">60</span>,t2%<span class="hljs-number">60</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> h1,m1,s1,h2,m2,s2;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d:%d - %d:%d:%d&quot;</span>, &amp;h1, &amp;m1, &amp;s1, &amp;h2, &amp;m2, &amp;s2);<br><span class="hljs-type">int</span> sum1 = h1*<span class="hljs-number">3600</span> + m1*<span class="hljs-number">60</span> + s1;<br><span class="hljs-type">int</span> sum2 = h2*<span class="hljs-number">3600</span> + m2*<span class="hljs-number">60</span> + s2;<br>dq.<span class="hljs-built_in">push_back</span>(&#123;sum1, sum2&#125;);<br>&#125;<br><span class="hljs-built_in">sort</span>(dq.<span class="hljs-built_in">begin</span>(), dq.<span class="hljs-built_in">end</span>());<br><span class="hljs-type">int</span> f = <span class="hljs-number">23</span>*<span class="hljs-number">3600</span> + <span class="hljs-number">59</span>*<span class="hljs-number">60</span> + <span class="hljs-number">59</span>;<br>dq.<span class="hljs-built_in">push_front</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>dq.<span class="hljs-built_in">push_back</span>(&#123;f,f&#125;);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; dq.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(dq[i].t2 != dq[i<span class="hljs-number">+1</span>].t1)&#123;<br><span class="hljs-built_in">print</span>(dq[i].t2, dq[i<span class="hljs-number">+1</span>].t1);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>分类练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>GPLT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPLT团体程序设计天梯赛分类练习1：字符串+二维数组</title>
    <link href="/competition/GPLT/GPLT-String-Array/"/>
    <url>/competition/GPLT/GPLT-String-Array/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929984&amp;page=0">L1-1天梯赛座位分配 - 团体程序设计天梯赛练习1：字符串+二维数组</a> - 数组</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929985&amp;page=0">L1-2倒数第N个字符串 - 团体程序设计天梯赛练习1：字符串+二维数组</a> -进制转换</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929986&amp;page=0">L1-6福到了 - 团体程序设计天梯赛练习1：字符串+二维数组</a> - 数组转置</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929987&amp;page=0">L1-8猜数字 - 团体程序设计天梯赛练习1：字符串+二维数组</a> - 数组</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929988&amp;page=0">7-56翻了 - 团体程序设计天梯赛练习1：字符串+二维数组</a> - 字符串匹配</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929989&amp;page=0">L1-3敲笨钟 - 团体程序设计天梯赛练习1：字符串+二维数组</a> - 字符串匹配</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929990&amp;page=0">7-7估值一亿的AI核心代码 - 团体程序设计天梯赛练习1：字符串+二维数组</a> -字符串复杂模拟</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929991&amp;page=0">7-8吃火锅 - 团体程序设计天梯赛练习1：字符串+二维数组</a> - 字符串匹配</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929992&amp;page=0">7-9刮刮彩票 - 团体程序设计天梯赛练习1：字符串+二维数组</a> - 数组</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929993&amp;page=0">7-10吉老师的回归 - 团体程序设计天梯赛练习1：字符串+二维数组</a> -字符串匹配</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929994&amp;page=0">7-11斯德哥尔摩火车上的题 - 团体程序设计天梯赛练习1：字符串+二维数组</a> -数组</p><p><a href="https://pintia.cn/problem-sets/1770719017067823104/exam/problems/type/7?problemSetProblemId=1770719062357929995&amp;page=0">L1-7机工士姆斯塔迪奥 - 团体程序设计天梯赛练习1：字符串+二维数组</a> -数组</p><h1 id="l1-1-天梯赛座位分配">L1-1 天梯赛座位分配</h1><h2 id="题解">题解</h2><p>使用三个栈分别存储每个学校的座位表。</p><p>坑点：考虑只有一所学校参加的情况。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><br><span class="hljs-type">int</span> n,cnt,k,f;<br><span class="hljs-type">int</span> sum[maxn];<br><span class="hljs-type">bool</span> vis[maxn];<br>vector&lt;<span class="hljs-type">int</span> &gt; ans[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;sum[i];<br>sum[i] *= <span class="hljs-number">10</span>;<br>&#125;<br>k = n;<br>cnt = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(vis[i] || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(ans[i].<span class="hljs-built_in">size</span>() &lt; sum[i])&#123;<br>ans[i].<span class="hljs-built_in">push_back</span>(cnt);<br>cnt += <span class="hljs-number">1</span> + (k == <span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans[i].<span class="hljs-built_in">size</span>() == sum[i])&#123;<br>vis[i] = <span class="hljs-literal">true</span>;<br>k--;<br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) cnt++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;#&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; ans[i].<span class="hljs-built_in">size</span>() ; j ++)&#123;<br>cout&lt;&lt;ans[i][j];<br><span class="hljs-keyword">if</span>((j<span class="hljs-number">+1</span>) % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l1-2-倒数第n个字符串">L1-2 倒数第N个字符串</h1><h2 id="题解-1">题解</h2><p>把 aaa - zzz 看成是3位数的26进制数，即 0-0-0 和 25-25-25。</p><p>倒数第N个数，即 <span class="math inline">\(26^l - N\)</span> 个数。我们需要输出这个数的26进制（字母形式）。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxl = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> l,n,cnt,a[maxl];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;l&gt;&gt;n;<br>n = <span class="hljs-built_in">pow</span>(<span class="hljs-number">26</span>, l) - n;<br><span class="hljs-keyword">while</span>(n)&#123;<br>a[cnt++] = n%<span class="hljs-number">26</span>;<br>n /= <span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l<span class="hljs-number">-1</span> ; i &gt;= <span class="hljs-number">0</span> ; i --)&#123;<br>cout&lt;&lt;<span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;a&#x27;</span> + a[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l1-6-福到了">L1-6 福到了</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">char</span> a[maxn][maxn], c;<br><span class="hljs-type">bool</span> f;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;c&gt;&gt;n; <span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>string s; <span class="hljs-built_in">getline</span>(cin,s); <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br>a[i<span class="hljs-number">+1</span>][j<span class="hljs-number">+1</span>] = (s[j] == <span class="hljs-string">&#x27; &#x27;</span> ? s[j] : c);<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 是否完全对称</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j] != a[n-i<span class="hljs-number">+1</span>][n-j<span class="hljs-number">+1</span>])&#123;<br>f = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!f) cout&lt;&lt;<span class="hljs-string">&quot;bu yong dao le&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n ; j &gt;= <span class="hljs-number">1</span> ; j --)&#123;<br>cout&lt;&lt;a[i][j]&lt;&lt;(j == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;\n&quot;</span>:<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l1-8-猜数字">L1-8 猜数字</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e4</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">double</span> avg,gap,num[maxn];<br>string s[maxn],ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;s[i]&gt;&gt;num[i];<br>avg += num[i]/n;<br>&#125;<br>gap = <span class="hljs-number">1e4</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg/<span class="hljs-number">2</span> - num[i]) &lt; gap)&#123;<br>gap = <span class="hljs-built_in">fabs</span>(avg/<span class="hljs-number">2</span> - num[i]);<br>ans = s[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">0</span>)&lt;&lt;avg/<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="翻了">7-5 6翻了</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s1,s2,res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">getline</span>(cin,s1);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(s1[i] == <span class="hljs-string">&#x27;6&#x27;</span>)&#123;<br>res += s1[i];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">9</span>) res = <span class="hljs-string">&quot;27&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span>) res = <span class="hljs-string">&quot;9&quot;</span>;<br>s2 += res;<br>res.<span class="hljs-built_in">clear</span>();<br>&#125;<br>s2 += s1[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">9</span>) res = <span class="hljs-string">&quot;27&quot;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span>) res = <span class="hljs-string">&quot;9&quot;</span>;<br>s2 += res;<br>res.<span class="hljs-built_in">clear</span>();<br>&#125;<br>cout&lt;&lt;s2;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l1-3-敲笨钟">L1-3 敲笨钟</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>vector&lt;string&gt; v;<br><span class="hljs-type">bool</span> f1,f2;<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge_ong</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-keyword">return</span> s.<span class="hljs-built_in">length</span>() &gt;= <span class="hljs-number">4</span> &amp;&amp; s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-4</span>,<span class="hljs-number">3</span>) == <span class="hljs-string">&quot;ong&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>v.<span class="hljs-built_in">clear</span>();<br>f1 = f2 = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否以ong结尾</span><br><span class="hljs-keyword">while</span>(cin&gt;&gt;s)&#123;<br><span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;,&#x27;</span>)&#123;<br>f1 = <span class="hljs-built_in">judge_ong</span>(s);<br>v.<span class="hljs-built_in">push_back</span>(s);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>f2 = <span class="hljs-built_in">judge_ong</span>(s);<br><span class="hljs-keyword">if</span>(f1 &amp;&amp; f2)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span> ; i ++)&#123;<br>cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;qiao ben zhong.&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Skipped&quot;</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>v.<span class="hljs-built_in">push_back</span>(s);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="估值一亿的ai核心代码">7-7 估值一亿的AI核心代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t; string s;<br>vector&lt;string&gt; v; <span class="hljs-comment">// 字段列表</span><br><span class="hljs-type">bool</span> ns[<span class="hljs-number">1050</span>]; <span class="hljs-comment">// 记录这个字段后面是否不需要空格</span><br><br><span class="hljs-comment">// 空格 或 半角字符</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br><span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//将原字符串切割为字段数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_space</span><span class="hljs-params">()</span></span>&#123;<br>s = s + <span class="hljs-string">&quot; &quot;</span>;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27; &#x27;</span> || <span class="hljs-built_in">judge</span>(s[i]))&#123; <span class="hljs-comment">// split : &quot; &quot; or 半角字符</span><br><span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">empty</span>()) v.<span class="hljs-built_in">push_back</span>(res);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(s[i]))&#123;<br>string t = <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;&quot;</span>) + s[i];<br>v.<span class="hljs-built_in">push_back</span>(t);<br>                <span class="hljs-comment">// 若半角字符后面没有空格，则进行记录，在输出时删去</span><br><span class="hljs-keyword">if</span>(i<span class="hljs-number">+1</span> &lt; s.<span class="hljs-built_in">length</span>() &amp;&amp; s[i<span class="hljs-number">+1</span>] != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>ns[v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>res.<span class="hljs-built_in">clear</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>res += s[i];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 题目要求的修改操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modified</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; v[i].<span class="hljs-built_in">size</span>() ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[i][j] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; v[i][j] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; v[i][j] != <span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>v[i][j] = v[i][j] + (<span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(v[i][j] == <span class="hljs-string">&#x27;?&#x27;</span>) v[i][j] = <span class="hljs-string">&#x27;!&#x27;</span>;<br>&#125;<br>&#125;<br>vector&lt;string&gt; vc = v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(v[i] == <span class="hljs-string">&quot;can&quot;</span> || v[i] == <span class="hljs-string">&quot;could&quot;</span>)&#123;<br><span class="hljs-keyword">if</span>(i<span class="hljs-number">+1</span> &lt; v.<span class="hljs-built_in">size</span>() &amp;&amp; v[i<span class="hljs-number">+1</span>] == <span class="hljs-string">&quot;you&quot;</span>)&#123;<br>vc[i] = <span class="hljs-string">&quot;I&quot;</span>;<br>vc[i<span class="hljs-number">+1</span>] = v[i];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(v[i] == <span class="hljs-string">&quot;I&quot;</span> || v[i] == <span class="hljs-string">&quot;me&quot;</span>) vc[i] = <span class="hljs-string">&quot;you&quot;</span>;<br>&#125;<br>v = vc;<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;AI: &quot;</span>;<br><span class="hljs-keyword">if</span>(!v.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;v.<span class="hljs-built_in">front</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judge</span>(v[i][<span class="hljs-number">0</span>]) &amp;&amp; !ns[i<span class="hljs-number">-1</span>]) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;v[i];<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(ns,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(ns));<br><span class="hljs-built_in">getline</span>(cin,s);<br>cout&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>v.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">remove_space</span>();<br><span class="hljs-built_in">modified</span>();<br><span class="hljs-built_in">Print</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="吃火锅">7-8 吃火锅</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s;<br>string p = <span class="hljs-string">&quot;chi1 huo3 guo1&quot;</span>;<br><span class="hljs-type">int</span> f,cnt,t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(cin,s))&#123;<br>t++;<br><span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;.&quot;</span>) <span class="hljs-keyword">break</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ls = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lp = p.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">while</span>(i &lt; ls &amp;&amp; j &lt; lp)&#123;<br><span class="hljs-keyword">if</span>(s[i] == p[j])&#123;<br>i++; j++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>i -= j<span class="hljs-number">-1</span>; j=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cnt += (j == lp);<br><span class="hljs-keyword">if</span>(f == <span class="hljs-number">0</span> &amp;&amp; cnt &gt; <span class="hljs-number">0</span>) f = t;<br>&#125;<br>cout&lt;&lt;t<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;-_-#&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;f&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="刮刮彩票">7-9 刮刮彩票</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> price[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<br><span class="hljs-number">10000</span>,<span class="hljs-number">36</span>,<span class="hljs-number">720</span>,<span class="hljs-number">360</span>,<span class="hljs-number">80</span>,<span class="hljs-number">252</span>,<span class="hljs-number">108</span>,<span class="hljs-number">72</span>,<span class="hljs-number">54</span>,<br><span class="hljs-number">180</span>,<span class="hljs-number">72</span>,<span class="hljs-number">180</span>,<span class="hljs-number">119</span>,<span class="hljs-number">36</span>,<span class="hljs-number">306</span>,<span class="hljs-number">1080</span>,<span class="hljs-number">144</span>,<span class="hljs-number">1800</span>,<span class="hljs-number">3600</span>&#125;;<br><br><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-type">int</span> t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(s &gt;= <span class="hljs-number">1</span> &amp;&amp; s &lt;= <span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br>res += a[s][i];<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &gt;= <span class="hljs-number">4</span> &amp;&amp; s &lt;= <span class="hljs-number">6</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br>res += a[i][s<span class="hljs-number">-3</span>];<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-number">7</span>)&#123;<br>res = a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] + a[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>res = a[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] + a[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">return</span> price[res];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">3</span> ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br>vis[a[i][j]] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 复原为0位置的数字[矩阵必须为1-9]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">3</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j] == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> q = <span class="hljs-number">1</span> ; q &lt;= <span class="hljs-number">9</span> ; q ++)&#123;<br><span class="hljs-keyword">if</span>(!vis[q])&#123;<br>a[i][j] = q;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;<br>cout&lt;&lt;a[x][y]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>cin&gt;&gt;t;<br>cout&lt;&lt;<span class="hljs-built_in">getPrice</span>(t);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="吉老师的回归">7-10 吉老师的回归</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br>string s;<br><br><span class="hljs-comment">// 字符串匹配</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string p)</span></span>&#123;<br><span class="hljs-type">int</span> ls = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lp = p.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; ls &amp;&amp; j &lt; lp)&#123;<br><span class="hljs-keyword">if</span>(s[i] == p[j])&#123;<br>i++;j++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>i -= j<span class="hljs-number">-1</span>;j=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> j == lp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">getline</span>(cin, s);<br><span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">judge</span>(<span class="hljs-string">&quot;easy&quot;</span>) || <span class="hljs-built_in">judge</span>(<span class="hljs-string">&quot;qiandao&quot;</span>)))&#123;<br><span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;s;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>m--;<br>&#125;<br>n--;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Wo AK le&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="斯德哥尔摩火车上的题">7-11 斯德哥尔摩火车上的题</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s1,s2;<br><br><span class="hljs-function">string <span class="hljs-title">getRes</span><span class="hljs-params">(string s)</span></span>&#123;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br><span class="hljs-type">int</span> l = s[i<span class="hljs-number">-1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-type">int</span> r = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">if</span>(l % <span class="hljs-number">2</span> == r % <span class="hljs-number">2</span>)&#123;<br>res += <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-built_in">max</span>(l,r));<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s1&gt;&gt;s2;<br>string r1 = <span class="hljs-built_in">getRes</span>(s1);<br>string r2 = <span class="hljs-built_in">getRes</span>(s2);<br><span class="hljs-keyword">if</span>(r1 == r2)&#123;<br>cout&lt;&lt;r1;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;r1&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;r2;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l1-7-机工士姆斯塔迪奥">L1-7 机工士姆斯塔迪奥</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> n,m,q,t,c;<br><span class="hljs-type">int</span> cols,rows;<br><span class="hljs-type">bool</span> vis_col[maxn],vis_row[maxn];<br><br><span class="hljs-comment">// 剩下的方格数 = 总方格数量 - 删去的行数*总列数 - 删去的列数*总行数 + 删去的列数*删去的行数 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br><span class="hljs-keyword">while</span>(q--)&#123;<br>cin&gt;&gt;t&gt;&gt;c;<br><span class="hljs-keyword">if</span>(t == <span class="hljs-number">0</span> &amp;&amp; !vis_row[c])&#123;<br>rows++;<br>vis_row[c] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t == <span class="hljs-number">1</span> &amp;&amp; !vis_col[c])&#123;<br>cols++;<br>vis_col[c] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;n*m - rows*m - cols*n + rows*cols;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>GPLT</category>
      
      <category>分类练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>GPLT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法提高课：动态规划6-区间DP</title>
    <link href="/competition/acwing-advance/AcWing-DP-6/"/>
    <url>/competition/acwing-advance/AcWing-DP-6/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://www.acwing.com/problem/content/1070/">1068.环形石子合并 - AcWing题库</a>：区间DP + 断环成链 + 前缀和</p><p><a href="https://www.acwing.com/problem/content/322/">320. 能量项链 -AcWing题库</a>：区间DP + 断环成链</p><p><a href="https://www.acwing.com/problem/content/481/">479. 加分二叉树- AcWing题库</a>：区间DP + 二叉树遍历</p><p><a href="https://www.acwing.com/problem/content/1071/">1069.凸多边形的划分 - AcWing题库</a>：区间DP + 三角剖分 + 高精度</p><p><a href="https://www.acwing.com/problem/content/323/">321. 棋盘分割 -AcWing题库</a>：二维区间DP</p><h1 id="环形石子合并">1068 环形石子合并</h1><p>将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。</p><p>规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。</p><p>请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：</p><ul><li>选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。</li><li>选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。</li></ul><h2 id="题解">题解</h2><p>最小值状态转移方程： <span class="math display">\[dp[l][r] = min(dp[l][r], dp[l][k] + dp[k][r] + \sum_{l}^{r}a[i])\]</span> 最大值状态转移方程： <span class="math display">\[dp[l][r] = max(dp[l][r], dp[l][k] + dp[k][r] + \sum_{l}^{r}a[i])\]</span> <span class="math inline">\(dp[l][r]\)</span> 表示合并 l 到 r个石子需要的花销。此处，遍历划分点k，可以得到每个区间的最优解。</p><p>注意：这里的求和需要用前缀和优化。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">500</span>;<br><br><span class="hljs-type">int</span> n,a[maxn],prefix[maxn];<br><span class="hljs-type">int</span> dp1[maxn][maxn],dp2[maxn][maxn];<br><span class="hljs-type">int</span> ma,mi;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i]; a[i+n] = a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">2</span>*n ; i ++)&#123;<br>prefix[i] = prefix[i<span class="hljs-number">-1</span>] + a[i];<br>&#125;<br><span class="hljs-built_in">memset</span>(dp1,inf,<span class="hljs-built_in">sizeof</span>(dp1));<br><span class="hljs-built_in">memset</span>(dp2,-inf,<span class="hljs-built_in">sizeof</span>(dp2));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">2</span>*n ; i ++)&#123;<br>dp1[i][i] = dp2[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j+i<span class="hljs-number">-1</span> &lt; <span class="hljs-number">2</span>*n ; j ++)&#123;<br><span class="hljs-type">int</span> l = j;<br><span class="hljs-type">int</span> r = j+i<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> sum = prefix[r] - prefix[l<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r;  k ++)&#123;<br>dp1[l][r] = <span class="hljs-built_in">min</span>(dp1[l][r], dp1[l][k] + dp1[k<span class="hljs-number">+1</span>][r] + sum);<br>dp2[l][r] = <span class="hljs-built_in">max</span>(dp2[l][r], dp2[l][k] + dp2[k<span class="hljs-number">+1</span>][r] + sum);<br>&#125;<br>&#125;<br>&#125;<br>ma = -inf; mi = inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i+n<span class="hljs-number">-1</span> &lt; <span class="hljs-number">2</span>*n ; i ++)&#123;<br>mi = <span class="hljs-built_in">min</span>(mi, dp1[i][i+n<span class="hljs-number">-1</span>]);<br>ma = <span class="hljs-built_in">max</span>(ma, dp2[i][i+n<span class="hljs-number">-1</span>]);<br>&#125;<br>cout&lt;&lt;mi&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;ma;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="能量项链">320 能量项链</h1><p>如果前一颗能量珠的头标记为 m，尾标记为 r，后一颗能量珠的头标记为r，尾标记为 n，则聚合后释放的能量为 m×r×n，新产生的珠子的头标记为m，尾标记为 n。</p><p>例如：((4⊕1)⊕2)⊕3)=10×2×3+10×3×5+10×5×10=710</p><p>显然，不同的聚合顺序得到的总能量是不同的，请求出一串项链释放出的最大总能量。</p><h2 id="题解-1">题解</h2><p><span class="math display">\[dp[l][r] = max(dp[l][r], dp[l][k] + dp[k+1][r] + h[l]*h[k+1]*h[r+1])\]</span></p><p><span class="math inline">\(dp[l][r]\)</span> 表示合并 l 到 r个珠子释放出的最大能量，<span class="math inline">\(h[i]\)</span>表示某个珠子的头标记，<span class="math inline">\(h[i+1]\)</span>恰好是尾标记。</p><p>此处，遍历划分点k，可以得到每个区间的最大值。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">205</span>;<br><br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> h[maxn],dp[maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;h[i];<br>h[i+n] = h[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j+i<span class="hljs-number">-1</span> &lt; <span class="hljs-number">2</span>*n ; j ++)&#123;<br><span class="hljs-type">int</span> l = j;<br><span class="hljs-type">int</span> r = j+i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>dp[l][r] = <span class="hljs-built_in">max</span>(dp[l][r], dp[l][k] + dp[k<span class="hljs-number">+1</span>][r] + h[l]*h[k<span class="hljs-number">+1</span>]*h[r<span class="hljs-number">+1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i+n<span class="hljs-number">-1</span> &lt; <span class="hljs-number">2</span>*n ; i ++)&#123;<br>ans = <span class="hljs-built_in">max</span>(ans,dp[i][i+n<span class="hljs-number">-1</span>]);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="加分二叉树">479 加分二叉树</h1><p>在一颗二叉树tree中，任一棵子树 subtree（也包含 tree本身）的加分计算方法如下：     </p><p>subtree的左子树的加分 × subtree的右子树的加分 ＋subtree的根的分数 </p><p>tree的中序遍历为（1,2,3,…,n），现在给定每个节点的加分，要求输出： </p><p>（1）tree的最高加分 </p><p>（2）tree的前序遍历</p><h2 id="题解-2">题解</h2><p>状态转移方程： <span class="math display">\[dp[l][r] = dp[l][k-1]*dp[k+1][r] + w[k];\]</span> 此处，<span class="math inline">\(dp[l][r]\)</span>表示从区间<span class="math inline">\([l, r]\)</span>的最优解。由于中序遍历的特殊性质，划分区间的点k恰好是子树的根，</p><p>我们在状态转移的过程中，记录最优解下的根为<span class="math inline">\(root[l][r]\)</span>，最后可以重构二叉树，输出前序遍历。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> n,cnt;<br><span class="hljs-type">int</span> w[maxn], pre[maxn], dp[maxn][maxn], root[maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_order</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> k = root[l][r];<br>cout&lt;&lt;k&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-built_in">pre_order</span>(l, k<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">pre_order</span>(k<span class="hljs-number">+1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i];<br>dp[i][i] = w[i];<br>root[i][i] = i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j+i<span class="hljs-number">-1</span> &lt;= n ; j ++)&#123;<br><span class="hljs-type">int</span> l = j;<br><span class="hljs-type">int</span> r = j+i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br><span class="hljs-type">int</span> lt = k<span class="hljs-number">-1</span> &gt;= l ? dp[l][k<span class="hljs-number">-1</span>] : <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> rt = k<span class="hljs-number">+1</span> &lt;= r ? dp[k<span class="hljs-number">+1</span>][r] : <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(lt*rt + w[k] &gt; dp[l][r])&#123;<br>dp[l][r] = lt*rt + w[k];<br>root[l][r] = k;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">1</span>][n]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">pre_order</span>(<span class="hljs-number">1</span>,n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="凸多边形的划分">1069 凸多边形的划分</h1><p>给定一个具有 N 个顶点的凸多边形，每个顶点的权值都是一个正整数。</p><p>将这个凸多边形划分成 N−2个互不相交的三角形，对于每个三角形，其三个顶点的权值相乘都可得到一个权值乘积，试求所有三角形的顶点权值乘积之和至少为多少。</p><h2 id="题解-3">题解</h2><p>对于一个区间为[l,r]的N边形，都可以用一个内部的三角形（三个点），将其划分为3部分：</p><p>即 l、r和k构成的三角形 + 区间[l, k]的最优解 + 区间[k,r]的最优解。</p><figure><img src="/competition/acwing-advance/AcWing-DP-6/55909_f09eb023fb-IMG_6B91346846EE-1.jpeg" alt="1069"><figcaption aria-hidden="true">1069</figcaption></figure><p>若我们得到两个点l 和r，第三个点k有N-2种选择，依次遍历每个选择下的权值，可以得到最优解。<span class="math display">\[dp[l][r] = min(dp[l][r], dp[l][k] + dp[k][r] + w[l]*w[k]*w[r])\]</span> 注意：本题数值较大，需要使用高精度乘法和加分。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">205</span>;<br><br><span class="hljs-type">int</span> n;<br>string w[maxn];<br>string dp[maxn][maxn];<br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>],b[<span class="hljs-number">1000</span>],c[<span class="hljs-number">1000</span>];<br><br><span class="hljs-function">string <span class="hljs-title">mul</span><span class="hljs-params">(string x, string y)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br>string ans = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> la = x.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lb = y.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lc = la + lb;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++) a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lb; i++) b[i] = y[lb - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; lb; j++) &#123;<br>c[i + j] += a[i] * b[j];<br>c[i + j + <span class="hljs-number">1</span>] += c[i + j] / <span class="hljs-number">10</span>;<br>c[i + j] %= <span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> ((c[lc - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (lc &gt; <span class="hljs-number">1</span>)) lc--;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lc- <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(c[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">add</span><span class="hljs-params">(string x, string y)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br><span class="hljs-type">int</span> la = x.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lb = y.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lc = <span class="hljs-built_in">max</span>(la, lb); <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++) a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lb; i++) b[i] = y[lb - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lc; i++) &#123;<br>c[i] += a[i] + b[i];<br>c[i + <span class="hljs-number">1</span>] += c[i]/<span class="hljs-number">10</span>;<br>c[i] %= <span class="hljs-number">10</span>;<br>&#125;<br>lc++;<br><span class="hljs-keyword">while</span> (lc &gt; <span class="hljs-number">1</span> &amp;&amp; c[lc<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>) lc--;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lc<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">char</span>(c[i] + <span class="hljs-string">&#x27;0&#x27;</span>));<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">Min</span><span class="hljs-params">(string x, string y)</span></span>&#123;<br><span class="hljs-type">int</span> lx = x.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> ly = y.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span>(lx &gt; ly) <span class="hljs-keyword">return</span> y;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ly &gt; lx) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; lx ; i ++)&#123;<br><span class="hljs-keyword">if</span>(x[i] &lt; y[i]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x[i] &gt; y[i]) <span class="hljs-keyword">return</span> y;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j+i<span class="hljs-number">-1</span> &lt;= n ; j ++)&#123;<br><span class="hljs-type">int</span> l = j;<br><span class="hljs-type">int</span> r = j+i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l<span class="hljs-number">+1</span> ; k &lt; r ; k ++)&#123;<br>string sum = <span class="hljs-built_in">mul</span>(<span class="hljs-built_in">mul</span>(w[l],w[k]),w[r]);<br><span class="hljs-keyword">if</span>(dp[l][r].<span class="hljs-built_in">empty</span>()) dp[l][r] = <span class="hljs-built_in">add</span>(dp[l][k], <span class="hljs-built_in">add</span>(dp[k][r], sum));<br><span class="hljs-keyword">else</span> dp[l][r] = <span class="hljs-built_in">Min</span>(dp[l][r], <span class="hljs-built_in">add</span>(dp[l][k], <span class="hljs-built_in">add</span>(dp[k][r], sum)));<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">1</span>][n];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法提高课：动态规划5-状态压缩DP</title>
    <link href="/competition/acwing-advance/AcWing-DP-5/"/>
    <url>/competition/acwing-advance/AcWing-DP-5/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://www.acwing.com/problem/content/1066/">1064. 小国王 -AcWing题库</a>：状态压缩DP 求方案数【棋盘】【限制放置个数】</p><p><a href="https://www.acwing.com/problem/content/329/">327. 玉米田 -AcWing题库</a>：状态压缩DP 求方案数【棋盘】【存在无效点】</p><p><a href="https://www.acwing.com/problem/content/294/">292. 炮兵阵地 -AcWing题库</a>：状态压缩DP 求方案数【棋盘】【需要考虑前2行 / 列】</p><p><a href="https://www.acwing.com/problem/content/526/">524. 愤怒的小鸟- AcWing题库</a>：状态压缩DP + 计算几何【重复覆盖问题】</p><p><a href="https://www.acwing.com/problem/content/531/">529. 宝藏 -AcWing题库</a>：状态压缩DP + 最小生成树</p><h1 id="小国王">1064 小国王</h1><p>在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8个格子，求使它们无法互相攻击的方案总数。</p><h2 id="题解">题解</h2><p>经典状态压缩DP问题；</p><p>首先，我们每行的每种<strong>合法</strong>状态存入sit数组，并将该状态下的国王数存入tol数组；</p><p>然后，设置状态转移方程为： <span class="math display">\[dp[i][j][k]=dp[i][j][k]+dp[i-1][r][k-tol[j]] \quad if \spacecheck(j,r)==true\]</span> i为当前行，k为已放置的国王数，j 和 r分别为当前行 和上一行的状态下标。若两个状态不冲突，进行累加；</p><p>最后，合并所有<span class="math inline">\(dp[n][i]\)</span>，得到总方案数。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">11</span>;<br><br><span class="hljs-type">int</span> n,k,cnt,ans;<br><span class="hljs-type">int</span> sit[(<span class="hljs-number">1</span>&lt;&lt;maxn)],tol[(<span class="hljs-number">1</span>&lt;&lt;maxn)],dp[maxn][(<span class="hljs-number">1</span>&lt;&lt;maxn)][maxn*maxn];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(sit[a] &amp; sit[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>((sit[a]&lt;&lt;<span class="hljs-number">1</span>) &amp; sit[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>((sit[a]&gt;&gt;<span class="hljs-number">1</span>) &amp; sit[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-comment">// init state</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span> ; s &lt; (<span class="hljs-number">1</span>&lt;&lt;n) ; s ++)&#123;<br><span class="hljs-keyword">if</span>(!(s &amp; s &gt;&gt; <span class="hljs-number">1</span>))&#123;<br>sit[++cnt] = s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) tol[cnt]++;<br>&#125;<br>&#125;<br>&#125;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= cnt ; j ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r &lt;= cnt ; r ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(j,r))&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = k; c &gt;= tol[j] ; c --)&#123;<br>dp[i][j][c] += dp[i<span class="hljs-number">-1</span>][r][c-tol[j]];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= cnt ; i ++)&#123;<br>ans += dp[n][i][k];<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="玉米田">327 玉米田</h1><p>玉米田由 M×N 个小土地方格组成。</p><p>部分土地是不育的，无法种植。相邻的土地也不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。</p><p>求出共有多少种种植方法。</p><p>注意：<strong>土地上什么都不种也算一种方法</strong>。</p><h2 id="题解-1">题解</h2><p>该题在1064的基础上增加了“不合法的方格”，但没有放置数量限制，所以dp数组可以减少一个维度。</p><p>首先，我们每行的种土豆的<strong>合法</strong>状态存入sit数组；</p><p>然后，设置状态转移方程为： <span class="math display">\[dp[i][j] = dp[i][j] + dp[i-1][r] \quad if \space check(j,r) == true \\\]</span> i为当前行，j 和 r分别为当前行 和上一行的状态下标。若两个状态不冲突，进行累加；【为了判断不合法的方格，使用vis数组存储01状态】</p><p>最后，合并所有<span class="math inline">\(dp[m][i]\)</span>，得到总方案数。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">200</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">13</span>;<br><br><span class="hljs-type">int</span> m,n,cnt,ans;<br><span class="hljs-type">int</span> sit[(<span class="hljs-number">1</span>&lt;&lt;maxn)];<br><span class="hljs-type">int</span> dp[maxm][(<span class="hljs-number">1</span>&lt;&lt;maxn)], vis[maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-type">int</span> f;cin&gt;&gt;f;<br>vis[i] = vis[i]|(f&lt;&lt;(j<span class="hljs-number">-1</span>));<br>&#125;<br>&#125;<br><span class="hljs-comment">// init state</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span> ; s &lt; (<span class="hljs-number">1</span>&lt;&lt;n) ; s ++)&#123;<br><span class="hljs-keyword">if</span>(!(s &amp; s&gt;&gt;<span class="hljs-number">1</span>))&#123;<br>sit[++cnt] = s;<br>&#125;<br>&#125;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= cnt ; j ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r &lt;= cnt ; r ++)&#123;<br>                <span class="hljs-comment">// check</span><br><span class="hljs-keyword">if</span>( (~vis[i])&amp; sit[j] ) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>( sit[j] &amp; sit[r] ) <span class="hljs-keyword">continue</span>;<br>dp[i][j] = (dp[i][j] + dp[i<span class="hljs-number">-1</span>][r])%mod;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= cnt ; i ++)&#123;<br>ans = (ans + dp[m][i])%mod;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="炮兵阵地">292 炮兵阵地</h1><p>一个 N×M 的地图由 N 行 M 列组成，地图的每一格可能是山地（用<code>H</code> 表示），也可能是平原（用 <code>P</code>表示）。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p><figure><img src="/competition/acwing-advance/AcWing-DP-5/19_d512cdba31-1185_1.jpg" alt="292"><figcaption aria-hidden="true">292</figcaption></figure><p>炮兵的攻击范围不受地形的影响。求最多能够摆放多少个炮兵部队。</p><h2 id="题解-2">题解</h2><p>该题和1064、327的区别在于，状态是否合法需要分析前2行，所以在dp数组需要同时存储2行的状态。</p><p><strong>此外，这道题不是要求方案数，而是求炮兵部队的数量最大值。</strong></p><p>设置状态转移方程为： <span class="math display">\[dp[i][j][k] = max(dp[i][j][k], dp[i-1][r][k] + tol[j]) \quad if \spacecheck(j,r,k) == true\]</span> i为当前行，j 、r、k分别为当前行、上一行、再上一行的状态下标。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> max_cnt = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// 这里如果直接开(1&lt;&lt;maxn)会Memory Limit</span><br><span class="hljs-comment">// 1&lt;&lt;10 = 1024</span><br><span class="hljs-comment">// 通过估算，得到最大max_cnt &lt; 100 [if m = 10, PPPPPPPPPP];</span><br><br><span class="hljs-type">int</span> n,m,cnt,ans;<br><span class="hljs-type">int</span> tol[max_cnt];<br><span class="hljs-type">int</span> vis[maxn],sit[max_cnt],dp[maxn][max_cnt][max_cnt];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-type">char</span> c;cin&gt;&gt;c;<br><span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;P&#x27;</span>) vis[i] = vis[i]|(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>));<br>&#125;<br>&#125;<br><span class="hljs-comment">// init state</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span> ; s &lt; (<span class="hljs-number">1</span>&lt;&lt;m) ; s ++)&#123;<br><span class="hljs-keyword">if</span>( !( s &amp; (s&gt;&gt;<span class="hljs-number">1</span>) ) &amp;&amp; !(s &amp; (s&gt;&gt;<span class="hljs-number">2</span>) ) )&#123;<br>sit[++cnt] = s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-keyword">if</span>((s&gt;&gt;i) &amp; <span class="hljs-number">1</span>) tol[cnt]++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= cnt ; j ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r &lt;= cnt ; r ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; k &lt;= cnt ; k ++)&#123;<br><span class="hljs-keyword">if</span>((~vis[i]) &amp; sit[j]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(sit[j] &amp; sit[r]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(sit[j] &amp; sit[k]) <span class="hljs-keyword">continue</span>;<br>dp[i][j][r] = <span class="hljs-built_in">max</span>(dp[i][j][r], dp[i<span class="hljs-number">-1</span>][r][k] + tol[j]);<br>ans = <span class="hljs-built_in">max</span>(dp[i][j][r],ans);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="愤怒的小鸟">524 愤怒的小鸟</h1><p>有一架弹弓位于 (0,0) 处，每次 Kiana可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 y=ax2+bx的曲线。在游戏的某个关卡里，平面的第一象限中有 n 只绿色的小猪，其中第 i 只小猪所在的坐标为 (xi,yi)。</p><p>这款游戏一共有 T 个关卡，求每个关卡中，消灭所有小猪最少需要的小鸟数量。</p><h2 id="题解-3">题解</h2><p>首先，我们进行预处理，只需要枚举所有不重合的点，每2点可以确定一条过原点的抛物线。<span class="math display">\[\left.\left\{\begin{array}{c}y_1=ax_1^2+bx_1\\y_2=ax_2^2+bx_2\end{array}\right.\right.\quad\Rightarrow\quad\left\{\begin{array}{c}a=\frac{\frac{y_1}{x_1}-\frac{y_2}{x_2}}{x_1-x_2}\\b=\frac{y_1}{x_1}-ax_1\end{array}\right.\]</span>接着，枚举每个小猪是否在某条抛物线上，我们就得到了每个抛物线的01状态，即能消灭哪些小猪，并存在sit数组中；</p><p>然后，我们把这个问题转化为 重复覆盖问题。状态转移方程为： <span class="math display">\[dp[s|sit[i][j]] = min(dp[s|sit[i][j]], dp[s] + 1)\]</span> 这里 i 和 j 分别表示2点，sit为它们确定的抛物线的01状态。</p><p>最后，得到结果为最少抛物线数为<span class="math inline">\(dp[(1&lt;&lt;n)-1]\)</span>。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">19</span>; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br><span class="hljs-type">double</span> x,y;<br>&#125;p[maxn];<br><br><span class="hljs-type">int</span> n,m,t,cnt;<br><span class="hljs-type">int</span> sit[maxn][maxn], dp[<span class="hljs-number">1</span>&lt;&lt;maxn];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - b) &lt; <span class="hljs-number">1e-6</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_sit</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(sit,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(sit));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>sit[i][i] = <span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-type">double</span> x1,y1,x2,y2;<br>x1 = p[i].x; y1 = p[i].y;<br>x2 = p[j].x; y2 = p[j].y;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">equal</span>(x1, x2)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// x1 - x2 != 0</span><br><span class="hljs-type">double</span> a = (y1 / x1 - y2 / x2) / (x1 - x2); <br><span class="hljs-type">double</span> b = (y1 / x1) - a * x1;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">equal</span>(a,<span class="hljs-number">0.0</span>) || a &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// a &lt; 0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; k &lt;= n ; k ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">equal</span>(a*p[k].x*p[k].x + b*p[k].x, p[k].y))&#123;<br>sit[i][j] = sit[i][j] | (<span class="hljs-number">1</span>&lt;&lt;(k<span class="hljs-number">-1</span>));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;p[i].x&gt;&gt;p[i].y;<br>&#125;<br><span class="hljs-built_in">init_sit</span>();<br><span class="hljs-built_in">memset</span>(dp,inf,<span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span> ; s &lt; (<span class="hljs-number">1</span>&lt;&lt;n) ; s ++)&#123;<br>dp[s|sit[i][j]] = <span class="hljs-built_in">min</span>(dp[s|sit[i][j]], dp[s] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法提高课：动态规划4-状态机模型</title>
    <link href="/competition/acwing-advance/AcWing-DP-4/"/>
    <url>/competition/acwing-advance/AcWing-DP-4/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p>状态机DP就是在普通DP的基础上，专门开辟一个维度记录当前事件所处的状态。</p><p>当某个事件的状态影响到后面事件的决策的时候，我们需要使用状态机模型。</p><p><a href="https://www.acwing.com/problem/content/description/1051/">1049.大盗阿福 - AcWing题库</a>：不能选择相邻数值，0/1表示是否选择。</p><p><a href="https://www.acwing.com/problem/content/1059/">1057. 股票买卖IV -AcWing题库</a>：每天可以买入和卖出股票（最多k次），0/1表示这天是否持有股票</p><p><a href="https://www.acwing.com/problem/content/1060/">1058. 股票买卖V -AcWing题库</a>：不限制购买次数，但股票卖出的第二天，无法购买。0/1/2表示不持有/持有/冷冻期。</p><p><a href="https://www.acwing.com/problem/content/1054/">1052. 设计密码- AcWing题库</a>：KMP匹配构建状态机模型。</p><p><a href="https://www.acwing.com/problem/content/1055/">1053. 修复DNA- AcWing题库</a>：AC自动机构建状态机模型（待补）</p><h1 id="大盗阿福">1049 大盗阿福</h1><p>这条街上一共有 N家店铺，每家店中都有一些现金。只有同时洗劫了两家相邻的店铺，报警系统才会启动。在不惊动警察的情况下，他今晚最多可以得到多少现金？</p><h2 id="题解">题解</h2><p>状态机模型可以用下面这张图来表示：</p><figure><img src="/competition/acwing-advance/AcWing-DP-4/55909_5c79c42cda-IMG_86A570C793B3-1.jpeg" alt="1049"><figcaption aria-hidden="true">1049</figcaption></figure><p>图片来源：<a href="https://www.acwing.com/solution/content/55012/">AcWing 1049.大盗阿福【线性DP+状态机模型DP+滚动数组优化】 - AcWing</a></p><p>状态转移方程： <span class="math display">\[\begin{cases}dp[i][0] = max(dp[i-1][1], dp[i][0]) \\dp[i][1] = dp[i-1][0] + a[i]\end{cases}\]</span> i - 考虑到第i家；0-不洗劫该店铺；1-洗劫该店铺</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> t,n;<br><span class="hljs-type">int</span> dp[maxn][<span class="hljs-number">2</span>],a[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);<br>dp[i][<span class="hljs-number">1</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + a[i];<br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[n][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">1</span>])&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="股票买卖-iv">1057 股票买卖 IV</h1><p>给定一支股票在第 i 天的价格。每天可以买入/卖出该支股票。</p><p>求最多可以完成 k 笔交易的情况下的最大利润。</p><p>注意：必须在再次购买前出售掉之前的股票；一次买入卖出合为一笔交易。</p><h2 id="题解-1">题解</h2><p>状态机模型可以用下面这张图来表示：</p><figure><img src="/competition/acwing-advance/AcWing-DP-4/55909_e2c6226ada-算法提高课-dp-状态机.png" alt="1057"><figcaption aria-hidden="true">1057</figcaption></figure><p>图片来源：<a href="https://www.acwing.com/solution/content/55037/">AcWing 1057.股票买卖 IV【线性DP+状态机模型DP+滚动数组优化】 - AcWing</a></p><p>状态转移方程： <span class="math display">\[\begin{cases}dp[i][j][0] = max(dp[i-1][j][0], dp[i][j-1][1] - p[i]) \\dp[i][j][1] = max(dp[i-1][j][1], dp[i][j][1] + p[i])\end{cases}\]</span> i - 考虑到第i天，j - 已完成交易多少次（买入+卖出算一次）；0 -不持有股票；1 - 持有股票</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxk = <span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> n,k,ans;<br><span class="hljs-type">int</span> p[maxn],dp[maxn][maxk][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 0-不持有股票；1-持有股票；</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;p[i];<br>&#125;<br><span class="hljs-built_in">memset</span>(dp,-inf,<span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= k ; j ++)&#123;<br>dp[i][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">0</span>] - p[i]);<br><span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">1</span>) dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + p[i]);<br><span class="hljs-keyword">else</span> dp[i][j][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= k ; i ++)&#123;<br>ans = <span class="hljs-built_in">max</span>(ans, dp[n][i][<span class="hljs-number">0</span>]);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="股票买卖-v">1058 股票买卖 V</h1><p>给定一支股票在第 i 天的价格。每天可以买入/卖出该支股票。</p><p>不限制交易次数，但卖出股票后，你无法在第二天买入股票 (即冷冻期为 11天)</p><h2 id="题解-2">题解</h2><p>状态机模型可以用下面这张图来表示：</p><figure><img src="/competition/acwing-advance/AcWing-DP-4/55909_f22fdff4db-IMG_5D88B9FE2880-1.jpeg" alt="1058"><figcaption aria-hidden="true">1058</figcaption></figure><p>图片来源：<a href="https://www.acwing.com/solution/content/55147/">AcWing 1058.股票买卖 V【线性DP+状态机模型DP+滚动数组优化】 - AcWing</a></p><p>状态转移方程： <span class="math display">\[\begin{cases}dp[i][0] = max(dp[i-1][0], dp[i-1][2]) \\dp[i][1] = max(dp[i-1][1], dp[i-1][0] - p[i]) \\dp[i][2] = dp[i-1][1] + p[i]\end{cases}\]</span> i - 考虑到第i天；0 - 不持有股票；1 - 持有股票；2 - 冷冻期</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxk = <span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> n, p[maxn], dp[maxn][<span class="hljs-number">3</span>]; <br><span class="hljs-comment">// 0-不持有股票；1-持有股票；2-冷冻期</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;p[i];<br>&#125;<br><span class="hljs-built_in">memset</span>(dp,-inf,<span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]);<br>dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] - p[i]);<br>dp[i][<span class="hljs-number">2</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + p[i];<br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[n][<span class="hljs-number">0</span>],dp[n][<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="设计密码">1052 设计密码</h1><p>你现在需要设计一个密码 S：</p><ul><li>S 的长度是 N；</li><li>S 只包含小写英文字母；</li><li>S 不包含子串 T；</li></ul><p>现在给定S的长度n和子串T，请问共有多少种不同的密码满足要求？请输出答案模109+7的余数。</p><h2 id="题解-3">题解</h2><p>这道题使用KMP匹配构建状态机模型：</p><p>设子串长度为m，则有m个状态，每个状态表示匹配到子串的第 j个位置。【为了得到不存在子串的方案数，只考虑状态1-m-1】。每次根据字符（a-z）使用Next数组的匹配结果，可以得到下一个状态。</p><figure><img src="/competition/acwing-advance/AcWing-DP-4/42785_1db05bda4b-7FDF0E458B0E28FD2BA8FB09F9497B8F.jpg" alt="1052"><figcaption aria-hidden="true">1052</figcaption></figure><p>题解图片来源：<a href="https://www.acwing.com/solution/content/28022/">AcWing 1052.设计密码 - AcWing</a></p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> Next[maxn];<br><span class="hljs-type">int</span> n,m,ans,dp[maxn][maxn];<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span>&#123;<br>Next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j<span class="hljs-number">+1</span>])&#123;j = Next[j];&#125;<br><span class="hljs-keyword">if</span>(s[i] == s[j<span class="hljs-number">+1</span>])&#123;j++;&#125;<br>Next[i] = j;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;s;<br>m = s.<span class="hljs-built_in">length</span>();<br>s = <span class="hljs-string">&quot; &quot;</span> + s;<br><span class="hljs-built_in">getNext</span>();<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span> ; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span> ; c ++)&#123;<br><span class="hljs-type">int</span> u = j;<br><span class="hljs-keyword">while</span>(u &gt; <span class="hljs-number">0</span> &amp;&amp; c != s[u<span class="hljs-number">+1</span>])&#123;u = Next[u];&#125;<br><span class="hljs-keyword">if</span>(c == s[u<span class="hljs-number">+1</span>]) &#123;u++;&#125;<br><span class="hljs-keyword">if</span>(u &lt; m) dp[i<span class="hljs-number">+1</span>][u] = (dp[i<span class="hljs-number">+1</span>][u] + dp[i][j]) % mod;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br>ans = (ans + dp[n][i]) % mod;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法提高课：动态规划3-背包模型</title>
    <link href="/competition/acwing-advance/AcWing-DP-3/"/>
    <url>/competition/acwing-advance/AcWing-DP-3/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://www.acwing.com/problem/content/description/425/">423. 采药- AcWing题库</a>：01背包模板题-1</p><p><a href="https://www.acwing.com/problem/content/428/">426. 开心的金明- AcWing题库</a>：01背包模板题-2</p><p><a href="https://www.acwing.com/problem/content/1026/">1024. 装箱问题- AcWing题库</a>：01背包变形，只给体积，求占用背包空间的最大值</p><p><a href="https://www.acwing.com/problem/content/280/">278. 数字组合 -AcWing题库</a>：求体积恰好为m的01背包方案数</p><p><a href="https://www.acwing.com/problem/content/1025/">1023. 买书 -AcWing题库</a>：体积恰好为m的01背包方案数（完全背包）-1</p><p><a href="https://www.acwing.com/problem/content/1023/">1021. 货币系统- AcWing题库</a>：体积恰好为m的01背包方案数（完全背包）-2</p><p><a href="https://www.acwing.com/problem/content/534/">532. 货币系统 -AcWing题库</a>：完全背包，求解极大线性无关组</p><p><a href="https://www.acwing.com/problem/content/1021/">1019. 庆功会 -AcWing题库</a>：多重背包的二进制优化</p><p><a href="https://www.acwing.com/problem/content/6/">6. 多重背包问题III - AcWing题库</a>：多重背包的单调队列优化</p><p><a href="https://www.acwing.com/problem/content/7/">7. 混合背包问题 -AcWing题库</a>：混合背包 &lt;=&gt; 包含完全背包情况的多重背包</p><p><a href="https://www.acwing.com/problem/content/8/">8.二维费用的背包问题 - AcWing题库</a>：二维01背包</p><p><a href="https://www.acwing.com/problem/content/1024/">1022.宠物小精灵之收服 -AcWing题库</a>：二维01背包+输出最优解下的状态（条件2）</p><p><a href="https://www.acwing.com/problem/content/1022/">1020. 潜水员 -AcWing题库</a>：二维背包（至少大于n和m条件）</p><p><a href="https://www.acwing.com/problem/content/1015/">1013. 机器分配- AcWing题库</a>：分组背包问题+状态回溯</p><p><a href="https://www.acwing.com/problem/content/489/">487.金明的预算方案 - AcWing题库</a>：分组背包 + 二进制枚举分组内选择</p><p><a href="https://www.acwing.com/problem/content/10/">10.有依赖的背包问题 - AcWing题库</a>：树上背包</p><p><a href="https://www.acwing.com/problem/content/11/">11.背包问题求方案数 - AcWing题库</a>：01背包求最优解的方案数</p><p><a href="https://www.acwing.com/problem/content/12/">12.背包问题求具体方案 - AcWing题库</a>：01背包求字典序最小的具体方案</p><p><a href="https://www.acwing.com/problem/content/736/">734. 能量石 -AcWing题库</a>：01背包 + 贪心[邻项交换]（价值随时间减少）</p><h1 id="采药">423 采药</h1><p>给n个物品，每个物品有对应的体积和价值，求不超过背包体积m，最多获得的价值。</p><h2 id="题解">题解</h2><p>01背包模板题</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2000</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> w[maxn],v[maxn];<br><span class="hljs-type">int</span> dp[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i]&gt;&gt;v[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i] ; j --)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-w[i]] + v[i]);<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="开心的金明">426 开心的金明</h1><p>给n个物品，每个物品有对应的价格和重要度，其价值 = 价格*重要度。</p><p>求不超过背包体积m的前提下，最多获得的价值。</p><h2 id="题解-1">题解</h2><p>01背包模板题。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">30050</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> dp[maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> v,p;<br>cin&gt;&gt;v&gt;&gt;p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= v ; j --)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-v] + v*p);<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="装箱问题">1024 装箱问题</h1><p>有一个箱子容量为 V，同时有 n个物品，每个物品有一个体积（正整数）。</p><p>要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</p><h2 id="题解-2">题解</h2><p>给n个不同体积的物品，放到总体积为m的箱子里，求最多占满的体积。</p><p>这里将初始值dp[0]设置为true，其他设置为false。</p><p>递归后可以知道：是否能填充到体积j（dp[j] == true）。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">20050</span>;<br><br><span class="hljs-type">int</span> n,m,ans,w[maxn];<br><span class="hljs-type">bool</span> dp[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i];<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i] ; j --)&#123;<br>dp[j] = dp[j] | dp[j-w[i]];<br><span class="hljs-keyword">if</span>(dp[j]) ans = <span class="hljs-built_in">max</span>(ans, j);<br>&#125;<br>&#125;<br>cout&lt;&lt;m-ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数字组合">278 数字组合</h1><p>给定 N 个正整数 A1,A2,…,AN，从中选出若干个数，使它们的和为M，求有多少种选择方案。</p><h2 id="题解-3">题解</h2><p>模板题 01背包求方案数</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">10050</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> dp[maxm],a[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= a[i] ; j --)&#123;<br>dp[j] = dp[j] + dp[j-a[i]];<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="买书">1023 买书</h1><p>小明手里有n元钱全部用来买书，书的价格为10元，20元，50元，100元。</p><p>问小明有多少种买书方案？（每种书可购买多本）</p><h2 id="题解-4">题解</h2><p>每种书可购买多本，意味着这是多重背包问题；</p><p>此外，注意这里题目说需要把n元钱花光，全部用来买书，所以0元的方案数为1，需要特判。</p><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>],dp[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>; a[<span class="hljs-number">2</span>] = <span class="hljs-number">20</span>; a[<span class="hljs-number">3</span>] = <span class="hljs-number">50</span>; a[<span class="hljs-number">4</span>] = <span class="hljs-number">100</span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">4</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = a[i] ; j &lt;= n ; j ++)&#123;<br>dp[j] = dp[j] + dp[j-a[i]];<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[n];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="货币系统">1021 货币系统</h1><p>给你一个n种面值的货币系统，求组成面值为m的货币有多少种方案。</p><h2 id="题解-5">题解</h2><p>多重01背包的方案数问题；</p><p>注意：这题结果数值较大，需要开Long Long；</p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> ll maxn = <span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> ll maxm = <span class="hljs-number">3050</span>;<br><br>ll n,m;<br>ll a[maxn],dp[maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = a[i] ; j &lt;= m ; j ++)&#123;<br>dp[j] = dp[j] + dp[j-a[i]];<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="货币系统-1">523 货币系统</h1><p>共有 n 种不同面额的货币，第 i 种货币的面额为 a[i]，每一种货币都有无穷多张。</p><p>两个货币系统 (n,a)和 (m,b)是等价的，当且仅当对于任意非负整数 x，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 </p><p>他们希望找到一个货币系统 (m,b)，满足 (m,b) 与原来的货币系统 (n,a)等价，且 m尽可能的小。</p><h2 id="题解-6">题解</h2><p>要求这道题的解，首先要知道极大线性无关组的概念：<a href="https://zh.wikipedia.org/wiki/最大線性無關組">最大线性无关组 -维基百科，自由的百科全书</a></p><p>货币系统<span class="math inline">\((n,a)\)</span> ,如果存在<span class="math inline">\(a_j\)</span>可以被<span class="math inline">\(a\)</span>中其他的向量 线性表出： <span class="math display">\[a_j=\sum_{i\neq j}c_ia_i\]</span></p><p>则 <span class="math inline">\(a_j\)</span> 在这个货币系统中是 无效的(所有线性表示中需要用到<span class="math inline">\(a_j\)</span>的项，都可以用<span class="math inline">\(\sum_i\neq jc_ia_i\)</span> 代替)因此，我们需要求出 货币系统<span class="math inline">\((n,a)\)</span>的最大无关向量组，即任意<span class="math inline">\(a_i\)</span>都不能被其他向量 线性表出</p><p>由此，我们知道<span class="math inline">\((m,b)\)</span>就是<span class="math inline">\((n,a)\)</span>的极大线性无关组，使用完全背包模型，删去能用其他货币线性表示的无效货币，即可得到结果。</p><p><strong>注意</strong>：这里需要进行排序，因为大面值的货币必须由小面值的货币组成。</p><h2 id="代码-6">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> t,n,m,a[maxn];<br><span class="hljs-type">bool</span> dp[maxn*<span class="hljs-number">25000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>m = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>m = <span class="hljs-built_in">max</span>(a[i],m);<br>&#125;<br><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a<span class="hljs-number">+1</span>+n);<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> res = n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(dp[a[i]])&#123;<br>res--;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = a[i] ; j &lt;= m ; j ++)&#123;<br>dp[j] = dp[j] | dp[j-a[i]];<br>&#125;<br>&#125;<br>cout&lt;&lt;res&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="庆功会">1019 庆功会</h1><p>班主任决定开一场庆功会，为此拨款购买奖品犒劳运动员。每个奖品有对应的价格、价值（价格与价值是不同的概念）和能购买的最大数量（买0件到s件均可）。</p><p>给定拨款金额，求能买的最大价值。</p><h2 id="题解-7">题解</h2><p>二进制优化的多重背包</p><h2 id="代码-7">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">6050</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> dp[maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> w,v,s;<br>cin&gt;&gt;w&gt;&gt;v&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; s &gt; k ; s -= k, k += k)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= k*w ; j --)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-k*w] + k*v);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= s*w ; j --)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-s*w] + s*v);<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多重背包问题-iii">6 多重背包问题 III</h1><p>有<span class="math inline">\(N\)</span>种物品和一个容量是<span class="math inline">\(V\)</span>的背包，第<span class="math inline">\(i\)</span>种物品最多有<span class="math inline">\(s_i\)</span>件，</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</p><h2 id="题解-8">题解</h2><p>参考：<a href="https://www.acwing.com/solution/content/53507/">AcWing6. 多重背包问题 III【单调队列优化+图示】 - AcWing</a></p><h2 id="代码-8">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1050</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">20050</span>;<br><br><span class="hljs-type">int</span> n,m,tt,hh;<br><span class="hljs-type">int</span> w[maxn],v[maxn],s[maxn],q[maxm];<br><span class="hljs-type">int</span> dp[maxn][maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i]&gt;&gt;v[i]&gt;&gt;s[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span> ; r &lt; w[i] ; r ++)&#123;<br>hh = <span class="hljs-number">0</span>;tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = r ; j &lt;= m ; j += w[i])&#123;<br><span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; j - q[hh] &gt; s[i]*w[i]) hh++;<br><span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; dp[i<span class="hljs-number">-1</span>][q[tt]] + (j-q[tt])/w[i]*v[i] &lt; dp[i<span class="hljs-number">-1</span>][j]) tt--;<br>q[++tt] = j;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][q[hh]] + (j-q[hh])/w[i]*v[i];<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[n][m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="混合背包问题">7 混合背包问题</h1><p>有 N 种物品和一个容量是 V 的背包。物品一共有三类：</p><ul><li>第一类物品只能用1次（01背包）；</li><li>第二类物品可以用无限次（完全背包）；</li><li>第三类物品最多只能用 <span class="math inline">\(s_i\)</span>次（多重背包）；</li></ul><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</p><h2 id="题解-9">题解</h2><p>01背包的情况可以当作 S == 1情况下的多重背包；</p><p>完全背包的情况，需要进行特判。</p><h2 id="代码-9">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">6050</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> dp[maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> w,v,s;<br>cin&gt;&gt;w&gt;&gt;v&gt;&gt;s;<br><span class="hljs-comment">// 完全背包</span><br><span class="hljs-keyword">if</span>(s == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = w; j &lt;= m ; j ++)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-w] + v);<br>&#125;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 多重背包</span><br><span class="hljs-keyword">if</span>(s == <span class="hljs-number">-1</span>) s = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; s &gt; k ; s -= k, k += k)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= k*w ; j --)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-k*w] + k*v);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= s*w ; j --)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-s*w] + s*v);<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维费用背包问题">8 二维费用背包问题</h1><p>有<span class="math inline">\(N\)</span>件物品和一个容量是<span class="math inline">\(V\)</span>的背包，背包能承受的最大重量是<span class="math inline">\(M\)</span> 。每件物品只能用一次。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量。</p><h2 id="题解-10">题解</h2><p>相比普通的01背包，增加一个维度的状态，需要用二维数组存储，增加一层循环。</p><h2 id="代码-10">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxt = <span class="hljs-number">200</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">200</span>;<br><br><span class="hljs-type">int</span> n,t,m;<br><span class="hljs-type">int</span> dp[maxt][maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;t&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> vo,w,v;<br>cin&gt;&gt;vo&gt;&gt;w&gt;&gt;v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t ; j &gt;= vo ; j --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = m ; k &gt;= w ; k --)&#123;<br>dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j-vo][k-w] + v);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[t][m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="宠物小精灵之收服">1022 宠物小精灵之收服</h1><p>小智捕捉每个不同的精灵需要一定数量的精灵球，并消耗皮卡丘的体力值。他的目标是捕捉尽量多的精灵球。求最多捕捉的精灵数 和 在该前提下最多剩余的体力。</p><h2 id="题解-11">题解</h2><p>多条件的二维背包问题：精灵球和体力值分别代表dp值的两个状态，精灵数就是dp值。</p><p>满足二维背包条件的最优解可能有多个，这题要求我们分析在这些最优解（精灵数量最多）的状态，得到另一个解（精灵数量最多的情况下，最少消耗的体力为多少）。</p><h2 id="代码-11">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> c[maxn],d[maxn],dp[maxn][maxn];<br><span class="hljs-type">int</span> ans1,ans2;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br>cin&gt;&gt;c[i]&gt;&gt;d[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n ; j &gt;= c[i] ; j --)&#123;<br><span class="hljs-comment">// 题目：使皮卡丘体力小于等于0的野生小精灵也不会被小智收服。</span><br><span class="hljs-comment">// 所以这里r的最大值是m-1，不能取到m</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = m<span class="hljs-number">-1</span> ; r &gt;= d[i] ; r --)&#123; <br>dp[j][r] = <span class="hljs-built_in">max</span>(dp[j][r], dp[j-c[i]][r-d[i]] + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(dp[j][r] &gt; ans1)&#123;<br>ans1 = dp[j][r];<br><span class="hljs-comment">//ans2 = r;</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j][r] == ans1)&#123;<br><span class="hljs-comment">//ans2 = min(ans2,r);</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// ans1 也可以单独求解</span><br><span class="hljs-comment">// 即找到所有满足最优解的状态中，受到伤害最少的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= m<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(dp[n][i] == ans1)&#123;<br>ans2 = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;m-ans2;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="潜水员">1020 潜水员</h1><p>潜水员下潜的深度需要各种数量的氧和氮。</p><p>潜水员有一定数量的气缸，每个气缸都有重量和两种的气体容量。</p><p>求最少需要的气缸重量。</p><h2 id="题解-12">题解</h2><p>这里把氧气、氮气需求当作dp的两个状态，求<strong>至少</strong>满足这两个需求量下的<strong>最少</strong>气缸容量。</p><h2 id="代码-12">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> n,m,k,dp[maxn][maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-built_in">memset</span>(dp,inf,<span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br><span class="hljs-type">int</span> a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = m ; r &gt;= <span class="hljs-number">0</span> ; r --)&#123;<br>dp[j][r] = <span class="hljs-built_in">min</span>(dp[j][r], dp[<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,j-a)][<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,r-b)] + c);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[n][m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="机器分配">1013 机器分配</h1><p>一共有M台相同的设备，准备分给下属的 N 个分公司。</p><p>现在，给定矩阵N*M，表示给 第 i 个 公司分配 j个机器时的盈利，求最大总盈利。</p><h2 id="题解-13">题解</h2><p>相当于是分组背包问题，我们为每个公司选择一个方案；</p><p>每个公司的状态只能从上一个公司转移过来；</p><p>最后，用dfs回溯状态；</p><p>注意：不是多重背包问题，因为对于每个公司而言，题目只给了几个机器累计的盈利，方案无法叠加。</p><h2 id="代码-13">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> b[maxn][maxm],dp[maxn][maxm],ans[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">0</span> ; t &lt;= j ; t ++)&#123;<br><span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j-t] + b[i][t] == dp[i][j])&#123;<br>ans[i] = t;<br><span class="hljs-built_in">dfs</span>(i<span class="hljs-number">-1</span>,j-t);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;b[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span> ; r &lt;= j ; r ++)&#123;<br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j-r] + b[i][r], dp[i][j]);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[n][m]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">dfs</span>(n,m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="金明的预算方案">487 金明的预算方案</h1><p>现在有M元钱和N个物品，如果要买归类为附件的物品，必须先买该附件所属的主件。</p><figure><img src="/competition/acwing-advance/AcWing-DP-3/19_45c6dcea44-QQ截图20190313024710.png" alt="table"><figcaption aria-hidden="true">table</figcaption></figure><p>每个主件可以有0-2个附件，<strong>附件不再有从属于自己的附件</strong>。</p><p>现在给定每个物品的价格w和价值v，要求最多获得物品的总价值。</p><h2 id="题解-14">题解</h2><p>这题如果用树上DP的模板求解，处理每个节点的时间复杂度为<span class="math inline">\(O(M*M)\)</span>，总的时间复杂度约为<span class="math inline">\(O(N*M*M)\)</span>，因为M &lt;=32000，所以会超时。</p><p>注意到，每个附件不再有从属于自己的附件，且&lt;=2个，因此，我们可以将每个主件及其附件看作是一个分组，优化为分组背包问题。分组背包+ 二进制优化枚举 的总时间复杂度为<span class="math inline">\(O(N_{分组数}*M)\)</span>，不会超时。</p><h2 id="代码-14">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">40000</span>;<br><br><span class="hljs-type">int</span> n,m,f;<br><span class="hljs-type">int</span> w[maxn],v[maxn],dp[maxm];<br><span class="hljs-type">bool</span> nd[maxn];<br>vector&lt;<span class="hljs-type">int</span> &gt; g[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i]&gt;&gt;v[i]&gt;&gt;f;<br>v[i] = w[i]*v[i];<br><span class="hljs-keyword">if</span>(f != <span class="hljs-number">0</span>) g[f].<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">else</span> nd[i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 若没有父节点，则为主件</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br><span class="hljs-keyword">if</span>(!nd[i]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 若不是主件，则跳过</span><br><span class="hljs-type">int</span> siz = g[i].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 二进制枚举分组内的每一个选择，并更新DP状态</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span> ; s &lt; (<span class="hljs-number">1</span>&lt;&lt;siz) ; s ++)&#123;<br><span class="hljs-type">int</span> v_sum = v[i];<br><span class="hljs-type">int</span> w_sum = w[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">0</span> ; t &lt; siz ; t ++)&#123;<br><span class="hljs-keyword">if</span>((s&gt;&gt;t) &amp; <span class="hljs-number">1</span>)&#123;<br>v_sum += v[g[i][t]];<br>w_sum += w[g[i][t]];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(j &gt;= w_sum) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-w_sum] + v_sum);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="有依赖的背包问题">10 有依赖的背包问题</h1><p>有 N 个物品和一个容量是 V 的背包。</p><p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p><p>如下图所示： <img src="/competition/acwing-advance/AcWing-DP-3/1_bb51ecbcd2-QQ图片20181018170337.png" alt="tree"></p><p>将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大？输出最大价值。</p><h2 id="题解-15">题解</h2><p><a href="https://chenzhiwei.me/动态规划/树形DP/#树上背包">树形DP -陈志伟的个人博客</a></p><h2 id="代码-15">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> w[maxn],v[maxn],dp[maxn][maxm],p,r;<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-built_in">dfs</span>(it);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; j-k &gt;= w[x]; k ++)&#123;<br>dp[x][j] = <span class="hljs-built_in">max</span>(dp[x][j], dp[x][j-k] + dp[it][k]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i]&gt;&gt;v[i]&gt;&gt;p;<br><span class="hljs-keyword">if</span>(p != <span class="hljs-number">-1</span>) e[p].<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">else</span> r = i;<br>        <span class="hljs-comment">// 注意这里的初始化 不能只是 dp[i][w[i]] = v[i];</span><br>        <span class="hljs-comment">// 而是要将w[i] - m 置为 v[i]</span><br>        <span class="hljs-comment">// 否则，若有m剩余，则dp[r][m]不是最优解</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = w[i] ; j &lt;= m ; j ++)&#123;<br>dp[i][j] = v[i];<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(r);<br>cout&lt;&lt;dp[r][m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="背包问题求方案数">11 背包问题求方案数</h1><p>在01背包的基础上，要求输出<strong>最优解的方案数</strong>（答案需要模 109+7）。</p><h2 id="题解-16">题解</h2><p>为了求解最优解的方案数（区分同数值的不同下标），我们需要设置一个<span class="math inline">\(cnt[i][j]\)</span>数组来记录：</p><p>考虑前1-i 个物品，背包容量为j时最优解（<span class="math inline">\(dp[i][j]\)</span>）的方案数。</p><p>这里的cnt数组需要进行初始化。<span class="math inline">\(cnt[0][j]\)</span>表示考虑0个物品的最优解方案数，此时无论背包容量j为多少，方案树都为1。</p><ul><li>这里的cnt和dp一样，也可以进行一维数组的优化。</li></ul><h2 id="代码-16">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> dp[maxm],cnt[maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= m ; i ++)&#123;<br>cnt[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> w,v; cin&gt;&gt;w&gt;&gt;v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w ; j --)&#123;<br><span class="hljs-keyword">if</span>(dp[j-w] + v &gt; dp[j])&#123;<br>dp[j] = dp[j-w] + v;<br>cnt[j] = cnt[j-w]; <span class="hljs-comment">//拿</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j-w] + v == dp[j])&#123;<br>cnt[j] = (cnt[j] + cnt[j-w])%mod; <span class="hljs-comment">// 拿+不拿</span><br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;cnt[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="背包问题求具体方案">12 背包问题求具体方案</h1><p>在01背包的基础上，要求输出<strong>字典序最小的最优方案</strong>。</p><p>这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是1…N。</p><h2 id="题解-17">题解</h2><p>为了输出01背包最优解的方案，我们需要在DP的状态转移进行回溯；</p><p>每个DP状态对应一个决策：对物品i 选/不选；</p><p>但是，当我们从1-N进行DP转移后，我们只能从后向前进行回溯，无法得到字典序最小的方案；</p><p>字典序最小要求：对物品1-N 从前往后 进行决策，若选/不选都能到达最优解，那么优先选。</p><p>因此，我们需要设置<span class="math inline">\(dp[i][j]\)</span>为考虑n-i个物品，容量为j时的最大价值。</p><p>最后，进行回溯得到路径即可。</p><h2 id="代码-17">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1050</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> dp[maxn][maxm],w[maxn],v[maxn];<br>vector&lt;<span class="hljs-type">int</span> &gt; path;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br><span class="hljs-keyword">if</span>(i == n<span class="hljs-number">+1</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(j &gt;= w[i] &amp;&amp; dp[i][j] == dp[i<span class="hljs-number">+1</span>][j-w[i]] + v[i])&#123;<br>path.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">dfs</span>(i<span class="hljs-number">+1</span>,j-w[i]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">dfs</span>(i<span class="hljs-number">+1</span>,j);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i]&gt;&gt;v[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br><span class="hljs-keyword">if</span>(j &gt;= w[i]) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">+1</span>][j], dp[i<span class="hljs-number">+1</span>][j-w[i]] + v[i]);<br><span class="hljs-keyword">else</span> dp[i][j] = dp[i<span class="hljs-number">+1</span>][j];<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,m);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : path)&#123;<br>cout&lt;&lt;it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="能量石">734 能量石</h1><p>吃完第 i 块能量石需要花费的时间为 Si 秒。第 i 块能量石最初包含 Ei单位的能量，并且每秒将失去 Li 单位的能量。能量石中包含的能量最多降低至0。开始吃一块能量石时，他就会立即获得该能量石所含的全部能量。</p><p>吃能量石可以获得的最大能量是多少？</p><h2 id="题解-18">题解</h2><p>我们先假设一个较小的贪心问题：</p><p>若只有2个能量石A,B，那么应该先吃哪个？当满足下面这个式子时，先吃A更优，因为总损失更小。<span class="math display">\[A + B - A.w*B.l &gt; B + A - B.w*A \\\]</span> 即： <span class="math display">\[A.w*B.l &lt; B.w*A\]</span> 同理，不满足时，先吃B更优。</p><p>对应n个能量石，就是多个该子问题的重叠。我们使用该规则进行排序，可以得到吃能量石的优先级。</p><p>最后，根据这个顺序进行01背包的求解即可。</p><h2 id="代码-18">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">1e4</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stone</span>&#123;<br><span class="hljs-type">int</span> w,v,l;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> stone &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> w*rhs.l &lt; rhs.w*l;<br>&#125;<br>&#125;s[maxn];<br><br><span class="hljs-type">int</span> dp[maxm];<br><span class="hljs-type">int</span> t,n,ans,sum;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span></span>&#123;<br>ans = sum = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;s[i].w&gt;&gt;s[i].v&gt;&gt;s[i].l;<br>sum += s[i].w;<br>&#125;<br><span class="hljs-built_in">sort</span>(s<span class="hljs-number">+1</span>,s<span class="hljs-number">+1</span>+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br><span class="hljs-type">int</span> now_v = s[i].v - s[i].l*(j-s[i].w);<br><span class="hljs-keyword">if</span>(j &gt;= s[i].w &amp;&amp; now_v &gt;= <span class="hljs-number">0</span>)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-s[i].w] + now_v);<br>&#125;<br>ans = <span class="hljs-built_in">max</span>(dp[j],ans);<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Case #&quot;</span>&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= t ; i ++)&#123;<br><span class="hljs-built_in">solve</span>(i);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法提高课：动态规划2-最长上升子序列</title>
    <link href="/competition/acwing-advance/AcWing-DP-2/"/>
    <url>/competition/acwing-advance/AcWing-DP-2/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://www.acwing.com/problem/content/897/">895.最长上升子序列 - AcWing题库</a>：LIS模板题（DP）（O(N^2)）</p><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/4423/">896.最长上升子序列 II - AcWing题库</a>：LIS模板题（贪心 +二分）O(N*LogN)</p><p><a href="https://www.acwing.com/problem/content/1019/">1017.怪盗基德的滑翔翼 - AcWing题库</a>：LIS二次遍历，求max（上升，下降）</p><p><a href="https://www.acwing.com/problem/content/1016/">1014. 登山 -AcWing题库</a>：求 先上升再下降 的最大长度</p><p><a href="https://www.acwing.com/problem/content/484/">482. 合唱队形 -AcWing题库</a>:1014的变形，求最少删去多少个数，可以构成先上升再下降的序列</p><p><a href="https://www.acwing.com/problem/content/1014/">1012. 友好城市- AcWing题库</a>：两个序列的LIS，一个作为下标，一个作为数值</p><p><a href="https://www.acwing.com/problem/content/1018/">1016.最大上升子序列和 - AcWing题库</a>：求最大和，只需要将 dp[j] + 1 改为dp[j] + a[i](注意最大和长度可能为1)</p><p><a href="https://www.acwing.com/problem/content/1012/">1010. 拦截导弹- AcWing题库</a>：覆盖整个序列的最少的不上升子序列的个数 ==最长上升子序列的长度</p><p><a href="https://www.acwing.com/problem/content/189/">187.导弹防御系统 - AcWing题库</a>：覆盖整个序列的最少的子序列个数（上升 或下降）的个数 -&gt; DFS</p><p><a href="https://www.acwing.com/problem/content/274/">272.最长公共上升子序列 -AcWing题库</a>：LCIS模板题，O(N^2)解法，前缀最大值优化</p><h1 id="题谱">题谱</h1><figure><img src="/competition/acwing-advance/AcWing-DP-2/image-20250203105357988.png" alt="image-20250203105357988"><figcaption aria-hidden="true">image-20250203105357988</figcaption></figure><h1 id="最长上升子序列">895 最长上升子序列</h1><p>给定一个长度为 N的数列，求数值严格单调递增的子序列的长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含整数 N。</p><p>第二行包含 N个整数，表示完整序列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p>1≤N≤1000 −109≤数列中的数≤109</p><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>动态规划O(N^2)</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e4</span>;<br><br><span class="hljs-type">int</span> n,res;<br><span class="hljs-type">int</span> a[maxn],dp[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123;<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;res<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最长上升子序列-ii">896 最长上升子序列 II</h1><p>给定一个长度为 N的数列，求数值严格单调递增的子序列的长度最长是多少。</p><p><strong>输入格式</strong></p><p>第一行包含整数 N。</p><p>第二行包含 N 个整数，表示完整序列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大长度。</p><p><strong>数据范围</strong></p><p>1≤N≤100000 −10^9≤数列中的数≤10^9</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="题解-1">题解</h2><p>二分+贪心O(N*logN)</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e4</span>;<br><br><span class="hljs-type">int</span> n,cnt;<br><span class="hljs-type">int</span> low[maxn],a[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(low[mid] &lt; x)&#123;<br>l = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>r = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>low[++cnt] = a[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; low[cnt])&#123;<br>low[++cnt] = a[i];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//int j = lower_bound(low+1,low+cnt+1,a[i]) - low;</span><br><span class="hljs-type">int</span> j = <span class="hljs-built_in">binarySearch</span>(<span class="hljs-number">0</span>, cnt, a[i]);<br>low[j] = a[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;cnt;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="怪盗基德的滑翔翼">1017 怪盗基德的滑翔翼</h1><p>怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。</p><p>而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于操作的滑翔翼。</p><p>有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装置也被柯南踢出的足球破坏了。</p><p>不得已，怪盗基德只能操作受损的滑翔翼逃脱。</p><p>假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。</p><p>初始时，怪盗基德可以在任何一幢建筑的顶端。</p><p>他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。</p><p>因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。</p><p>他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。</p><p>请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？</p><p><strong>输入格式</strong></p><p>输入数据第一行是一个整数K，代表有K组测试数据。</p><p>每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。</p><p><strong>输出格式</strong></p><p>对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。</p><p><strong>数据范围</strong></p><p>1≤K≤100 1≤N≤100 0&lt;h&lt;10000</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-number">8</span><br><span class="hljs-symbol">300 </span><span class="hljs-number">207</span> <span class="hljs-number">155</span> <span class="hljs-number">299</span> <span class="hljs-number">298</span> <span class="hljs-number">170</span> <span class="hljs-number">158</span> <span class="hljs-number">65</span><br><span class="hljs-number">8</span><br><span class="hljs-symbol">65 </span><span class="hljs-number">158</span> <span class="hljs-number">170</span> <span class="hljs-number">298</span> <span class="hljs-number">299</span> <span class="hljs-number">155</span> <span class="hljs-number">207</span> <span class="hljs-number">300</span><br><span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>6<br>9<br></code></pre></td></tr></table></figure><h2 id="题解-2">题解</h2><p>怪盗基德可以从左到右滑行，也可以从右到左滑行。基德每次滑行必须严格下降，求最大长度。</p><p>相当于计算 Max( 最长上升子序列长度，最长下降子序列长度）。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><br><span class="hljs-type">int</span> t,n,res;<br><span class="hljs-type">int</span> a[maxn],dp[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>res = <span class="hljs-number">0</span>;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123;<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &lt; a[j])&#123;<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;res<span class="hljs-number">+1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="登山">1014 登山</h1><p>五一到了，ACM队组织大家去登山观光，队员们发现山上一共有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。</p><p>同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。</p><p>队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？</p><p><strong>输入格式</strong></p><p>第一行包含整数N，表示景点数量。</p><p>第二行包含N个整数，表示每个景点的海拔。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最多能浏览的景点数。</p><p><strong>数据范围</strong></p><p>2≤N≤1000</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">186 </span><span class="hljs-number">186</span> <span class="hljs-number">150</span> <span class="hljs-number">200</span> <span class="hljs-number">160</span> <span class="hljs-number">130</span> <span class="hljs-number">197</span> <span class="hljs-number">220</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="题解-3">题解</h2><p>登山队先上山后下山，且海拔必须严格上升和下降。</p><p>本质是 求 先上升后下降的最大序列长度。因此，我们从左到右遍历一次上升序列，在从右到左遍历一次下降序列。</p><p>dp1[i] + 1 表示从1到i的最大长度，dp2[i] + 1表示从n到i的最大长度。</p><p>res = max(res, dp1[i] + dp2[i] + 1)</p><p>此处不是+2，而是+1，是因为要减去重合点 i。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2000</span>;<br><br><span class="hljs-type">int</span> n,res;<br><span class="hljs-type">int</span> a[maxn],dp1[maxn],dp2[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123;<br>dp1[i] = <span class="hljs-built_in">max</span>(dp1[i],dp1[j]<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span> ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n ; j &gt;= i<span class="hljs-number">+1</span> ; j --)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123;<br>dp2[i] = <span class="hljs-built_in">max</span>(dp2[i], dp2[j]<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>res = <span class="hljs-built_in">max</span>(res,dp1[i]+dp2[i]);<br>&#125;<br>cout&lt;&lt;res<span class="hljs-number">+1</span>; <span class="hljs-comment">// res + 1 + 1 - 1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="合唱队形">482 合唱队形</h1><p>NN 位同学站成一排，音乐老师要请其中的 (N−K)(N−K)位同学出列，使得剩下的 KK 位同学排成合唱队形。     </p><p>合唱队形是指这样的一种队形：设 KK 位同学从左到右依次编号为1，2…，K他们的身高分别为 T1，T2，…，TK 则他们的身高满足T1&lt;…<Ti>Ti+1&gt;…&gt;TK(1≤i≤K)   </Ti></p><p>你的任务是，已知所有 N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。</p><p><strong>输入格式</strong></p><p>输入的第一行是一个整数 N，表示同学的总数。</p><p>第二行有 N 个整数，用空格分隔，第 i个整数 Ti 是第 i位同学的身高(厘米)。</p><p><strong>输出格式</strong></p><p>输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。</p><p><strong>数据范围</strong></p><p>2≤N≤100 130≤Ti≤230</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">186 </span><span class="hljs-number">186</span> <span class="hljs-number">150</span> <span class="hljs-number">200</span> <span class="hljs-number">160</span> <span class="hljs-number">130</span> <span class="hljs-number">197</span> <span class="hljs-number">220</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="题解-4">题解</h2><p>这题和1014类似，问最少需要多少人出队，其实就是在问最多剩下多少人。</p><p>这个问题和1014相同，使用总数减去结果即可。</p><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><br><span class="hljs-type">int</span> n,res;<br><span class="hljs-type">int</span> a[maxn],dp1[maxn],dp2[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123;<br>dp1[i] = <span class="hljs-built_in">max</span>(dp1[i],dp1[j]<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span> ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n ; j &gt;= i<span class="hljs-number">+1</span> ; j --)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123;<br>dp2[i] = <span class="hljs-built_in">max</span>(dp2[i], dp2[j]<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>res = <span class="hljs-built_in">max</span>(res,dp1[i]+dp2[i]);<br>&#125;<br>cout&lt;&lt;n-(res<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="友好城市">1012 友好城市</h1><p>Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。</p><p>北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。</p><p>每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。</p><p>编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量多。</p><p><strong>输入格式</strong></p><p>第1行，一个整数N，表示城市数。</p><p>第2行到第n+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。</p><p><strong>输出格式</strong></p><p>仅一行，输出一个整数，表示政府所能批准的最多申请数。</p><p><strong>数据范围</strong></p><p>1≤N≤500 0≤xi≤10000</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">22 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">12</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">17 </span><span class="hljs-number">17</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="题解-5">题解</h2><p>在河的南北两岸分别有n队友好城市，每对友好城市可以修建桥梁。现在给定每对城市的坐标，求最大桥梁数量。这里只需要用北岸城市坐标排序，并将南岸城市的坐标当作数值，求最长上升子序列即可。</p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e4</span>;<br><br><span class="hljs-type">int</span> n,res;<br><span class="hljs-type">int</span> dp[maxn];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">city</span>&#123;<br><span class="hljs-type">int</span> a,b;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> city &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> a &lt; rhs.a;<br>&#125;<br>&#125;c[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;c[i].a&gt;&gt;c[i].b;<br>&#125;<br><span class="hljs-built_in">sort</span>(c<span class="hljs-number">+1</span>,c+n<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(c[i].b &gt; c[j].b)&#123;<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j]<span class="hljs-number">+1</span>);<br>res = <span class="hljs-built_in">max</span>(dp[i],res);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;res<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最大上升子序列和">1016 最大上升子序列和</h1><p>一个数的序列 bi，当 b1&lt;b2&lt;…&lt;bS的时候，我们称这个序列是上升的。</p><p>对于给定的一个序列(a1,a2,…,aN)，我们可以得到一些上升的子序列(ai1,ai2,…,aiK)，这里1≤i1&lt;i2&lt;…&lt;iK≤N</p><p>比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7),(3,4,8)等等。</p><p>这些子序列中和最大为18，为子序列(1,3,5,9)的和。</p><p>你的任务，就是对于给定的序列，求出最大上升子序列和。</p><p>注意，最长的上升子序列的和不一定是最大的，比如序列(100,1,2,3)的最大上升子序列和为100，而最长上升子序列为(1,2,3)。</p><p><strong>输入格式</strong></p><p>输入的第一行是序列的长度N。</p><p>第二行给出序列中的N个整数，这些整数的取值范围都在0到10000(可能重复)。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大上升子序列和。</p><p><strong>数据范围</strong></p><p>1≤N≤1000</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">18<br></code></pre></td></tr></table></figure><h2 id="题解-6">题解</h2><p>求最大长度：dp[i] = max(dp[i], dp[j] + 1);</p><p>求最大和：dp[i] = max(dp[i], dp[j] + a[i]);</p><ul><li>注意需要考虑 长度为1的最大值，例如：100 1 2 3</li></ul><h2 id="代码-6">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2000</span>;<br><br><span class="hljs-type">int</span> n,res;<br><span class="hljs-type">int</span> a[maxn],dp[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>dp[i] = a[i];<br>res = <span class="hljs-built_in">max</span>(dp[i], res);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123;<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + a[i]);<br>res = <span class="hljs-built_in">max</span>(dp[i], res);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;res;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拦截导弹">1010 拦截导弹</h1><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。</p><p>但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。</p><p>某天，雷达捕捉到敌国的导弹来袭。</p><p>由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p><p>输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p><p><strong>输入格式</strong></p><p>共一行，输入导弹依次飞来的高度。</p><p><strong>输出格式</strong></p><p>第一行包含一个整数，表示最多能拦截的导弹数。</p><p>第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。</p><p><strong>数据范围</strong></p><p>雷达给出的高度数据是不大于 30000 的正整数，导弹数不超过 1000。</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">389 </span><span class="hljs-number">207</span> <span class="hljs-number">155</span> <span class="hljs-number">300</span> <span class="hljs-number">299</span> <span class="hljs-number">170</span> <span class="hljs-number">158</span> <span class="hljs-number">65</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>2<br></code></pre></td></tr></table></figure><h2 id="题解-7">题解</h2><p>求解这道题的关键在于下面这个性质 <span class="math display">\[覆盖整个序列的最少的不上升子序列的个数 == 最长上升子序列的长度\]</span> 所以，这题的第二问可以转化为：求最长上升子序列的长度。</p><p>证明：<a href="https://www.acwing.com/solution/content/52042/">AcWing1010. 拦截导弹【附贪心证明】 - AcWing</a></p><h2 id="代码-7">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2000</span>;<br><br><span class="hljs-comment">// a -- 高度</span><br><span class="hljs-comment">// dp1 -- [1,i]最大上升长度</span><br><span class="hljs-comment">// dp2 -- [1,i]最少需要的拦截系统</span><br><span class="hljs-type">int</span> a[maxn],dp1[maxn],dp2[maxn];<br><span class="hljs-type">int</span> n,res,cnt;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;a[n<span class="hljs-number">+1</span>])&#123;n++;&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &lt;= a[j]) dp1[i] = <span class="hljs-built_in">max</span>(dp1[i], dp1[j] + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span> dp2[i] = <span class="hljs-built_in">max</span>(dp2[i], dp2[j]<span class="hljs-number">+1</span>); <br>            <span class="hljs-comment">// 若a[i] &gt; a[j], 说明需要一个新的拦截系统，才能容纳这个数。</span><br>            <span class="hljs-comment">// 所以dp2[i]需要和dp[j]+1取最值，进行状态更新</span><br>            <span class="hljs-comment">// 若a[i] &lt;= a[j], 则之前的拦截系统就可以拦截这个数</span><br>            <span class="hljs-comment">// 所以dp2[i]只需要和dp[j]取最值，但dp[j]已经被cnt考虑过了，所以不需要再更新。</span><br>res = <span class="hljs-built_in">max</span>(dp1[i],res);<br>cnt = <span class="hljs-built_in">max</span>(dp2[i],cnt);<br>&#125;<br>&#125;<br>cout&lt;&lt;res<span class="hljs-number">+1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;cnt<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="导弹防御系统">187 导弹防御系统</h1><p>为了对抗附近恶意国家的威胁，RR 国更新了他们的导弹防御系统。</p><p>一套防御系统的导弹拦截高度要么一直 <strong>严格单调</strong>上升要么一直 <strong>严格单调</strong> 下降。</p><p>例如，一套系统先后拦截了高度为 3 和高度为 4的两发导弹，那么接下来该系统就只能拦截高度大于 4的导弹。</p><p>给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。</p><p><strong>输入格式</strong></p><p>输入包含多组测试用例。</p><p>对于每个测试用例，第一行包含整数 n，表示来袭导弹数量。</p><p>第二行包含 n 个<strong>不同的</strong>整数，表示每个导弹的高度。</p><p>当输入测试用例 n=0 时，表示输入终止，且该用例无需处理。</p><p><strong>输出格式</strong></p><p>对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。</p><p><strong>数据范围</strong></p><p>1≤n≤501≤n≤50</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p><strong>样例解释</strong></p><p>对于给出样例，最少需要两套防御系统。</p><p>一套击落高度为 3,43,4 的导弹，另一套击落高度为 5,2,15,2,1的导弹。</p><h2 id="题解-8">题解</h2><p>这题需要使用dfs求解。</p><p>首先，使用up和down数组分别保存当前所有的上升/下降序列的末尾值</p><p>然后，从d=1到d=n依次处理每个数，每次处理考虑四种情况：</p><p>1）插入已存在的上升序列；</p><p>2）创建并插入新的上升序列；</p><p>3）插入已存在的下降序列中；</p><p>4）创建一个新下降序列；</p><p>最后，使用全局的ans剪枝，考虑所有情况后，得到最优解。</p><h2 id="代码-8">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> a[maxn],up[maxn],down[maxn];<br><br><span class="hljs-comment">// d - 处理到第几个数</span><br><span class="hljs-comment">// u - 当前需要多少个上升系统</span><br><span class="hljs-comment">// v - 当前需要多少个下降系统</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br><span class="hljs-keyword">if</span>(u+v &gt;= ans) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(d == n<span class="hljs-number">+1</span>)&#123;<br>ans = <span class="hljs-built_in">min</span>(ans, u+v);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 尝试放入上升系统中</span><br><span class="hljs-comment">// up数组是从大到小排序的，找到第一个&lt;a[d]的即是最优的</span><br><span class="hljs-type">int</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= u ; i++)&#123;<br><span class="hljs-keyword">if</span>(a[d] &gt; up[i])&#123;<br>f = i;<br><span class="hljs-type">int</span> t = up[i];<br>up[i] = a[d];<br><span class="hljs-built_in">dfs</span>(d<span class="hljs-number">+1</span>,u,v);<br>up[i] = t;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(f == <span class="hljs-number">0</span>)&#123;<br>up[u<span class="hljs-number">+1</span>] = a[d];<br><span class="hljs-built_in">dfs</span>(d<span class="hljs-number">+1</span>,u<span class="hljs-number">+1</span>,v);<br>&#125;<br><span class="hljs-comment">// 尝试放入下降系统中，同理</span><br>f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= v ; i++)&#123;<br><span class="hljs-keyword">if</span>(a[d] &lt; down[i])&#123;<br>f = i;<br><span class="hljs-type">int</span> t = down[i];<br>down[i] = a[d];<br><span class="hljs-built_in">dfs</span>(d<span class="hljs-number">+1</span>,u,v);<br>down[i] = t;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(f == <span class="hljs-number">0</span>)&#123;<br>down[v<span class="hljs-number">+1</span>] = a[d];<br><span class="hljs-built_in">dfs</span>(d<span class="hljs-number">+1</span>,u,v<span class="hljs-number">+1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;n, n)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>ans = n;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最长公共上升子序列">272 最长公共上升子序列</h1><p>熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。</p><p>小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。</p><p>小沐沐说，对于两个数列 A 和B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。</p><p>奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。</p><p>不过，只要告诉奶牛它的长度就可以了。</p><p>数列 AA 和 BB 的长度均不超过 3000。</p><p><strong>输入格式</strong></p><p>第一行包含一个整数 N，表示数列 A，B 的长度。</p><p>第二行包含 N 个整数，表示数列 A。</p><p>第三行包含 N 个整数，表示数列 B。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最长公共上升子序列的长度。</p><p><strong>数据范围</strong></p><p>1≤N≤3000</p><p>序列中的数字均不超过 2^31−1。</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h2 id="题解-9">题解</h2><p>设dp[i][j]为：考虑从a的[1,i]区间 和b的[1,j]的区间，且以b[j]结尾的LCIS长度</p><p>更新dp[i][j]策略如下：</p><p>从小到大遍历每一个i和j，判断a[i]是否等于b[j]，</p><p>若a[i] != b[j]，则a[i]对LCIS的长度没有贡献，dp[i][j] =dp[i-1][j]；</p><p>若a[i] == b[j]，则往前遍历所有dp[i][k](k &lt; j &amp;&amp; a[i] &gt;b[k])，更新dp[i][j] 为 dp[i][k]+1的最大值；</p><p>最后，答案为dp[i][j]的最大值。</p><h2 id="代码-9">代码</h2><p>O(N^3)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">3050</span>;<br><br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> a[maxn],b[maxn],dp[maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;b[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] != b[j]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> maxv = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 注意到，这里的遍历是和i无关的，只和1-j有关</span><br>                <span class="hljs-comment">// 因此可以移到i层，进行优化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; k &lt;= j ; k ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; b[k])&#123;<br>maxv = <span class="hljs-built_in">max</span>(dp[i][k]<span class="hljs-number">+1</span>, maxv);<br>&#125;<br>&#125;<br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], maxv);<br>&#125;<br>ans = <span class="hljs-built_in">max</span>(dp[i][j],ans);<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>O(N^2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">3050</span>;<br><br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> a[maxn],b[maxn],dp[maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;b[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> maxv = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] != b[j]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br><span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], maxv);<br><span class="hljs-keyword">if</span>(a[i] &gt; b[j]) maxv = <span class="hljs-built_in">max</span>(maxv, dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>);<br>ans = <span class="hljs-built_in">max</span>(dp[i][j],ans);<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing算法提高课：动态规划1-数字三角形模型</title>
    <link href="/competition/acwing-advance/AcWing-DP-1/"/>
    <url>/competition/acwing-advance/AcWing-DP-1/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要">摘要</h1><p><a href="https://www.acwing.com/problem/content/1017/">1015. 摘花生 -AcWing题库</a>：模板题(下/右)</p><p><a href="https://www.acwing.com/problem/content/description/1020/">1018.最低通行费 - AcWing题库</a>：模板题条件变形（上/下/左/右，但步数 &lt;=2*n-1）</p><ul><li>由于这题求的是最小值，左上边界需要特定初始化，保证取某一边；求最大值的时候，虽然也规定必须是从左上角出发，但无需这么做，因为超出边界部分为0，不会被取。</li></ul><p><a href="https://www.acwing.com/problem/content/1029/">1027. 方格取数- AcWing题库</a>：先走到终点，再从终点走到起点的最大值 &lt;=&gt;2个人同时从起点走到终点。路径可以有重合，但是价值只能取一次。</p><p><a href="https://www.acwing.com/problem/content/description/277/">275.传纸条 -AcWing题库</a>：和1027类似，需要走两次。区别在于两次的路径不允许有重合点。</p><h1 id="摘花生">1015 摘花生</h1><p>Hello Kitty想摘点花生送给她喜欢的米老鼠。</p><p>她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。</p><p>地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。</p><p>Hello Kitty只能向东或向南走，不能向西或向北走。</p><p>问Hello Kitty最多能够摘到多少颗花生。</p><figure><img src="/competition/acwing-advance/AcWing-DP-1/19_a8509f26d5-1.gif" alt="1.gif"><figcaption aria-hidden="true">1.gif</figcaption></figure><p><strong>输入格式</strong></p><p>第一行是一个整数T，代表一共有多少组数据。</p><p>接下来是T组数据。</p><p>每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。</p><p>每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。</p><p><strong>输出格式</strong></p><p>对每组输入数据，输出一行，内容为HelloKitty能摘到得最多的花生颗数。</p><p><strong>数据范围</strong></p><p>1≤T≤1001≤T≤100, 1≤R,C≤1001≤R,C≤100, 0≤M≤10000≤M≤1000</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>16<br></code></pre></td></tr></table></figure><h2 id="题解">题解</h2><p>状态转移方程： <span class="math display">\[dp[i][j] = max(dp[i-1][j] + a[i][j], dp[i][j-1] + a[i][j])\]</span> 当前最大值 = max(从下到下的最大值，从左到右的最大值）</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><br><span class="hljs-type">int</span> t,n,m;<br><span class="hljs-type">int</span> dp[maxn][maxn],a[maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]) + a[i][j];<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[n][m]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最低通行费">1018 最低通行费</h1><p>一个商人穿过一个 N×N的正方形的网格，去参加一个非常重要的商务活动。</p><p>他要从网格的左上角进，右下角出。</p><p>每穿越中间 11 个小方格，都要花费 11 个单位时间。</p><p>商人必须在 (2N−1) 个单位时间穿越出去。</p><p>而在经过中间的每个小方格时，都需要缴纳一定的费用。</p><p>这个商人期望在规定时间内用最少费用穿越出去。</p><p>请问至少需要多少费用？</p><p>注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。</p><p><strong>输入格式</strong></p><p>第一行是一个整数，表示正方形的宽度 N。</p><p>后面 N 行，每行 N 个不大于 100100的正整数，为网格上每个小方格的费用。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示至少需要的费用。</p><p><strong>数据范围</strong></p><p>1≤N≤1001≤N≤100</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span> <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">8</span>  <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span> <span class="hljs-number">5</span>  <span class="hljs-number">7</span>  <span class="hljs-number">15</span> <span class="hljs-number">17</span><br><span class="hljs-symbol">6 </span> <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  <span class="hljs-number">18</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">19</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">20 </span><span class="hljs-number">23</span> <span class="hljs-number">25</span> <span class="hljs-number">29</span> <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">109<br></code></pre></td></tr></table></figure><p><strong>样例解释</strong></p><p>样例中，最小值为109=1+2+5+7+9+12+19+21+33109=1+2+5+7+9+12+19+21+33。</p><h2 id="题解-1">题解</h2><p>状态转移方程： <span class="math display">\[\begin{cases}dp[i][j] = dp[i][j-1] + a[i][j] &amp; i == 1\\dp[i][j] = dp[i-1][j] + a[i][j] &amp; j == 1 \\dp[i][j] = min(dp[i-1][j] + a[i][j], dp[i][j-1] + a[i][j]) &amp;  else\end{cases}\]</span> 当前最小值 = max(从下到下的最小值，从左到右的最小值）</p><p>注意：因为只能从左上角出发，所以左上边界需要特殊处理</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[maxn][maxn],dp[maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] + a[i][j];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">1</span>) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + a[i][j];<br><span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + a[i][j];<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[n][n];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方格取数">1027 方格取数</h1><p>设有 N×N的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：</p><figure><img src="/competition/acwing-advance/AcWing-DP-1/19_764ece6ed5-2.gif" alt="2.gif"><figcaption aria-hidden="true">2.gif</figcaption></figure><p>某人从图中的左上角 A出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。</p><p>在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。</p><p>此人从 A 点到 B点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。</p><p><strong>输入格式</strong></p><p>第一行为一个整数N，表示 N×N 的方格图。</p><p>接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。</p><p>行和列编号从 11 开始。</p><p>一行“0 0 0”表示结束。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示两条路径上取得的最大的和。</p><p><strong>数据范围</strong></p><p>N≤10N≤10</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">14</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">3</span> <span class="hljs-number">15</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">2</span> <span class="hljs-number">14</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">67<br></code></pre></td></tr></table></figure><h2 id="题解-2">题解</h2><p>先走到终点，再从终点走到起点的最大值 &lt;=&gt;2个人同时从起点走到终点</p><p>状态转移方程： <span class="math display">\[dp[k][i1][i2] = max(dp[k-1][i1][i2],dp[k-1][i1-1][i2],dp[k-1][i1][i2-1],dp[l-1][i1-1][i2-1]) + val\]</span> 此处k为两人同步走的步数（k == i +j），i和j分别为横纵坐标，val为当前值 <span class="math display">\[val = \begin{cases}a[i1][j1] &amp; {i1 == i2} \\a[i1][j1] + a[i2][j2] &amp; {i1 != i2}\end{cases}\]</span> 根据题意，若重合，需要删去其中一个。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">50</span>;<br><br><span class="hljs-type">int</span> a[maxn][maxn],dp[maxn][maxn][maxn];<br><span class="hljs-type">int</span> x,y,w,n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;x&gt;&gt;y&gt;&gt;w)&#123;<br><span class="hljs-keyword">if</span>(x+y+w == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>a[x][y] = w;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span> ; k &lt;= <span class="hljs-number">2</span>*n ; k ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span> ; i1 &lt; k ; i1 ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span> ; i2 &lt; k ; i2 ++)&#123;<br><span class="hljs-type">int</span> j1 = k - i1;<br><span class="hljs-type">int</span> j2 = k - i2;<br><span class="hljs-type">int</span> val = a[i1][j1];<br><span class="hljs-keyword">if</span>(i1 != i2) val += a[i2][j2];<br><span class="hljs-type">int</span> &amp; p = dp[k][i1][i2];<br>p = <span class="hljs-built_in">max</span>(p, dp[k<span class="hljs-number">-1</span>][i1<span class="hljs-number">-1</span>][i2<span class="hljs-number">-1</span>] + val);<br>p = <span class="hljs-built_in">max</span>(p, dp[k<span class="hljs-number">-1</span>][i1][i2] + val);<br>p = <span class="hljs-built_in">max</span>(p, dp[k<span class="hljs-number">-1</span>][i1<span class="hljs-number">-1</span>][i2] + val);<br>p = <span class="hljs-built_in">max</span>(p, dp[k<span class="hljs-number">-1</span>][i1][i2<span class="hljs-number">-1</span>] + val);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">2</span>*n][n][n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="传纸条">275 传纸条</h1><p>小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。</p><p>一次素质拓展活动中，班上同学安排坐成一个 m 行 n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。</p><p>幸运的是，他们可以通过传纸条来进行交流。</p><p>纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标 (m,n)。</p><p>从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 </p><p>在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。</p><p>班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙，反之亦然。 </p><p>还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0 表示），可以用一个 0∼100 的自然数来表示，数越大表示越好心。</p><p>小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。</p><p>现在，请你帮助小渊和小轩找到这样的两条路径。</p><p><strong>输入格式</strong></p><p>第一行有 2 个用空格隔开的整数 m 和 n，表示学生矩阵有 m 行 n列。</p><p>接下来的 m 行是一个 m×n 的矩阵，矩阵中第 i 行 j 列的整数表示坐在第 i行 j 列的学生的好心程度，每行的 n 个整数之间用空格隔开。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</p><p><strong>数据范围</strong></p><p>1≤n,m≤50</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">3</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">8</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">34<br></code></pre></td></tr></table></figure><h2 id="题解-3">题解</h2><p>和1027类似，需要走两次。区别在于两次的路径不允许有重合点。</p><p>状态转移方程： <span class="math display">\[dp[k][i1][i2] =\begin{cases}max(dp[k-1][i1][i2],dp[k-1][i1-1][i2],dp[k-1][i1][i2-1],dp[l-1][i1-1][i2-1]) + val &amp; i1!= i2 \\0 &amp; i1 == i2\end{cases}\]</span>因为此处不能重复，所以当点重合时，该状态不合法，直接置为0。</p><p>k为两人同步走的步数（k == i + j），i和j分别为横纵坐标，val值的定义为<span class="math display">\[val = \begin{cases}0 &amp; {i1 == i2} \\a[i1][j1] + a[i2][j2] &amp; {i1 != i2}\end{cases}\]</span></p><ul><li>这题也可以用和1027相同的代码求解：<a href="https://www.acwing.com/solution/content/12389/">AcWing 275.证明传纸条为何可以使用方格取数的代码 - AcWing</a></li></ul><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[maxn][maxn],dp[maxn*<span class="hljs-number">2</span>][maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">2</span> ; k &lt;= n+m ; k ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span> ; i1 &lt; k &amp;&amp; i1 &lt;= n ; i1 ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i2 = <span class="hljs-number">1</span> ; i2 &lt; k &amp;&amp; i2 &lt;= n; i2 ++)&#123;<br><span class="hljs-keyword">if</span>(i1 == i2 &amp;&amp; k != n+m) <span class="hljs-keyword">continue</span>;<br><span class="hljs-type">int</span> j1 = k - i1;<br><span class="hljs-type">int</span> j2 = k - i2;<br><span class="hljs-type">int</span> val = a[i1][j1] + a[i2][j2];<br><span class="hljs-type">int</span> &amp;p = dp[k][i1][i2];<br>p = <span class="hljs-built_in">max</span>(p, dp[k<span class="hljs-number">-1</span>][i1][i2] + val);<br>p = <span class="hljs-built_in">max</span>(p, dp[k<span class="hljs-number">-1</span>][i1<span class="hljs-number">-1</span>][i2] + val);<br>p = <span class="hljs-built_in">max</span>(p, dp[k<span class="hljs-number">-1</span>][i1][i2<span class="hljs-number">-1</span>] + val);<br>p = <span class="hljs-built_in">max</span>(p, dp[k<span class="hljs-number">-1</span>][i1<span class="hljs-number">-1</span>][i2<span class="hljs-number">-1</span>] + val);<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[n+m][n][n];<br>    <span class="hljs-comment">// 注意此处不是输出dp[n+m][n][m],因为都是i1,i2都是纵坐标</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>AcWing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序开发</title>
    <link href="/other/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/other/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="文件目录结构">文件目录结构</h1><p>1）app</p><p>app.js ：小程序的入口</p><p>app.json ：小程序的全局配置</p><p>app.wxss/scss ：小程序全局样式</p><p>2）pages</p><p>pages文件夹包含多个页面文件夹。每个文件夹包含4类文件，</p><p>对于页面index来说，有：</p><p>index.js ：页面逻辑</p><p>index.json：页面配置</p><p>index.wxss/scss：页面样式</p><p>index.wxml：页面结构</p><p>3）其他</p><p>project.config.json ：项目公共配置</p><p>project.private.config.json：项目个人配置</p><p>sitemap.json：设置是否允许被微信索引</p><h1 id="全局配置-app.json">全局配置-app.json</h1><p>主要包括3个常见的配置项目：pages 、window 、tabbar</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">//pages页面，设置小程序的页面，写完自动创建文件夹</span><br>    <span class="hljs-attr">&quot;pages&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;pages/cate/cate&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;pages/cart/cart&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;pages/profile/profile&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;pages/index/index&quot;</span><br>    <span class="hljs-punctuation">]</span><br>    <span class="hljs-comment">//pages中的第一项自动成为小程序的首页</span><br>    <span class="hljs-comment">//但是也可以通过entryPagePath强制设置首页</span><br>    <span class="hljs-attr">&quot;entryPagePath&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;pages/page_2/page_2&quot;</span><span class="hljs-punctuation">,</span><br>    <br>    <span class="hljs-comment">//window用于设置小程序的状态栏、顶部导航条、上滑窗口、主页面</span><br>   <span class="hljs-attr">&quot;window&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">//设置顶部导航条的标题</span><br>      <span class="hljs-attr">&quot;navigationBarTitleText&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;导航条标题&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">//设置顶部导航条背景色</span><br>      <span class="hljs-attr">&quot;navigationBarBackgroundColor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#f3514f&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">//是否允许下拉刷新</span><br>      <span class="hljs-attr">&quot;enablePullDownRefresh&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">//这里的背景指的是下拉后的显示窗格</span><br>      <span class="hljs-comment">//设置背景的颜色</span><br>      <span class="hljs-attr">&quot;backgroundColor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#efefef&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">//设置刷新点的样式，light/dark</span><br>      <span class="hljs-attr">&quot;backgroundTextStyle&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;dark&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <br>  <span class="hljs-comment">//设置底部导航栏</span><br>   <span class="hljs-attr">&quot;tabBar&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;selectedColor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#f3514f&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//被选择时的文本颜色</span><br>    <span class="hljs-attr">&quot;color&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;#666&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//未被选择时的文本颜色</span><br>    <span class="hljs-attr">&quot;list&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span> <span class="hljs-comment">//至少需要2个</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;首页&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//名称</span><br>        <span class="hljs-attr">&quot;pagePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pages/index/index&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//页面路径</span><br>        <span class="hljs-attr">&quot;iconPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/images/tabbar/index.png&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//没选择的图标</span><br>        <span class="hljs-attr">&quot;selectedIconPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/images/tabbar/index-active.png&quot;</span> <span class="hljs-comment">//选择后的图标</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;购物车&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;pagePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pages/cart/cart&quot;</span><span class="hljs-punctuation">,</span> <br>        <span class="hljs-attr">&quot;iconPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/images/tabbar/cart.png&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;selectedIconPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/images/tabbar/cart-active.png&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;分类&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;pagePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pages/cate/cate&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;iconPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/images/tabbar/cate.png&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;selectedIconPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/images/tabbar/cate-active.png&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;我的&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;pagePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pages/profile/profile&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;iconPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/images/tabbar/profile.png&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;selectedIconPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/images/tabbar/profile-active.png&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="页面配置-page.json">页面配置-page.json</h1><p>当前页面配置若设置了和全局配置，会覆盖全局配置，否则沿用全局设置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;usingComponents&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;navigationBarTitleText&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;商品分类&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;navigationBarBackgroundColor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#00AF92&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;enablePullDownRefresh&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="页面结构-page.wxml">页面结构-page.wxml</h1><p>wxml是小程序中用来编写页面结构的文件格式。</p><p>wxml提供了view、image、text、navigator等标签，在小程序中也称标签为组件</p><ul><li><p>什么是rpx？</p><p>由于不同手机像素尺寸不同，为了适配不同的手机页面，微信提供了rpx来代替px（像素）。</p><p>无论任何手机，宽度都为750rpx</p></li><li><p>如何配置sass格式？</p><p>在project.config.json里的setting增加一行如下代码，然后把所有wxss文件后缀名改为scss</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;setting&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;useCompilerPlugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;sass&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h2 id="view组件page组件">1）view组件/page组件</h2><p>wxml就是由各种组件层层嵌套形成的，由此构成页面。</p><p>我们使用view组件包裹其他组件，形成块状结构，而整个页面又被一个page组件包裹。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//在scss重设置page的属性</span><br><span class="hljs-attribute">page</span>&#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>; <span class="hljs-comment">//填充100%的高度</span><br>  <span class="hljs-attribute">background-color</span>: lightgreen; <span class="hljs-comment">//背景色为浅绿</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="swiper组件-轮播图">2）swiper组件-轮播图</h2><p>swiper-item是轮播图组件swiper中的一个子页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--轮播图--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;swiper-container&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--提取scss文件中的swiper-container类--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">swiper</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">autoplay</span> = <span class="hljs-string">&quot;true&quot;</span> //<span class="hljs-attr">是否自动切换</span></span><br><span class="hljs-tag">    <span class="hljs-attr">interval</span> = <span class="hljs-string">&quot;2000&quot;</span> //<span class="hljs-attr">切换间隔ms</span></span><br><span class="hljs-tag">    <span class="hljs-attr">indicator-dots</span> = <span class="hljs-string">&quot;true&quot;</span>//<span class="hljs-attr">是否显示dots</span></span><br><span class="hljs-tag">    <span class="hljs-attr">circular</span> = <span class="hljs-string">&quot;true&quot;</span> //<span class="hljs-attr">最后一格是否向右切换</span></span><br><span class="hljs-tag">    <span class="hljs-attr">indicator-color</span>=<span class="hljs-string">&quot;#efefef&quot;</span> //<span class="hljs-attr">设置dots颜色</span></span><br><span class="hljs-tag">    <span class="hljs-attr">indicator-active-color</span>=<span class="hljs-string">&quot;#f3514f&quot;</span>&gt;</span><br>      <br>    <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span>first-item<span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span>second-item<span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span>third-item<span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span><br>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应的scss：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.swiper-container</span>&#123;<br>  swiper&#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">360</span>rpx; <span class="hljs-comment">//高度</span><br>    <span class="hljs-attribute">background-color</span>:white;<span class="hljs-comment">//背景颜色</span><br>    swiper-item&#123;<br>      &amp;<span class="hljs-selector-pseudo">:first-child</span>&#123;<br>        <span class="hljs-attribute">background-color</span>: yellow;<span class="hljs-comment">//背景颜色</span><br>        <span class="hljs-selector-tag">text</span>-align:center; <span class="hljs-comment">//文本左右对齐</span><br>        <span class="hljs-selector-tag">line</span>-<span class="hljs-attribute">height</span>: <span class="hljs-number">180</span>rpx;<span class="hljs-comment">//行间距</span><br>      &#125;<br>      &amp;<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-attribute">background-color</span>: lightgreen;<br>        <span class="hljs-selector-tag">text</span>-align:center;<br>        <span class="hljs-selector-tag">line</span>-<span class="hljs-attribute">height</span>: <span class="hljs-number">180</span>rpx;<br>      &#125;<br>      &amp;<span class="hljs-selector-pseudo">:last-child</span>&#123;<br>        <span class="hljs-attribute">background-color</span>: skyblue;<br>        <span class="hljs-selector-tag">text</span>-align:center;<br>        <span class="hljs-selector-tag">line</span>-<span class="hljs-attribute">height</span>: <span class="hljs-number">180</span>rpx;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="image组件-图片">3）image组件-图片</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;/images/&quot;</span> //<span class="hljs-attr">文件路径</span></span><br><span class="hljs-tag">       <span class="hljs-attr">mode</span> = <span class="hljs-string">&quot;aspectfit&quot;</span> //<span class="hljs-attr">图片的裁切和缩放方式</span></span><br><span class="hljs-tag">       <span class="hljs-attr">show-menu-by-longpress</span> = <span class="hljs-string">&quot;true&quot;</span> //<span class="hljs-attr">长按图片加载菜单</span>（<span class="hljs-attr">收藏</span>、<span class="hljs-attr">保存</span>、<span class="hljs-attr">分享等</span>）</span><br><span class="hljs-tag">       <span class="hljs-attr">lazy-load</span> = <span class="hljs-string">&quot;true&quot;</span> //<span class="hljs-attr">懒加载</span>（<span class="hljs-attr">在滑动到该图片时</span>，<span class="hljs-attr">才加载该图片</span>）</span><br><span class="hljs-tag">       &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="text组件-文本">4）text组件-文本</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">user-select</span>=<span class="hljs-string">&quot;true&quot;</span> //<span class="hljs-attr">是否可被长按选取</span></span><br><span class="hljs-tag">      <span class="hljs-attr">space</span> = <span class="hljs-string">&quot;emsp&quot;</span> //<span class="hljs-attr">是否显示连续空格</span>，<span class="hljs-attr">以及空格格式</span>(<span class="hljs-attr">emsp</span> <span class="hljs-attr">-</span> <span class="hljs-attr">中文空格</span>，<span class="hljs-attr">ensp</span> <span class="hljs-attr">-</span> <span class="hljs-attr">英文空格</span>)</span><br><span class="hljs-tag">      &gt;</span><br>hello world<br><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="navigator组件-跳转">5）navigator组件-跳转</h2><p>在必要时，使用navigator组件包裹其他组件，例如imgae和text，可以实现单击跳转功能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">navigator</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;/pages/index/index&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">oepn-type</span> = <span class="hljs-string">&quot;switchTab&quot;</span></span><br><span class="hljs-tag">           // <span class="hljs-attr">open-type说明</span>：</span><br><span class="hljs-tag">           // <span class="hljs-attr">navigate</span> <span class="hljs-attr">----</span> <span class="hljs-attr">跳转后存在返回按钮</span>，<span class="hljs-attr">只能跳转到非tabbar页面</span></span><br><span class="hljs-tag">           // <span class="hljs-attr">redirect</span> <span class="hljs-attr">----</span> <span class="hljs-attr">跳转后无返回按钮</span>，<span class="hljs-attr">只能跳转到非tabbar页面</span></span><br><span class="hljs-tag">           // <span class="hljs-attr">switchTab</span> <span class="hljs-attr">----</span> <span class="hljs-attr">跳转到某个tabbar页面</span></span><br><span class="hljs-tag">           // <span class="hljs-attr">reLaunch</span> <span class="hljs-attr">----</span> <span class="hljs-attr">关闭所有页面</span>，<span class="hljs-attr">并打开某个页面</span></span><br><span class="hljs-tag">           // <span class="hljs-attr">nevigateBack</span> <span class="hljs-attr">----</span> <span class="hljs-attr">返回上一个页面</span></span><br><span class="hljs-tag">           // <span class="hljs-attr">若使用navigateBack属性</span>，<span class="hljs-attr">还可以设置</span> <span class="hljs-attr">delta</span> = <span class="hljs-string">&quot;数字&quot;</span> <span class="hljs-attr">来设置返回前n页</span></span><br><span class="hljs-tag">           &gt;</span><br>跳转到首页<br>    <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">...</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">...</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="scroll-view组件">6）scroll-view组件</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">scroll-view</span> <span class="hljs-attr">class</span> = <span class="hljs-string">&quot;scroll_container_x&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">scroll-x</span> = <span class="hljs-string">&quot;true&quot;</span> //<span class="hljs-attr">横线滑动</span></span><br><span class="hljs-tag">             //<span class="hljs-attr">或者scroll-y</span>，<span class="hljs-attr">可以实现纵向滑动</span></span><br><span class="hljs-tag">             &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">scroll-view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应的scss文件样式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.scroll_container_x</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">80</span>rpx;<br>  <span class="hljs-attribute">white-space</span>:nowrap;<br>  <span class="hljs-attribute">background-color</span> : white;<br>  view&#123;<br>    <span class="hljs-attribute">display</span>:inline-block;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">80</span>rpx;<br>    &amp;<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>)&#123;<br>      <span class="hljs-attribute">background-color</span>: blueviolet;<br>    &#125;<br>    &amp;<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>)&#123;<br>      <span class="hljs-attribute">background-color</span>: burlywood;<br>    &#125;<br>    &amp;<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>)&#123;<br>      <span class="hljs-attribute">background-color</span>: chartreuse;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="botton组件">7）botton组件</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;primary&quot;</span> // <span class="hljs-attr">按钮样式</span>，<span class="hljs-attr">比如</span> ：<span class="hljs-attr">warn</span> 、<span class="hljs-attr">default</span></span><br><span class="hljs-tag">        <span class="hljs-attr">bindtap</span> = <span class="hljs-string">&quot;handler&quot;</span> //<span class="hljs-attr">按下按钮后触发的函数</span>（<span class="hljs-attr">事件</span>），<span class="hljs-attr">定义在js文件中</span></span><br><span class="hljs-tag">        &gt;</span>按钮名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应的js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">page</span>([<br>...<br><span class="hljs-title function_">handler</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;handler事件被触发了&quot;</span>)<br>  &#125;,<br>...<br>])<br></code></pre></td></tr></table></figure><h2 id="input组件">8）input组件</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">bindinput</span> = <span class="hljs-string">&quot;getInputVal&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应的js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">page</span>([<br>...<br>  <span class="hljs-title function_">getInputVal</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>)<br>  &#125;,<br>...<br>])<br></code></pre></td></tr></table></figure><h1 id="事件系统-page.js">事件系统-page.js</h1><h2 id="事件冒泡">1）事件冒泡</h2><p>bind：tap会在该事件触发后，继续向上触发其父节点的事件，这被叫做“事件冒泡”。</p><p>如下，childTap事件触发后，parentTap事件也被触发。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">bind:tap</span> = <span class="hljs-string">&quot;parentTap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">botton</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">bind:tap</span> = <span class="hljs-string">&quot;childTap&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">botton</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>catch：tap不会向上冒泡。如果想阻止事件冒泡，可以将如上代码改为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">bind:tap</span> = <span class="hljs-string">&quot;parentTap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">botton</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attr">catch:tap</span> = <span class="hljs-string">&quot;childTap&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">botton</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="事件传参">2）事件传参</h2><p>在事件中，事件绑定者指的是绑定tap属性的组件，而事件触发者指的是触发tap的组件。使用currentTarget获得的是当前事件绑定者身上的数据，而使用target获得的是事件触发者身上的数据。</p><p>例如：</p><p>若此时按下按钮，view成为事件绑定者，button成为事件触发者。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">bind:tap</span> = <span class="hljs-string">&quot;handler&quot;</span> <span class="hljs-attr">data-id</span> = <span class="hljs-string">&quot;222&quot;</span> <span class="hljs-attr">data-name</span> = <span class="hljs-string">&quot;peter&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;primary&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">data-id</span> = <span class="hljs-string">&quot;111&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">data-name</span> = <span class="hljs-string">&quot;Tom&quot;</span> &gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">bind:tap</span> = <span class="hljs-string">&quot;handler&quot;</span> <span class="hljs-attr">mark:id</span> = <span class="hljs-string">&quot;222&quot;</span> <span class="hljs-attr">mark:name</span> = <span class="hljs-string">&quot;peter&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;primary&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">mark:id</span> = <span class="hljs-string">&quot;111&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">mark:name</span> = <span class="hljs-string">&quot;Tom&quot;</span> &gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js事件如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">...  <br><span class="hljs-title function_">handler</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">id</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">name</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">id</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">dataset</span>.<span class="hljs-property">name</span>);<br>  &#125;,<br>...<br><span class="hljs-comment">//console outcome:</span><br><span class="hljs-comment">//111</span><br><span class="hljs-comment">//Tom</span><br><span class="hljs-comment">//222</span><br><span class="hljs-comment">//peter</span><br></code></pre></td></tr></table></figure><p>另一种事件传参的方法是通过mark，获取事件触发者的数据</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">bind:tap</span> = <span class="hljs-string">&quot;handler&quot;</span> <span class="hljs-attr">mark:id</span> = <span class="hljs-string">&quot;222&quot;</span> <span class="hljs-attr">mark:name</span> = <span class="hljs-string">&quot;peter&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;primary&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">mark:id</span> = <span class="hljs-string">&quot;111&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">mark:name</span> = <span class="hljs-string">&quot;Tom&quot;</span> &gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br>  <span class="hljs-title function_">handler</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">mark</span>.<span class="hljs-property">id</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">mark</span>.<span class="hljs-property">name</span>);<br>  &#125;,<br>...<br><span class="hljs-comment">//console result:</span><br><span class="hljs-comment">//111</span><br><span class="hljs-comment">//Tom</span><br></code></pre></td></tr></table></figure><h2 id="数据声明和绑定">3）数据声明和绑定</h2><p>在js文件的中可以声明一些变量，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br>  <span class="hljs-attr">data</span>: &#123;<br>    id : <span class="hljs-string">&quot;1&quot;</span>,<br>    <span class="hljs-attr">obj</span>: &#123;<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;jim&quot;</span>,<br>      <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;18&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">ischecked</span>:<span class="hljs-literal">false</span>,<br>  &#125;,<br>...<br></code></pre></td></tr></table></figure><p>在wxml中使用特殊符号进行访问，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;obj.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;id*3 + 2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;ischecked === true ? &quot;yes&quot; : &quot;no&quot;&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="数据更新">4）数据更新</h2><p>直接在js中使用this.data.xxx的方式赋值，虽然可以修改数据，但是无法改变刷新页面上呈现的数据。若要实现后者，则需要使用this.setData()的方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;id&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;obj.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">botton</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">bind:tap</span> = <span class="hljs-string">&quot;handler&quot;</span>&gt;</span>更新名字为jackson<span class="hljs-tag">&lt;/<span class="hljs-name">botton</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">handler</span>(<span class="hljs-params">event</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">obj</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Wang&quot;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">id</span> += <span class="hljs-number">1</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;<br>    <span class="hljs-attr">obj</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;jackson&quot;</span>&#125;,<br>    id : <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">id</span> + <span class="hljs-number">1</span><br>  &#125;)<br></code></pre></td></tr></table></figure><p>每次按下按钮，页面上的id每次增加2，而name变为jackson。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面向对象思想</title>
    <link href="/other/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/"/>
    <url>/other/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="类class">类（class）</h1><p><strong>类的修饰符：</strong></p><p>-- public：公共类，无任何限制</p><p>-- static：抽象类，无法被实例化</p><p>-- final ：无法被继承</p><hr><p><strong>类成员的访问修饰符：</strong></p><p>-- default：被该类自身、同一个包中其他类</p><p>-- public：可以被所有类访问</p><p>-- private：只能被该类自身访问</p><p>-- protected：被该类自身、同个包中其他类、子类访问</p><p>-- private protected：被该类自身、子类访问</p><p><strong>类成员的非访问修饰符：</strong></p><p>--static：静态变量，独立于类，存在于整个程序运行的生命周期，可以在类未被实例化时访问</p><p>-- final：值无法被修改</p><p>-- volatile：可以被多个线程同时修改</p><h2 id="类的基本使用">1）类的基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以学生类为例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-comment">//私有变量</span><br>    <span class="hljs-keyword">private</span> String name, number;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> MathScore, ChineseScore, EnglishScore;<br>    <span class="hljs-comment">//公有函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PrintMessage</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Name : &quot;</span> + name);<br>        System.out.println(<span class="hljs-string">&quot;StuNumber : &quot;</span> + number);<br>        System.out.println(<span class="hljs-string">&quot;average score : &quot;</span> + <br>                           (MathScore + ChineseScore + EnglishScore)/<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-comment">//构造函数</span><br>    Student(<span class="hljs-keyword">final</span> String s1,<span class="hljs-keyword">final</span> String s2,<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> score1,<span class="hljs-keyword">final</span> <span class="hljs-type">double</span> score2,<span class="hljs-keyword">final</span> <span class="hljs-type">double</span> score3)&#123;<br>        <span class="hljs-built_in">this</span>.name = s1;<br>        <span class="hljs-built_in">this</span>.number = s2;<br>        <span class="hljs-built_in">this</span>.MathScore = score1;<br>        <span class="hljs-built_in">this</span>.ChineseScore = score2;<br>        <span class="hljs-built_in">this</span>.EnglishScore = score3;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>      <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;peter&quot;</span>,<span class="hljs-string">&quot;20070803&quot;</span>,<span class="hljs-number">83</span>,<span class="hljs-number">90</span>,<span class="hljs-number">60</span>);<br>      s.PrintMessage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态变量方法static">2）静态变量/方法（static）</h2><p>我们可以使用静态变量，继续完善1)中的学生类。我们建立一个total_num的静态变量，该变量属于整个学生群体。可以被实例化的类访问，也可以直接访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name, number;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> MathScore, ChineseScore, EnglishScore;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">total_num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PrintMessage</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Name : &quot;</span> + name);<br>        System.out.println(<span class="hljs-string">&quot;StuNumber : &quot;</span> + number);<br>        System.out.println(<span class="hljs-string">&quot;average score : &quot;</span> + (MathScore + ChineseScore + EnglishScore)/<span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;total_num : &quot;</span> + total_num);<br>    &#125;<br>    Student(<span class="hljs-keyword">final</span> String s1,<span class="hljs-keyword">final</span> String s2,<span class="hljs-keyword">final</span> <span class="hljs-type">double</span> score1,<span class="hljs-keyword">final</span> <span class="hljs-type">double</span> score2,<span class="hljs-keyword">final</span> <span class="hljs-type">double</span> score3)&#123;<br>        <span class="hljs-built_in">this</span>.name = s1;<br>        <span class="hljs-built_in">this</span>.number = s2;<br>        <span class="hljs-built_in">this</span>.MathScore = score1;<br>        <span class="hljs-built_in">this</span>.ChineseScore = score2;<br>        <span class="hljs-built_in">this</span>.EnglishScore = score3;<br>        total_num ++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>      <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Peter&quot;</span>,<span class="hljs-string">&quot;20070803&quot;</span>,<span class="hljs-number">83</span>,<span class="hljs-number">90</span>,<span class="hljs-number">60</span>);<br>      <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Jackson&quot;</span>,<span class="hljs-string">&quot;20140225&quot;</span>,<span class="hljs-number">80</span>,<span class="hljs-number">100</span>,<span class="hljs-number">78</span>);<br>      <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Lisa&quot;</span>,<span class="hljs-string">&quot;20021208&quot;</span>,<span class="hljs-number">99</span>,<span class="hljs-number">67</span>,<span class="hljs-number">89</span>);<br>      s3.PrintMessage();<br>      System.out.println(Student.total_num);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Name : Lisa</span><br><span class="hljs-comment">//StuNumber : 20021208</span><br><span class="hljs-comment">//average score : 85.0</span><br><span class="hljs-comment">//total_num : 3</span><br><span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><h2 id="抽象类abstract">3）抽象类（abstract）</h2><p>抽象类是含有抽象方法的类，使用abstract声明。</p><p>抽象类强调从属关系，接口强调特定功能的实现。继承抽象类 和 实现接口的类都必须描述所有未实现的功能。</p><p>抽象类与接口的具体区别：</p><p>A.接口只能有未实现的方法。而抽象类既能拥有普通的方法，又有抽象的方法，所以既能自己完成一些功能，又给子类提供可能性。</p><p>B.一个类可以实现多个接口，但只能继承一个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BasicSalory</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">salory</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">salory</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;Salory is &quot;</span> + <span class="hljs-number">5</span>*BasicSalory);&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">salory</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;Salory is &quot;</span> + <span class="hljs-number">3</span>*BasicSalory);&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String []args)</span>&#123;<br>        <span class="hljs-comment">// Employee t = new Employee(); //java: Employee是抽象的; 无法实例化</span><br>        <span class="hljs-comment">// t.salory();</span><br>        <span class="hljs-type">Worker</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();<br>        a.salory();<br>        <span class="hljs-type">Manager</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();<br>        b.salory();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="继承extends">继承（extends）</h1><p>Java使用extends实现单一继承（在java中多重继承是不被允许的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shape</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;shape drawed!&quot;</span>);&#125;;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">erase</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;shape erased!&quot;</span>);&#125;;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cricle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">shape</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;cricle drawed!&quot;</span>);&#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">erase</span><span class="hljs-params">()</span>&#123;System.out.println(<span class="hljs-string">&quot;cricle earsed!&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String arg[])</span>&#123;<br>        <span class="hljs-type">shape</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">shape</span>();<br>        s.draw();s.erase();<br>        s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">cricle</span>();<br>        s.draw();s.erase();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//shape drawed!</span><br><span class="hljs-comment">//shape erased!</span><br><span class="hljs-comment">//cricle drawed!</span><br><span class="hljs-comment">//cricle earsed!</span><br></code></pre></td></tr></table></figure><h1 id="包package">包（package）</h1><p>"包" 是java项中的用于存放各种类的文件夹。可以使用import语句引用或者直接引用。包的引用形式和文件夹路径是强联系的。</p><p>比如：我在src中创建一个shape文件夹，里面存放一个cricle类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> shape; <span class="hljs-comment">//使用package语句，声明在哪个包中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cricle</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cricle drawed!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">erase</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cricle erased!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时类的路径为“shape/cricle.class”，所以在主程序中使用shape.cricle来引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> shape.cricle;<span class="hljs-comment">//也可以使用shape.cricle来引用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String arg[])</span> &#123;<br>        <span class="hljs-type">cricle</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">cricle</span>();<br>        s.draw();<br>        s.erase();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//cricle drawed!</span><br><span class="hljs-comment">//cricle earsed!</span><br></code></pre></td></tr></table></figure><h1 id="接口interface">接口（interface）</h1><p>在java中，接口是抽象方法的集合。</p><p>接口的声明方法和类很相似，但接口只声明要实现的方法，和定义常量，不描述具体的属性和方法。</p><p>接口无法被实例化，但可以被类实现（implements）。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">volume</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;System.out.println(<span class="hljs-string">&quot;Add result: &quot;</span>+(x+y));&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">volume</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span>&#123;System.out.println(<span class="hljs-string">&quot;Volume result: &quot;</span>+(x*y*z));&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        Demo d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>();<br>        d.add(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br>        d.volume(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Add result: 30</span><br><span class="hljs-comment">//Volume result: 1000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/other/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/other/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进程线程多线程">进程、线程、多线程</h1><blockquote><p>一个进程可以包括多个线程，但是至少需要包含一个线程</p></blockquote><blockquote><p>线程是CPU执行的最小单位</p><p>对于单核CPU而言，一次只能执行一个线程</p><p>但是由于不同线程间切换速度极快，近似达到了同步执行的效果</p></blockquote><h1 id="线程创建">线程创建</h1><blockquote><p>创建Java的子线程有两种方法</p><p>1--继承Thread类</p><p>2--实现Runnable接口</p><p>3--实现callable接口（了解即可）</p><p>建议使用方法2，自定义类实现Runnable接口后便于被多个线程使用</p></blockquote><h2 id="继承thread类">继承Thread类</h2><p>STEP1：自定义类，继承Thread</p><p>STEP2：重写run方法，真正需要执行的程序放在run方法里</p><p>STEP3：创建STEP1中的自定义类，调用start方法，运行线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>().start(); <span class="hljs-comment">//创建子线程</span><br>        <span class="hljs-comment">//main线程输出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">20</span> ; i ++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;In main process:&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123; <span class="hljs-comment">//自定义MyThread类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//重写父类run方法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">20</span> ; i ++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;In Thread processs:&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出如下，由于两个线程的优先级相同，可以观察到CPU在不同线程间切换</span><br><span class="hljs-comment">//In Thread processs:0</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//In main process:0</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//In Thread processs:6</span><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><h2 id="实现runnable接口">实现Runnable接口</h2><p>STEP1：自定义类，实现runnable接口</p><p>STEP2：实现接口中的run方法，真正需要执行的程序放在run方法里</p><p>STEP3：使用STEP1中的自定义类来实例化Thread类，调用start方法，运行线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//子线程创建</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>()).start();<br>        <span class="hljs-comment">//主线程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">20</span> ; i ++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;In main process&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<span class="hljs-comment">//自定义MyRunable类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//实现run方法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">20</span> ; i ++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;In Thread processs:&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现callable接口">实现Callable接口</h2><p><a href="https://www.bilibili.com/video/BV1V4411p7EF?p=8&amp;vd_source=697f2e2d84a57722a7f31ac60acd742e">多线程08：实现Callable接口_哔哩哔哩_bilibili</a></p><h1 id="线程停止">线程停止</h1><p>JDK中提供的stop、destroy方法目前已经被废弃</p><p>目前主流的做法是设置一个变量，来控制线程的运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable,<span class="hljs-string">&quot;The thread&quot;</span>).start();<br>        <span class="hljs-keyword">try</span>&#123;<br>            Thread.sleep(<span class="hljs-number">3</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        myRunnable.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">alive</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(alive)&#123; <span class="hljs-comment">//方法写在while内部</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; is running...&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//线程终止函数</span><br>        alive = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程休眠">线程休眠</h1><blockquote><p>每一个对象都有一把锁，sleep不会释放锁</p></blockquote><p>使用Sleep实现简单的计时器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Clock</span>(),<span class="hljs-string">&quot;ClockCounter&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(cnt &lt; <span class="hljs-number">10</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//间隔一秒</span><br>            &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123; <span class="hljs-comment">//当休眠被打断时触发异常</span><br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;The Clock count =&gt; &quot;</span> + cnt);<br>            cnt++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程礼让">线程礼让</h1><p>礼让线程，就是让一个进程从运行状态重新变为就绪状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(),<span class="hljs-string">&quot;a&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(),<span class="hljs-string">&quot;b&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始执行&quot;</span>);<br>        Thread.<span class="hljs-keyword">yield</span>();<span class="hljs-comment">//线程礼让</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束执行&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//若不加礼让；</span><br><span class="hljs-comment">//a开始执行</span><br><span class="hljs-comment">//a结束执行</span><br><span class="hljs-comment">//b开始执行</span><br><span class="hljs-comment">//b结束执行</span><br><br><span class="hljs-comment">//若礼让：（也可能失败）</span><br><span class="hljs-comment">//a开始执行</span><br><span class="hljs-comment">//b开始执行</span><br><span class="hljs-comment">//a结束执行</span><br><span class="hljs-comment">//b结束执行</span><br></code></pre></td></tr></table></figure><h1 id="线程强制执行">线程强制执行</h1><p>join方法可以被理解成线程间的“插队”</p><p>调用该方法可以使得其他线程进入阻塞状态，优先执行某个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        thread.start();<span class="hljs-comment">//开启子线程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">100</span> ; i ++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Normal =&gt; &quot;</span> + i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>)&#123; <span class="hljs-comment">//vip通道插队</span><br>                thread.join();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">20</span> ; i ++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;VIP =&gt; &quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Normal =&gt; 1</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//Normal =&gt; 10</span><br><span class="hljs-comment">//VIP =&gt; 1</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//VIP =&gt; 20</span><br><span class="hljs-comment">//Normal =&gt; 11</span><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><h1 id="线程优先级">线程优先级</h1><p>线程优先级只能保证高优先级的线程优先被调用</p><p>但并不是一个严格保证，低优先级的线程仍有可能被提前调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(),<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.setPriority(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(),<span class="hljs-string">&quot;t1&quot;</span>);<br>        t2.setPriority(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>(),<span class="hljs-string">&quot;t1&quot;</span>);<br>        t3.setPriority(<span class="hljs-number">3</span>);<br>        <br>        t1.start();t2.start();t3.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>       System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;is running:&quot;</span> + Thread.currentThread().getPriority());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="守护线程">守护线程</h1><p>线程包括守护线程和用户线程</p><p>虚拟机运行在所有用户线程结束后即结束，不需要等待守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">god</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">God</span>());<br>        god.setDaemon(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置守护进程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">you</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">You</span>());<br>        you.setDaemon(<span class="hljs-literal">false</span>);<br>        god.start();<br>        you.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">God</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<span class="hljs-comment">//自身非终止，等待所有用户进程结束后才终止</span><br>            System.out.println(<span class="hljs-string">&quot;God bless you&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">You</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">36500</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;I am alive today&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----Goodbye world-----&quot;</span>);<span class="hljs-comment">//结束标识</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程同步">线程同步</h1><p>例1：售票机卖票问题</p><blockquote><p>三个售票机同时售票，两个售票机可能卖出同一张票，</p><p>原因是：因为一个售票机卖出票x时，另一个售票机不会等待其操作结束</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//模拟三个售票机同时卖票</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SellTicket</span>(),<span class="hljs-string">&quot;SellMachine_1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SellTicket</span>(),<span class="hljs-string">&quot;SellMachine_2&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SellTicket</span>(),<span class="hljs-string">&quot;SellMachine_3&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (ticketNum &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//模拟卖票过程</span><br>            <span class="hljs-keyword">try</span>&#123;  <span class="hljs-comment">//每次卖票，花费10ms（模拟延时，放大问题的发生性）</span><br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//由于没有加锁，导致可能卖出相同的票，或者出现负数</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; has selled ticket_&quot;</span> + (ticketNum--));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//SellMachine_3 has selled ticket_18</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//SellMachine_2 has selled ticket_18</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//SellMachine_1 has selled ticket_16</span><br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SellTicket</span> <span class="hljs-variable">sellTicket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SellTicket</span>();<span class="hljs-comment">//synchronized锁的是同一个实例,而不是一个类</span><br>        <span class="hljs-comment">//模拟三个售票机同时卖票</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sellTicket,<span class="hljs-string">&quot;SellMachine_1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sellTicket,<span class="hljs-string">&quot;SellMachine_2&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sellTicket,<span class="hljs-string">&quot;SellMachine_3&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticketNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">//不能直接锁run函数,否则一直等待同一台机器购票完毕</span><br>        <span class="hljs-comment">//显示一个机器开始卖票</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; start&quot;</span>);<br>        <span class="hljs-keyword">while</span> (flag)&#123;<span class="hljs-comment">//模拟卖票过程</span><br>            buy();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//直接对函数施加锁，此时锁的是this指向的实例</span><br>    <span class="hljs-comment">//加了锁以后,票依次卖出,哪个机器先买到票，取决于cpu如何分配</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(ticketNum &gt;= <span class="hljs-number">1</span>)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; has selled ticket_&quot;</span> + (ticketNum--));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">//终止程序</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例2：银行取钱问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <span class="hljs-comment">//新建银行账户</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">myBankAccount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-number">100</span>,<span class="hljs-string">&quot;Peter&#x27;s account&quot;</span>);<span class="hljs-comment">//创建账户</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Drawing</span>(myBankAccount,<span class="hljs-number">50</span>,<span class="hljs-string">&quot;Peter&quot;</span>).start();<span class="hljs-comment">//Peter取钱</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Drawing</span>(myBankAccount,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;girlfriend&quot;</span>).start();<span class="hljs-comment">//girlfriend取钱</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> money;<span class="hljs-comment">//账户余额</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//账户名</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">(<span class="hljs-type">int</span> money_,String name_)</span>&#123;<br>        <span class="hljs-built_in">this</span>.money = money_;<br>        <span class="hljs-built_in">this</span>.name = name_;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMoney</span><span class="hljs-params">(<span class="hljs-type">int</span> nowMoney)</span>&#123;<br>        money = nowMoney;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drawing</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    Account account;<span class="hljs-comment">//需要取钱的账户</span><br>    <span class="hljs-type">int</span> drawingMoney;<span class="hljs-comment">//需要取的钱</span><br>    String name;<span class="hljs-comment">//取钱的名称</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Drawing</span><span class="hljs-params">(Account account,<span class="hljs-type">int</span> drawingMoney,String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.account = account;<br>        <span class="hljs-built_in">this</span>.drawingMoney = drawingMoney;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//由于没有加锁，两次操作同时进行，导致余额变为负数</span><br>        <br>        <span class="hljs-keyword">if</span>(account.getMoney() &lt; drawingMoney)&#123;<br>            System.out.println(<span class="hljs-string">&quot;操作人 =&gt; &quot;</span> + name);<br>            System.out.println(<span class="hljs-string">&quot;错误 =&gt; 余额不足&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        account.setMoney(account.getMoney() - drawingMoney);<br>        System.out.println(<span class="hljs-string">&quot;操作人 =&gt; &quot;</span> + name);<br>        System.out.println(<span class="hljs-string">&quot;已成功取出 =&gt; &quot;</span> + drawingMoney);<br>        System.out.println(<span class="hljs-string">&quot;账户余额 =&gt; &quot;</span> + account.getMoney());<br>        System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drawing</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    Account account;<span class="hljs-comment">//需要取钱的账户</span><br>    <span class="hljs-type">int</span> drawingMoney;<span class="hljs-comment">//需要取的钱</span><br>    String name;<span class="hljs-comment">//取钱的名称</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Drawing</span><span class="hljs-params">(Account account,<span class="hljs-type">int</span> drawingMoney,String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.account = account;<br>        <span class="hljs-built_in">this</span>.drawingMoney = drawingMoney;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//此处使用synchronized锁住account，不能同时对同一个账户操作</span><br>        <span class="hljs-keyword">synchronized</span> (account)&#123; <span class="hljs-comment">//不能直接锁run函数，否则锁的是Drawing实例，无效</span><br>            <br>            <span class="hljs-keyword">if</span>(account.getMoney() &lt; drawingMoney)&#123;<br>                System.out.println(<span class="hljs-string">&quot;操作人 =&gt; &quot;</span> + name);<br>                System.out.println(<span class="hljs-string">&quot;错误 =&gt; 余额不足&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            account.setMoney(account.getMoney() - drawingMoney);<br>            System.out.println(<span class="hljs-string">&quot;操作人 =&gt; &quot;</span> + name);<br>            System.out.println(<span class="hljs-string">&quot;已成功取出 =&gt; &quot;</span> + drawingMoney);<br>            System.out.println(<span class="hljs-string">&quot;账户余额 =&gt; &quot;</span> + account.getMoney());<br>            System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础语法</title>
    <link href="/other/Java-basic/"/>
    <url>/other/Java-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是java">什么是JAVA</h1><h2 id="历史">历史</h2><p>​ Java源于上个世纪90年代<a href="https://en.wikipedia.org/wiki/James_Gosling">詹姆斯·高斯林</a>（高司令，Java之父）开发的Oak语言，最早的目标是针对小型家电设备的嵌入式应用。后来开发Oak的SUN公司被Oracle收购，Oak也改名为Java</p><h2 id="跨平台特性">跨平台特性</h2><p>​ Java介于编译型语言和解释型语言之间。</p><p>​----编译型语言如C、C++，代码是直接编译成机器码执行，需要为每一种平台的编译对应的机器码。</p><p>​----解释型语言如Python、Ruby，由解释器直接加载源码然后运行，代价是运行效率太低。</p><p>​----Java是将代码编译成一种“字节码”，类似于抽象的CPU指令。这种“字节码"需要开发者针对不同平台分别编写虚拟机来加载字节码并执行。</p><blockquote><p>源代码文件对应后缀.java</p><p>字节码文件对应后缀.class</p></blockquote><blockquote><p>$ javac对应编译命令----.java -&gt; .class</p><p>$ java对应运行命令----run .class</p></blockquote><h2 id="jvmjre与jdk">JVM、JRE与JDK</h2><p>​ JDK &gt;&gt; JRE &gt;&gt; JVM</p><p>​ ----JVM（Java Virtual Machine）即JAVA虚拟机</p><p>​ ----JRE（Java RuntimeEnvironment）不仅包括了JVM，还提供了编译器、调试器等开发工具，是将Java源码编译为Java字节码的运行环境</p><p>​ ----JDK（Java DevelopmentKit）包括了JVM和JRE，还提供了许多Java工具和基础类库</p><h2 id="三个版本">三个版本</h2><p>​ java具有三个版本</p><p>​ ----JAVA SE（标准版）：语言本身、核心开发技术、Java标准库</p><p>​ ----JAVA EE（企业版）：Spring框架、数据库开发、分布式架构</p><p>​ ----JAVA ME（嵌入式）：针对嵌入式设备</p><p>​ 从包含内容上看，EE &gt;&gt; SE &gt;&gt; ME</p><h1 id="java基础">Java基础</h1><h2 id="基本类型">1）基本类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">- 整数类型：<span class="hljs-type">byte</span>，<span class="hljs-type">short</span>，<span class="hljs-type">int</span>，<span class="hljs-type">long</span><br>- 浮点数类型：<span class="hljs-type">float</span>，<span class="hljs-type">double</span><br>- 字符类型：<span class="hljs-type">char</span><br>- 布尔类型：<span class="hljs-type">boolean</span><br>----------------------------------<br>- 字符串类型：String<br>- 自动判断：<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure><h2 id="命名规范">2）命名规范</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类名以大写开始</span><br>- Hello<br>- NoteBook<br>- VRPlayer<br><span class="hljs-comment">//方法以小写字母开始</span><br>- main<br>- goodMorning<br>- playVR<br></code></pre></td></tr></table></figure><h2 id="输入输出">3）输入输出</h2><p>--输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in); <span class="hljs-comment">// 创建Scanner对象</span><br>        System.out.print(<span class="hljs-string">&quot;Input your name: &quot;</span>); <span class="hljs-comment">// 打印提示</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> scanner.nextLine(); <span class="hljs-comment">// 读取一行输入并获取字符串</span><br>        System.out.print(<span class="hljs-string">&quot;Input your age: &quot;</span>); <span class="hljs-comment">// 打印提示</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> scanner.nextInt(); <span class="hljs-comment">// 读取一行输入并获取整数</span><br>        System.out.printf(<span class="hljs-string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="hljs-comment">// 格式化输出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>--输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;A:&quot;</span>);<span class="hljs-comment">//输出，不换行</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926</span>;<br>        System.out.printf(<span class="hljs-string">&quot;%.2f\n&quot;</span>, d); <span class="hljs-comment">//格式化输出</span><br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;END&quot;</span>);<span class="hljs-comment">//输出，换行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>%d ---- 整数</p><p>%f ---- 浮点数</p><p>%x ---- 十六进制浮点</p><p>%e ---- 格式化输出</p><p>%s ---- 字符串</p></blockquote><h2 id="数组与排序">4)数组与排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> []a = &#123;<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>        System.out.println(Arrays.toString(a));<br>        Arrays.sort(a);<br>        System.out.println(Arrays.toString(a));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="命令行参数">5)命令行参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(String it : args)&#123;<br>            System.out.println(it);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Terminal：java Main arg1 arg2 arg3    </span><br><span class="hljs-comment">//arg1</span><br><span class="hljs-comment">//arg2</span><br><span class="hljs-comment">//arg3</span><br></code></pre></td></tr></table></figure><h1 id="java面向对象特性">Java面向对象特性</h1><h2 id="继承extends">1）继承（extends）</h2><p>在Java中使用extends实现继承。</p><p>每个类都有个父类，默认父类为Object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;...&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;...&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 不要重复name和age字段/方法,</span><br>    <span class="hljs-comment">// 只需要定义新增score字段/方法:</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123; … &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123; … &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在java中使用super来访问父类的函数</p><p>在构造函数中必须先调用super()来实例化父类field</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> score;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age); <span class="hljs-comment">// 显式调用父类的构造方法Person(String, int)</span><br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p><ul><li><code>toString()</code>：把instance输出为<code>String</code>；</li><li><code>equals()</code>：判断两个instance是否逻辑相等；</li><li><code>hashCode()</code>：计算一个instance的哈希值。</li></ul><h2 id="重写override">2）重写（override）</h2><p>例如，在<code>Person</code>类中，我们定义了<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Person.run&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在子类<code>Student</code>中，覆写这个<code>run()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//加上@Override可以让编译器帮助检查是否进行了正确的覆写</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student.run&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个很经典的报税例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span><br>        Income[] incomes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Income</span>[] &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Income</span>(<span class="hljs-number">3000</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Salary</span>(<span class="hljs-number">7500</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateCouncilSpecialAllowance</span>(<span class="hljs-number">15000</span>)<br>        &#125;;<br>        System.out.println(totalTax(incomes));<br>    &#125;<br>    <span class="hljs-comment">//统计总的税收</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">totalTax</span><span class="hljs-params">(Income... incomes)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Income income: incomes) &#123;<br>            total = total + income.getTax();<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//基类：基本的税率</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Income</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">double</span> income;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Income</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span> &#123;<br>        <span class="hljs-built_in">this</span>.income = income;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> income * <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 税率10%</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//其他两种收税制度</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Income</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Salary</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span> &#123;<br>        <span class="hljs-built_in">super</span>(income);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (income &lt;= <span class="hljs-number">5000</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (income - <span class="hljs-number">5000</span>) * <span class="hljs-number">0.2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StateCouncilSpecialAllowance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Income</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StateCouncilSpecialAllowance</span><span class="hljs-params">(<span class="hljs-type">double</span> income)</span> &#123;<br>        <span class="hljs-built_in">super</span>(income);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTax</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，Java中也允许重写Object类的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 显示更有意义的字符串:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person:name=&quot;</span> + name;<br>    &#125;<br>    <span class="hljs-comment">// 比较是否相等:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">// 当且仅当o为Person类型:</span><br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Person) &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) o;<br>            <span class="hljs-comment">// 并且name字段相同时，返回true:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(p.name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 计算hash:</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.hashCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量final">3）常量（final）</h2><p>在Java中可以使用final来修饰类/方法/字段，以禁止继承/重写/修改</p><p>例如：</p><h3 id="禁止重写"><strong>1.禁止重写</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//----------------------------------</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// compile error: 不允许覆写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="禁止继承"><strong>2.禁止继承</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>&#125;<br><span class="hljs-comment">//----------------------------------</span><br><span class="hljs-comment">// compile error: 不允许继承自Person</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="禁止修改"><strong>3.禁止修改</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String name = <span class="hljs-string">&quot;Unamed&quot;</span>;<br>&#125;<br><span class="hljs-comment">//----------------------------------</span><br>Person p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>();<br>p.name = <span class="hljs-string">&quot;New Name&quot;</span>; <span class="hljs-comment">// compile error!</span><br></code></pre></td></tr></table></figure><h2 id="抽象abstract">4）抽象（abstract）</h2><p>​如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-comment">//compile error</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口interface">5）接口（interface）</h2><h3 id="基本定义">1.基本定义</h3><p>​接口是没有字段的抽象类，如果一个抽象类没有字段，所有方法全部都是抽象方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><p>​ 那么，就可以把该抽象类改写为接口：<code>interface</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><p>​<code>interface</code>不能定义实例字段。但是，<code>interface</code>是可以有staticfinal字段的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MALE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">FEMALE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//int MALE = 1; 被自动声明为static final</span><br>   <span class="hljs-comment">//int FEMALE = 2;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现多个接口">2.实现多个接口</h3><p>​ 在Java中，一个类不能继承多个类，但是却可以实现多个接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span>, Hello &#123;...&#125;<span class="hljs-comment">// 实现了两个interface</span><br></code></pre></td></tr></table></figure><h3 id="接口继承">3.接口继承</h3><p>​此外，一个<code>interface</code>也可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p><p>----接口的default方法</p><p>​在接口中，可以定义<code>default</code>方法，提供该方法未被实现类实现时的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(getName() + <span class="hljs-string">&quot; run&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="包package">6）包（package）</h2><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p><p>例如：</p><p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p><p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p><p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p><p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-comment">// 导入mr.jun包的所有class:</span><br><span class="hljs-keyword">import</span> mr.jun.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Arrays</span> <span class="hljs-variable">arrays</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arrays</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="作用域public">7）作用域（public）</h2><p>public、private、protected是Java中声明作用域的修饰符</p><p>​ ----default：类/字段/方法可以在同一包内被访问</p><p>​ ----public：类/字段/方法在任意位置被访问</p><p>​ ----private：类不可在其他地方被访问，字段/方法只能在类内部访问</p><p>​ ----protected：字段/方法只能在类及其子类内部访问</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java GUI-页面设计</title>
    <link href="/other/Java-GUI/"/>
    <url>/other/Java-GUI/</url>
    
    <content type="html"><![CDATA[<h1 id="java-gui">Java GUI</h1><blockquote><p>java的GUI编程主要使用两个库：AWT和Swing</p></blockquote><h3 id="awt">AWT</h3><p>AWT (Abstract Window Toolkit)是Java的原始图形工具包，它是Java平台的一部分，自Java1.0版本起就存在了。</p><p>它提供了基本的GUI组件，如窗口、按钮、文本框等，以及布局管理器和事件处理机制。AWT组件是<strong>本地平台依赖的</strong>，这意味着AWT组件<strong>的外观和行为可能会因操作系统的不同而有所差异</strong>。AWT的优点在于它<strong>与平台紧密集成，运行速度快</strong></p><p>然而，AWT的缺点也很明显</p><p>​----因为它是本地依赖的，所以AWT应用程序的<strong>可移植性较差</strong>。</p><p>​----AWT的<strong>界面风格相对较为古老，不如现代图形界面库那样美观</strong>。</p><h3 id="swing">Swing</h3><p>Swing是Java的一个扩展图形工具包，<strong>基于AWT构建</strong>。</p><p>Swing组件<strong>是平台无关的</strong>，在不同的操作系统上看起来和行为都非常相似。它还<strong>提供了更高级的功能</strong>，如拖放支持、表格和树形控件等。</p><p>Swing的优点在于<strong>其跨平台兼容性和丰富的组件库</strong>。</p><p>然而，Swing也有一些缺点。</p><p>​ ----某些情况下可能会<strong>比AWT原生组件慢一些</strong>。</p><p>​----在处理复杂布局和高级图形效果时可能<strong>不如其他现代图形库那样灵活和高效</strong>。</p><h1 id="awt-1">AWT</h1><h2 id="container">Container</h2><p>Container实际上继承自Components</p><p>用于存储其他components，本身没有实际作用</p><h3 id="frame">Frame</h3><p>Frame是用于承载整个窗口的容器</p><p>常常自定义一个新的容器来继承Frame，并在构造函数中初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">frame</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">frame</span>(<span class="hljs-string">&quot;Hello Java GUI&quot;</span>);<br>    &#125;<br>&#125;<span class="hljs-comment">//主类只提供frame的入口，后面的例子里省略主类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setVisible(<span class="hljs-literal">true</span>); <span class="hljs-comment">//设置可见性</span><br>        setSize(<span class="hljs-number">400</span>,<span class="hljs-number">400</span>); <span class="hljs-comment">//设置大小，也可以用setBounds</span><br>        setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">59</span>, <span class="hljs-number">162</span>, <span class="hljs-number">198</span>));<span class="hljs-comment">//设置颜色</span><br>        addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowAdapter</span>()&#123;<span class="hljs-comment">//添加窗口关闭监听器，否则无法正常关闭，后续例子省略该监听器</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>                System.exit(<span class="hljs-number">0</span>);<br>            &#125;;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="panel">Panel</h3><p>Panel是用于装载组件的容器</p><p>一般来说，一个Frame包含多个Panel，一个Panel包含多个组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Panel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">400</span>,<span class="hljs-number">400</span>);<br>        setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">59</span>, <span class="hljs-number">162</span>, <span class="hljs-number">198</span>));<br>        setVisible(<span class="hljs-literal">true</span>);<br>        <br>        setLayout(<span class="hljs-literal">null</span>);<span class="hljs-comment">//不设置布局</span><br>        add(panel);<span class="hljs-comment">//添加Panel到Frame</span><br><br>        panel.setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>);<span class="hljs-comment">//设置panel位置、大小</span><br>        panel.setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">225</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">242</span>));<span class="hljs-comment">//颜色</span><br>        panel.setVisible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//可见性</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="layoutmanager">LayoutManager</h2><p>LayoutManger主要有三个子类：FlowLayout(流式布局)、GridLayout(表格布局)、BorderLayout(边缘布局)</p><blockquote><p>this.setLayout(null) -&gt; 绝对布局</p></blockquote><h3 id="flowlayout">FlowLayout</h3><p>从左到右，从上到下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button1&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button2&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button3&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button4&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button5&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button6&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>);<br>        setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">59</span>, <span class="hljs-number">162</span>, <span class="hljs-number">198</span>));<br>        setVisible(<span class="hljs-literal">true</span>);<br>        setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());<span class="hljs-comment">//流式布局</span><br><br>        add(but1);add(but2);add(but3);add(but4);add(but5);add(but6);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="borderlayout">BorderLayout</h3><p>按东西南北中的顺序，依次排布</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;east&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;west&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;south&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;north&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;center&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>);<br>        setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">59</span>, <span class="hljs-number">162</span>, <span class="hljs-number">198</span>));<br>        setVisible(<span class="hljs-literal">true</span>);<br>        setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BorderLayout</span>());<span class="hljs-comment">//设置边框布局</span><br>        <br>        add(but1,BorderLayout.EAST);<br>        add(but2,BorderLayout.WEST);<br>        add(but3,BorderLayout.SOUTH);<br>        add(but4,BorderLayout.NORTH);<br>        add(but5,BorderLayout.CENTER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gridlayout">GridLayout</h3><p>表格布局，设置几行几列，从左到右，从上到下地放入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button1&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button2&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button3&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button4&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button5&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;button6&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>);<br>        setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">59</span>, <span class="hljs-number">162</span>, <span class="hljs-number">198</span>));<br>        setVisible(<span class="hljs-literal">true</span>);<br>        setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>));<span class="hljs-comment">//设置表格布局</span><br>        <span class="hljs-comment">//row，column，hgap，wgap</span><br>        add(but1);add(but2);add(but3);add(but4);add(but5);add(but6);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mix-used">Mix-used</h3><p>通过对Panel和Frame分别设置不同的LayoutManager来实现多种布局方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Panel</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BorderLayout</span>());<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Panel</span> <span class="hljs-variable">tab1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Panel</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BorderLayout</span>());<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Panel</span> <span class="hljs-variable">tab2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">400</span>,<span class="hljs-number">400</span>);<br>        setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">59</span>, <span class="hljs-number">162</span>, <span class="hljs-number">198</span>));<br>        setVisible(<span class="hljs-literal">true</span>);<br>        setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>));<br><br>        p1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;east-1&quot;</span>),BorderLayout.EAST);<br>        p1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;west-1&quot;</span>),BorderLayout.WEST);<br>        p1.add(tab1,BorderLayout.CENTER);<br>        tab1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;tab1-(1,1)&quot;</span>));<br>        tab1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;tab1-(2-1)&quot;</span>));<br><br>        p2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;east-2&quot;</span>),BorderLayout.EAST);<br>        p2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;west-2&quot;</span>),BorderLayout.WEST);<br>        p2.add(tab2,BorderLayout.CENTER);<br>        tab2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;tab2-(1,1)&quot;</span>));<br>        tab2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;tab2-(1,2)&quot;</span>));<br>        tab2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;tab2-(2,1)&quot;</span>));<br>        tab2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;tab2-(2,2)&quot;</span>));<br><br>        add(p1);add(p2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="eventlisener">EventLisener</h2><p>Java提供了如下接口来实现 自定义的监听器接口，它们都继承自EventListener</p><blockquote><p>WindowListener 窗口监听</p><p>MouseListener 鼠标监听</p><p>ActionListener 动作监听</p><p>KeyListener 键盘监听</p></blockquote><h3 id="windowlistener">WindowListener</h3><p>窗口监听器，常用的就只有windowClosing和windowActivated</p><p>分别是关闭和打开窗口时候发生的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WindowListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventListener</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowOpened</span><span class="hljs-params">(WindowEvent e)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span>;<span class="hljs-comment">//关闭</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosed</span><span class="hljs-params">(WindowEvent e)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowIconified</span><span class="hljs-params">(WindowEvent e)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowDeiconified</span><span class="hljs-params">(WindowEvent e)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowActivated</span><span class="hljs-params">(WindowEvent e)</span>;<span class="hljs-comment">//打开</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowDeactivated</span><span class="hljs-params">(WindowEvent e)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接实现该接口的方法需要重写每个类，可以采用适配器模式，</p><p>继承WindowAdaptor，只需要重写部分需要的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowAdapter</span>()&#123;<span class="hljs-comment">//添加窗口关闭监听器，否则无法正常关闭，后续例子省略该监听器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>        System.exit(<span class="hljs-number">0</span>);<br>    &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="mouselistener">MouseListener</h3><p>包括如下五种事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MouseListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventListener</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseClicked</span><span class="hljs-params">(MouseEvent e)</span>;<span class="hljs-comment">//按下并松开时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mousePressed</span><span class="hljs-params">(MouseEvent e)</span>;<span class="hljs-comment">//按下时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseReleased</span><span class="hljs-params">(MouseEvent e)</span>;<span class="hljs-comment">//松开时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseEntered</span><span class="hljs-params">(MouseEvent e)</span>;<span class="hljs-comment">//鼠标进入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseExited</span><span class="hljs-params">(MouseEvent e)</span>;<span class="hljs-comment">//鼠标移开</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同理，可以继承MouseAdaptor简化重写操作，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMouseListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MouseAdapter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mousePressed</span><span class="hljs-params">(MouseEvent e)</span> &#123;<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(e.getX(),e.getY());<br>        points.add(p);<br>        repaint();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="actionlistener">ActionListener</h3><p>ActionListener接口里只有一个事件函数actionPerformed</p><p>通常是添加在Button和TextField组件上的监听器，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//button监听器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;<br>        System.out.println(tf.getText());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//TextField监听器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;<br>        System.out.println(tf.getText());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="keylistener">KeyListener</h3><p>接口模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">KeyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventListener</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyTyped</span><span class="hljs-params">(KeyEvent e)</span>;<span class="hljs-comment">//按下并松开</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyPressed</span><span class="hljs-params">(KeyEvent e)</span>;<span class="hljs-comment">//按下</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyReleased</span><span class="hljs-params">(KeyEvent e)</span>;<span class="hljs-comment">//松开</span><br>&#125;<br></code></pre></td></tr></table></figure><p>适配器模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyKeyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">KeyAdapter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyPressed</span><span class="hljs-params">(KeyEvent e)</span> &#123;<br>        System.out.print(e.getKeyChar());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在KeyEvent类中，存在可以判断几乎所有键盘按键的字段</p></blockquote><p>例如：如下实现了判断上下左右四个按键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyKeyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">KeyAdapter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyPressed</span><span class="hljs-params">(KeyEvent e)</span> &#123;<br>        <span class="hljs-keyword">if</span>(e.getKeyCode() == KeyEvent.VK_UP)&#123;<br>            System.out.println(<span class="hljs-string">&quot;up&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.getKeyCode() == KeyEvent.VK_DOWN)&#123;<br>            System.out.println(<span class="hljs-string">&quot;down&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.getKeyCode() == KeyEvent.VK_LEFT) &#123;<br>            System.out.println(<span class="hljs-string">&quot;left&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.getKeyCode() == KeyEvent.VK_RIGHT) &#123;<br>            System.out.println(<span class="hljs-string">&quot;right&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="component">Component</h2><h3 id="button">Button</h3><p>使用button实现一个简单的输出事件</p><p>--外部类写法，需要使用参数传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;press to print&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ClickCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        <span class="hljs-comment">//frame设置</span><br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setBackground(Color.white);<br>        setVisible(<span class="hljs-literal">true</span>);<br>        setLayout(<span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">//but设置       </span><br>        but.setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>        but.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyActionListener</span>(<span class="hljs-built_in">this</span>));<span class="hljs-comment">//引用传递自身</span><br>        add(but);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//监听器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">frame</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyActionListener</span><span class="hljs-params">(frame fr_)</span>&#123;<br>        fr = fr_;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;The Button is pressed.&quot;</span> + (++fr.ClickCount) );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>--内部类写法，节省了参数传递的步骤，更简洁（后续案例都采用内部类监听器）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;press to print&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ClickCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        <span class="hljs-comment">//frame设置</span><br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setBackground(Color.white);<br>        setVisible(<span class="hljs-literal">true</span>);<br>        setLayout(<span class="hljs-literal">null</span>);<br>   <span class="hljs-comment">//but设置</span><br>        but.setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>        but.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyActionListener</span>());<br>        add(but);<br>    &#125;<br>    <span class="hljs-comment">//监听器设置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;The Button is pressed.&quot;</span> + (++ClickCount) );<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="textfield">TextField</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">TextField</span> <span class="hljs-variable">tf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextField</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setBackground(Color.white);<br>        setVisible(<span class="hljs-literal">true</span>);<br>        addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWindowsListener</span>());<br>        tf.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyActionListener</span>());<br>        add(tf);<br>    &#125;<br>    <span class="hljs-comment">//将监听器都写成frame的内部类，省略传参，是一种更规范和简洁的写法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindowsListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WindowAdapter</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;<br>            System.out.println(tf.getText());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="a-simple-caculator">A Simple Caculator</h3><p>使用Button和TextField实现一个简单的加法计算器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">frame</span>(<span class="hljs-string">&quot;Caculator&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TextField</span> <span class="hljs-variable">tf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextField</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TextField</span> <span class="hljs-variable">tf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextField</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">TextField</span> <span class="hljs-variable">tf3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextField</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Label</span> <span class="hljs-variable">lb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>(<span class="hljs-string">&quot;+&quot;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Button</span> <span class="hljs-variable">but</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;=&quot;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num1,num2,num3;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">200</span>);<br>        setBackground(Color.white);<br>        setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>(FlowLayout.CENTER,<span class="hljs-number">15</span>,<span class="hljs-number">50</span>));<br>        addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWindowsListener</span>());<br>        setVisible(<span class="hljs-literal">true</span>);<br><br>        add(tf1);add(lb);add(tf2);add(but);add(tf3);<br><br>        but.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyActionListener</span>());<br>    &#125;<br>    <span class="hljs-comment">//关闭窗口监听器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindowsListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WindowAdapter</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//button事件监听器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActionListener</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span>&#123;<br>            <span class="hljs-keyword">try</span>&#123; <span class="hljs-comment">//异常处理</span><br>                num1 = Integer.parseInt(tf1.getText());<br>                num2 = Integer.parseInt(tf2.getText());<br>                num3 = num1 + num2;<br>                tf3.setText(String.valueOf(num3));<br>            &#125;<span class="hljs-keyword">catch</span>(Exception er)&#123;<br>                tf3.setText(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="a-simple-painting-tool">A Simple Painting Tool</h3><p><strong>Paint</strong></p><p>paint函数在初始化的时候，会调用一次</p><p>重写paint函数，并调用Graphics中的函数来实现绘图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>        setBackground(Color.white);<br>        addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWindowsListener</span>());<br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindowsListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WindowAdapter</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span>&#123; <span class="hljs-comment">//paint函数在初始化的时候，会调用一次</span><br>        <span class="hljs-comment">//此处重写paint来画笔</span><br>        <span class="hljs-built_in">super</span>.paint(g);<br>        g.setColor(Color.BLUE);<span class="hljs-comment">//设置画笔颜色</span><br>        g.fillOval(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<span class="hljs-comment">//圆</span><br>        g.setColor(Color.RED);<br>        g.fillRect(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>);<span class="hljs-comment">//矩形</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用鼠标监听器实现单击画点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">frame</span>(<span class="hljs-string">&quot;Painting Points&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">frame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Frame</span>&#123;<br>    <span class="hljs-type">ArrayList</span> <span class="hljs-variable">points</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Point&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">frame</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>        setBackground(Color.white);<br>        addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyWindowsListener</span>());<br>        addMouseListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMouseListener</span>());<br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-comment">//窗口关闭监听器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindowsListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WindowAdapter</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//鼠标单击监听器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMouseListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MouseAdapter</span>&#123;<br>        <span class="hljs-comment">//每次单击鼠标，添加一个点进入数组，并重绘一次</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mousePressed</span><span class="hljs-params">(MouseEvent e)</span> &#123;<br>            <span class="hljs-type">Point</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(e.getX(),e.getY());<br>            points.add(p);<br>            repaint();<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//重写paint函数</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;<br>        <span class="hljs-comment">//每次调用paint函数，遍历points数组，并画出每一个点</span><br>        <span class="hljs-comment">//可调用repaint重绘</span><br>        <span class="hljs-built_in">super</span>.paint(g);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> points.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            <span class="hljs-type">Point</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Point)it.next();<br>            g.setColor(Color.BLUE);<br>            g.fillOval(p.x,p.y,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="swing-1">Swing</h1><h2 id="jframe">JFrame</h2><p>在JFrame中，往窗体中放组件和设置布局、颜色，需要调用getContentPane()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">jframe</span>(<span class="hljs-string">&quot;Hello JFrame&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-type">JLabel</span> <span class="hljs-variable">lb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;This is a JLabel text&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>        setVisible(<span class="hljs-literal">true</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setBackground(Color.CYAN);<br>        lb.setHorizontalAlignment(SwingConstants.CENTER);<span class="hljs-comment">//设置文本居中放置</span><br>        ctr.add(lb);<br>    &#125;<br>    <span class="hljs-comment">//窗口关闭监听器</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="jdialog">JDialog</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-type">JButton</span> <span class="hljs-variable">jbut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;Press to show a JDialog&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>        setVisible(<span class="hljs-literal">true</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br>        jbut.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActionListener</span>() &#123; <span class="hljs-comment">//在button中设置弹窗设置</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyJDialog</span>();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setLayout(<span class="hljs-literal">null</span>);<br>        ctr.setBackground(Color.CYAN);<br>        jbut.setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">100</span>);<br>        jbut.setHorizontalAlignment(SwingConstants.CENTER);<br>        ctr.add(jbut);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyJDialog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JDialog</span>&#123; <span class="hljs-comment">//设置弹出的配置</span><br>    <span class="hljs-type">JLabel</span> <span class="hljs-variable">jlb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;I am a JLabel in JDialog&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyJDialog</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">super</span>();<br>        setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">200</span>);<br>        setVisible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> getContentPane();<br>        jlb.setHorizontalAlignment(SwingConstants.CENTER);<br>        ctr.add(jlb);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="imageicon">ImageIcon</h2><p>为label插入本地图标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-type">JLabel</span> <span class="hljs-variable">jlb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;here is Label&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setLayout(<span class="hljs-literal">null</span>);<br>        ctr.setBackground(Color.white);<br><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> jframe.class.getResource(<span class="hljs-string">&quot;test.jpg&quot;</span>);<span class="hljs-comment">//设置图片路径,这个路径通常是 src/</span><br>        <span class="hljs-type">ImageIcon</span> <span class="hljs-variable">icon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageIcon</span>(url);<span class="hljs-comment">//导入图片</span><br>        <span class="hljs-type">Image</span> <span class="hljs-variable">newImage</span> <span class="hljs-operator">=</span> icon.getImage().getScaledInstance(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, Image.SCALE_DEFAULT);<span class="hljs-comment">//重新设置图片大小</span><br>        icon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageIcon</span>(newImage);<br><br>        jlb.setIcon(icon);<span class="hljs-comment">//为label设置图标</span><br>        jlb.setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">50</span>);<br>        jlb.setHorizontalAlignment(SwingConstants.CENTER);<br>        ctr.add(jlb);<br>        <br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为Button插入图标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-type">JButton</span> <span class="hljs-variable">jbut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> jframe.class.getResource(<span class="hljs-string">&quot;test.jpg&quot;</span>); <span class="hljs-comment">//导入图标</span><br>        <span class="hljs-type">ImageIcon</span> <span class="hljs-variable">icon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageIcon</span>(resource);<br>        <span class="hljs-type">Image</span> <span class="hljs-variable">icon_new</span> <span class="hljs-operator">=</span> icon.getImage().getScaledInstance(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,Image.SCALE_DEFAULT);<br>        icon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageIcon</span>(icon_new);<br><br>        jbut.setIcon(icon); <span class="hljs-comment">//插入图标</span><br>        jbut.setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">50</span>);<br>        <br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setLayout(<span class="hljs-literal">null</span>);<br>        ctr.setBackground(Color.white);<br>        ctr.add(jbut);<br><br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="jscrollpane">JScrollPane</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-type">JTextArea</span> <span class="hljs-variable">jtextArea</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextArea</span>(<span class="hljs-string">&quot;hello JTextArea&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//JTextArea多行输入框</span><br>    <span class="hljs-type">JScrollPane</span> <span class="hljs-variable">jScrollPane</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JScrollPane</span>(jtextArea);<span class="hljs-comment">//将JTextArea加入JScrollPane</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<br>        ctr.setBackground(Color.white);<br>        <br>        ctr.add(jScrollPane);<span class="hljs-comment">//加入JScrollPane</span><br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jradiobutton">JRadioButton</h2><p>单选框</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br><br>        <span class="hljs-type">JRadioButton</span> <span class="hljs-variable">jbut1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JRadioButton</span>(<span class="hljs-string">&quot;but1&quot;</span>);<br>        <span class="hljs-type">JRadioButton</span> <span class="hljs-variable">jbut2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JRadioButton</span>(<span class="hljs-string">&quot;but2&quot;</span>);<br>        <span class="hljs-type">JRadioButton</span> <span class="hljs-variable">jbut3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JRadioButton</span>(<span class="hljs-string">&quot;but3&quot;</span>);<br><br>        <span class="hljs-type">ButtonGroup</span> <span class="hljs-variable">butGrp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ButtonGroup</span>();<span class="hljs-comment">//在ButtonGroup内的RadioButton只能被选中其中一个</span><br>        butGrp.add(jbut1);<br>        butGrp.add(jbut2);<br>        butGrp.add(jbut3);<br><br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());<br>        ctr.setBackground(Color.white);<br>        ctr.add(jbut1);<br>        ctr.add(jbut2);<br>        ctr.add(jbut3);<br><br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jcheckbox">JCheckBox</h2><p>复选框</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br><br>        <span class="hljs-type">JCheckBox</span> <span class="hljs-variable">jck1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JCheckBox</span>(<span class="hljs-string">&quot;jck1&quot;</span>);<br>        <span class="hljs-type">JCheckBox</span> <span class="hljs-variable">jck2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JCheckBox</span>(<span class="hljs-string">&quot;jck2&quot;</span>);<br>        <span class="hljs-type">JCheckBox</span> <span class="hljs-variable">jck3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JCheckBox</span>(<span class="hljs-string">&quot;jck3&quot;</span>);<br><br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());<br>        ctr.setBackground(Color.white);<br>        ctr.add(jck1);<br>        ctr.add(jck2);<br>        ctr.add(jck3);<br><br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jcombobox">JComboBox</h2><p>下拉框</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br><br>        <span class="hljs-type">JComboBox</span> <span class="hljs-variable">jcb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JComboBox</span>();<br><br>        jcb.addItem(<span class="hljs-string">&quot;Chinese&quot;</span>);<br>        jcb.addItem(<span class="hljs-string">&quot;English&quot;</span>);<br>        jcb.addItem(<span class="hljs-string">&quot;French&quot;</span>);<br>        <br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());<br>        ctr.setBackground(Color.white);<br>        ctr.add(jcb);<br><br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jlist">JList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br><br>        String []strs = &#123;<span class="hljs-string">&quot;Chinese&quot;</span>,<span class="hljs-string">&quot;English&quot;</span>,<span class="hljs-string">&quot;French&quot;</span>&#125;;<br><br>        <span class="hljs-type">JList</span> <span class="hljs-variable">jlist</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JList</span>(strs);<br><br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane(); <span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());<br>        ctr.setBackground(Color.white);<br>        ctr.add(jlist);<br><br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jtextfield">JTextField</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br><br>        <span class="hljs-type">JTextField</span> <span class="hljs-variable">jtf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextField</span>(<span class="hljs-string">&quot;请在此输入文本&quot;</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//文本输入框</span><br>        <span class="hljs-type">JPasswordField</span> <span class="hljs-variable">jpf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPasswordField</span>(<span class="hljs-string">&quot;请输入密码&quot;</span>,<span class="hljs-number">20</span>); <span class="hljs-comment">//密码输入框</span><br>        jpf.setEchoChar(<span class="hljs-string">&#x27;&amp;&#x27;</span>);<br><br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());<br>        ctr.setBackground(Color.white);<br>        ctr.add(jtf);<br>        ctr.add(jpf);<br><br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jmenu">JMenu</h2><p>JMenuBar -- 菜单栏</p><p>JMenu -- 菜单/子菜单</p><p>JMenuItem -- 菜单项（最小单元）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">jframe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JFrame</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">jframe</span><span class="hljs-params">(String title)</span> &#123;<br>        <span class="hljs-built_in">super</span>(title);<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<span class="hljs-comment">//JFrame中的默认关闭设置</span><br><br>        <span class="hljs-type">JMenuBar</span> <span class="hljs-variable">jmb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuBar</span>(); <span class="hljs-comment">//菜单栏</span><br>        <span class="hljs-type">JMenu</span> <span class="hljs-variable">CN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenu</span>(<span class="hljs-string">&quot;China&quot;</span>); <span class="hljs-comment">//菜单</span><br>        <span class="hljs-type">JMenu</span> <span class="hljs-variable">bj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenu</span>(<span class="hljs-string">&quot;Beijing&quot;</span>);<br>        bj.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;haidian&quot;</span>));<span class="hljs-comment">//菜单项</span><br>        bj.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;chaoyang&quot;</span>));<br>        <span class="hljs-type">JMenuItem</span> <span class="hljs-variable">fj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;Fujian&quot;</span>);<span class="hljs-comment">//菜单项</span><br>        <span class="hljs-type">JMenuItem</span> <span class="hljs-variable">sh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;Shanghai&quot;</span>);<br><br>        fj.addActionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActionListener</span>() &#123; <span class="hljs-comment">//添加菜单项触发事件</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;<br>                <span class="hljs-type">JDialog</span> <span class="hljs-variable">jb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JDialog</span>();<br>                jb.setBounds(<span class="hljs-number">500</span>,<span class="hljs-number">500</span>,<span class="hljs-number">300</span>,<span class="hljs-number">300</span>);<br>                jb.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;WELCOME TO FUJIAN!!!&quot;</span>));<br>                jb.setVisible(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//同上</span><br>        <span class="hljs-type">JMenu</span> <span class="hljs-variable">US</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenu</span>(<span class="hljs-string">&quot;The United State&quot;</span>);<br>        <span class="hljs-type">JMenuItem</span> <span class="hljs-variable">bmh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;Birmingham&quot;</span>);<br>        <span class="hljs-type">JMenuItem</span> <span class="hljs-variable">la</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;LosAngeles&quot;</span>);<br>        <span class="hljs-type">JMenuItem</span> <span class="hljs-variable">sf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;SanFrancisco&quot;</span>);<br>        <span class="hljs-comment">//同上</span><br>        <span class="hljs-type">JMenu</span> <span class="hljs-variable">UK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenu</span>(<span class="hljs-string">&quot;The United Kingdom&quot;</span>);<br>        <span class="hljs-type">JMenuItem</span> <span class="hljs-variable">ld</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;London&quot;</span>);<br>        <span class="hljs-type">JMenuItem</span> <span class="hljs-variable">edb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;Edinburgh&quot;</span>);<br>        <span class="hljs-type">JMenuItem</span> <span class="hljs-variable">oxf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;Oxford&quot;</span>);<br>        <br>        <span class="hljs-comment">//添加操作</span><br>        CN.add(fj);CN.add(bj);CN.add(sh);<br>        US.add(bmh);US.add(la);US.add(sf);<br>        UK.add(ld);UK.add(edb);UK.add(oxf);<br>        jmb.add(CN);<br>        jmb.add(US);<br>        jmb.add(UK);<br>        <br>        <span class="hljs-comment">//设置菜单</span><br>        setJMenuBar(jmb);<br>        <span class="hljs-type">Container</span> <span class="hljs-variable">ctr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getContentPane();<span class="hljs-comment">//在JFrame中，往窗体中放组件和设置颜色，需要调用getContentPane()</span><br>        ctr.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());<br>        ctr.setBackground(Color.white);<br>        <br>        setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/other/Git/"/>
    <url>/other/Git/</url>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 -廖雪峰的官方网站 (liaoxuefeng.com)</a>的学习笔记</p><h1 id="初始化">初始化</h1><p>1.初始化当前文件夹为git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init <br></code></pre></td></tr></table></figure><p>2.设置个人信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&#x27;你的用户名&#x27;</span><br>git config --global user.email <span class="hljs-string">&#x27;你的邮箱&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="暂存区和仓库">暂存区和仓库</h1><p>1.查看当前工作区状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br><span class="hljs-comment">#哪些文件还没被加入暂存区</span><br></code></pre></td></tr></table></figure><p>2.查看文件变动情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff <span class="hljs-comment">#对比暂存区，哪些文件被删除了/修改了</span><br>git checkout<br><span class="hljs-comment">#对比仓库，哪些文件被删除了/修改了</span><br>git diff <br><span class="hljs-comment">#对比暂存区，哪些文件被删除了/修改了</span><br></code></pre></td></tr></table></figure><p>3.添加文件进入暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add 文件名<br>git add *<br></code></pre></td></tr></table></figure><p>4.将文件移出暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset HEAD 文件名 <span class="hljs-comment">#不覆盖当前工作区文件 == 取消git add 文件名</span><br>git restore --staged 文件名 <span class="hljs-comment">#覆盖当前工作区文件</span><br></code></pre></td></tr></table></figure><p>5.将暂存区文件加入仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;修改注释信息&quot;</span><br></code></pre></td></tr></table></figure><h1 id="版本回退">版本回退</h1><p>1.查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> <span class="hljs-comment">#查看当前版本前的历史记录</span><br>git <span class="hljs-built_in">log</span> --pretty=oneline  <span class="hljs-comment">#一行显示</span><br>git reflog  <span class="hljs-comment">#查看操作记录</span><br></code></pre></td></tr></table></figure><p>2.版本回退</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^ <span class="hljs-comment">#回到上一个版本</span><br>git reset --hard 版本标签 <span class="hljs-comment">#回到指定版本 该标签通过log/logref查询，可不写全</span><br></code></pre></td></tr></table></figure><p>3.文件回退</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout 文件名 <span class="hljs-comment">#将该文件回退到仓库状态</span><br></code></pre></td></tr></table></figure><h1 id="github远程仓库">GitHub远程仓库</h1><h2 id="准备">准备</h2><p>1.创建SSH密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;邮箱地址&quot;</span><br><span class="hljs-comment">#一般存在/user/用户/.ssh/id_rsa.pub</span><br></code></pre></td></tr></table></figure><p>2.将本地的ssh公钥拷贝到GitHub</p><p>3.在GitHub上创建一个仓库</p><h2 id="同步与克隆">同步与克隆</h2><p>1.连接本地仓库到远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:CzwCugb/LearnHowToGit.git<br></code></pre></td></tr></table></figure><p>2.同步当前仓库到GitHub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin master <span class="hljs-comment">#连接并关联origin 和 master</span><br>git push origin master <span class="hljs-comment">#仅连接</span><br></code></pre></td></tr></table></figure><p>3.克隆远程仓库到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:CzwCugb/LearnHowToGit.git<br></code></pre></td></tr></table></figure><h2 id="删除">删除</h2><p>1.查询当前关联远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote<br>git remote -v<br></code></pre></td></tr></table></figure><p>2.删除关联</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-built_in">rm</span> origin<br></code></pre></td></tr></table></figure><h1 id="分支">分支</h1><p>1.创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-comment">#查询所有分支</span><br>git branch dev <span class="hljs-comment">#创建分支dev</span><br></code></pre></td></tr></table></figure><p>2.删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d dev<br></code></pre></td></tr></table></figure><p>3.切换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch dev <span class="hljs-comment">#切换</span><br><span class="hljs-comment">#相当于 git checkout dev</span><br>git switch -c dev <span class="hljs-comment">#创建并切换</span><br><span class="hljs-comment">#相当于 git checkout -b dev</span><br></code></pre></td></tr></table></figure><p>4.合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">get merge dev <span class="hljs-comment">#将dev分支合并到当前分支</span><br></code></pre></td></tr></table></figure><p>5.冲突</p><p>在分支合并时，若它们各自的修改相比与公共祖先存在冲突，</p><p>此时合并会报错，需要我们手动修改对应内容</p><h1 id="保存现场">保存现场</h1><p>在一个修改还没做完，不想更新一个版本时，可以将 工作区 和 暂存区暂时保存在stash里</p><p>1.使用stash临时存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br><span class="hljs-comment">#此时工作区之前的修改删除，保存在stash list中，以便恢复</span><br></code></pre></td></tr></table></figure><p>2.查询stash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash list<br></code></pre></td></tr></table></figure><p>3.恢复和删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash apply &lt;index&gt; <span class="hljs-comment">#使用</span><br>git stash drop &lt;index&gt; <span class="hljs-comment">#删除</span><br>git stash pop &lt;index&gt; <span class="hljs-comment">#使用并删除</span><br></code></pre></td></tr></table></figure><h1 id="拉取更新">拉取更新</h1><p>git Pull</p><p>相当于git fetch和git merge两个命令的组合。简而言之，gitpull用于从远程仓库拉取更新并将它们合并到当前分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull &lt;remote&gt; &lt;branch&gt;<br></code></pre></td></tr></table></figure><p>git Fetch</p><p>gitfetch命令则是用于从远程仓库获取更新，但它不会自动合并到当前分支。相反，它将获取的更新保存在本地，让你可以在需要的时候进行合并操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch &lt;remote&gt; &lt;branch&gt;<br>git merge &lt;remote&gt;/&lt;branch&gt;<br></code></pre></td></tr></table></figure><h1 id="标签">标签</h1><p>需要记录每次reset的地址过于繁琐，因此，使用标签来替代</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag <span class="hljs-comment">#显示所有标签</span><br>git show &lt;tagname&gt; <span class="hljs-comment">#显示标签信息</span><br>git tag v1.0 <span class="hljs-comment">#给当前版本打标签</span><br>git tag v1.1 -m <span class="hljs-string">&quot;version 1.1 released&quot;</span> 1094adb <span class="hljs-comment">#指定地址和提示信息</span><br></code></pre></td></tr></table></figure><p>后续在使用该地址值，可以使用标签访问，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard v1.0<br></code></pre></td></tr></table></figure><p>删除标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -d v1.0<br></code></pre></td></tr></table></figure><p>推送标签到远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin v1.0 <span class="hljs-comment">#推送一个</span><br>git push origin --tags <span class="hljs-comment">#全部推送</span><br></code></pre></td></tr></table></figure><h1 id="其他参考">其他参考</h1><p><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用Git 命令清单 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href="https://git-scm.com/">Git (git-scm.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习笔记</title>
    <link href="/other/JavaWeb/"/>
    <url>/other/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h1 id="javaweb">JavaWeb</h1><blockquote><p>参考教程：https://www.bilibili.com/video/BV12J411M7Sj/</p></blockquote><p>JavaWeb是编写动态网页的方法，相对应的，HTML、CSS则是编写静态网页的方法。</p><p>JavaWeb包括如下几种实现：</p><p>1 ASP：微软开发。直接在HTML中嵌入VB代码，调试难度高。</p><p>2 PHP：代码简单，容易实现。但难以承载高访问量。</p><p>3 JSP/Servlet：Sun公司开发。语法类似于ASP，能够承载高访问量。</p><h1 id="tomcat">1 Tomcat</h1><p>Tomcat是一种<strong>开源</strong>的服务器程序，适用于<strong>轻量级</strong>企业应用开发。</p><p>Tomcat为HTML服务，但实际上运行的是JSP和Servlet。</p><p><strong>Tomcat根目录文件解析</strong></p><figure><img src="/other/JavaWeb/image-20241210164623711.png" alt="image-20241210164623711"><figcaption aria-hidden="true">image-20241210164623711</figcaption></figure><p>bin——脚本：启动、运行服务器等操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">startup.bat -- 开启<br>​shutdown.bat -- 关闭<br></code></pre></td></tr></table></figure><p>conf——配置文件：配置端口号、域名等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">默认端口：<span class="hljs-number">8080</span><br>​默认域名：localhost<br></code></pre></td></tr></table></figure><p>在此处可以修改 tomcat 域名 和 端口号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">maxParameterCount</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">           /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost&quot;</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">&quot;webapps&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>webapps——Web应用：每个文件夹对应一个应用</p><p>在Webapps中，有tomcat的5个默认web应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">examples——tomcat 实例<br>​Root——tomcat 默认首页<br>​docs——tomcat 文档说明<br></code></pre></td></tr></table></figure><h1 id="http">2 HTTP</h1><h2 id="文本传输协议">2-1 文本传输协议</h2><p>HTTP（超文本传输协议）是一种简单的请求-响应协议，通常运行在TCP之上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">文本：字符串<br>超文本：图片、视频、音频、地图等<br></code></pre></td></tr></table></figure><p>HTTPS 相比 HTTP 更安全</p><h2 id="请求行">2-2 请求行</h2><p>Get：携带的参数较少，大小有限制，会在浏览器URL行显示参数，不安全，但高效</p><p>Post：携带的参数没有限制，大小没有限制，不会在浏览器URL行显示参数，不安全，但高效</p><h2 id="消息头">2-3 消息头</h2><p>请求www.baidu.com的消息头</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">content-encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7<br><span class="hljs-attribute">accept-encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br, zstd<br><span class="hljs-attribute">accept-language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6<br><span class="hljs-attribute">host</span><span class="hljs-punctuation">: </span>www.baidu.com<br></code></pre></td></tr></table></figure><h2 id="常见响应状态码">2-4 常见响应状态码</h2><p>200：请求响应成功</p><p>3xx：请求重定向</p><p>404：资源不存在</p><p>5xx：服务器错误</p><h1 id="maven">3 Maven</h1><p>Maven 是一个项目管理工具，它包含了一个项目<strong>对象模型</strong><code>(POM：Project Object Model)</code></p><p>它的主要功能有：</p><ul><li>标准化的项目结构</li><li>标准化的构建流程（编译，测试，打包，发布……）</li><li>对 jar 的统一管理</li></ul><h2 id="配置maven下载镜像">3-1 配置Maven下载镜像</h2><p>idea自带的Maven放置在：JetBrainsIDEA 2024.2.2 目录下</p><p>进入maven3文件夹，修改.xml 中的配置为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>huaweicloud<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>external:*,!aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>华为云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://mirrors.huaweicloud.com/repository/maven/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>apachemaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>external:*,!aliyunmaven,!huaweicloud<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>apache公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.maven.apache.org/maven2<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置maven本地仓库">3-2 配置Maven本地仓库</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- localRepository</span><br><span class="hljs-comment"> | The path to the local repository maven will use to store artifacts.</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> | Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="hljs-comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\JetBrains\IntelliJ IDEA 2024.2.2\plugins\maven\lib\maven3\maven-repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在setting.xml的此处添加仓库地址，jar包将被保存在这。</p><h2 id="在idea中使用maven">3-3 在IDEA中使用Maven</h2><p>首先，在IDEA中创建一个Maven项目</p><p>Maven Archetype 选择org.apache.maven.archetypes:maven-archetype-webapp</p><p>然后，我们得到如下的项目。</p><figure><img src="/other/JavaWeb/image-20241210214716241.png" alt="image-20241210214716241"><figcaption aria-hidden="true">image-20241210214716241</figcaption></figure><p>src ---- 编译前（源文件）</p><p>​ main ---- 主程序</p><p>​ java ---- 存放java源代码</p><p>​ resources ---- 资源文件</p><p>​ webapp ---- 网页APP</p><p>​ WEB-INF ---- 配置文件</p><p>​ index.jsp ---- 默认网页</p><p>​ test ---- 调试程序</p><p>target ---- 编译后</p><h2 id="在idea中配置tomcat">3-4 在IDEA中配置Tomcat</h2><p>在IDEA中新建一个Run/Debug Configurations，选择TomcatServer/local。</p><p>此时下方会显示：</p><figure><img src="/other/JavaWeb/image-20241210215703206.png" alt="image-20241210215703206"><figcaption aria-hidden="true">image-20241210215703206</figcaption></figure><p>这是因为没有正确配置启动网页。这里按Fix，会自动跳转到配置页面：</p><figure><img src="/other/JavaWeb/image-20241210215820870.png" alt="image-20241210215820870"><figcaption aria-hidden="true">image-20241210215820870</figcaption></figure><p>这里我们新建了一个启动路径。此处可以配置Applicationcontext，如下。</p><figure><img src="/other/JavaWeb/image-20241210215936803.png" alt="image-20241210215936803"><figcaption aria-hidden="true">image-20241210215936803</figcaption></figure><p>这会改变网页的URL，变为：<a href="http://localhost:8080/welcome/">localhost:8080/welcome/</a></p><h2 id="在maven中导入jar包">3-5 在Maven中导入Jar包</h2><p>在Maven项目的根目录下，pom.xml中说明了各种项目配置。</p><figure><img src="/other/JavaWeb/image-20241210221608980.png" alt="image-20241210221608980"><figcaption aria-hidden="true">image-20241210221608980</figcaption></figure><p>比如，这里我们就导入了junit这个测试用的jar包。</p><p>我们也可以在<a href="https://mvnrepository.com/">Maven Repository:Search/Browse/Explore</a>中搜索各种所需jar包的dependency格式。</p><p>比如，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>pom.xml修改后，Maven会自动安装所依赖的jar包。</p><p>如果不需要某个包，也可以直接删除对应的dependency。</p><h1 id="servlet">4 Servlet</h1><h2 id="servlet原理">4-1 Servlet原理</h2><p>Sun公司提供了一个Servlet接口，用于实现动态Web。</p><p>在用户向Web服务器发送请求时，会首先调用Servlet实现类。</p><p>这个实现Servlet接口的java类，被称作Servlet。</p><figure><img src="/other/JavaWeb/image-20241212125332856.png" alt="image-20241212125332856"><figcaption aria-hidden="true">image-20241212125332856</figcaption></figure><p>Servlet继承图</p><figure><img src="/other/JavaWeb/image-20241212130019986.png" alt="image-20241212130019986"><figcaption aria-hidden="true">image-20241212130019986</figcaption></figure><h2 id="web子项目">4-2 WEB子项目</h2><p>在IDEA的Project中创建Module，同样选择mavenwebapp模板，就在父项目下创建了子项目，比如，这里创建在javaweb-02-servlet下创建了servlet-01子项目。</p><figure><img src="/other/JavaWeb/image-20241212125102669.png" alt="image-20241212125102669"><figcaption aria-hidden="true">image-20241212125102669</figcaption></figure><p>子项目同样具有pom.xml配置。此外，在pom.xml中也配置了项目关联信息。</p><p>父项目pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>servlet-01<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子项目pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javaweb-02-servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子项目中的类被允许继承父项目中的类。</p><h2 id="servlet映射">4-3 Servlet映射</h2><p>为了让Web服务器找到对应的Servlet，我们需要建立 URL 到 Servlet的映射。</p><p>该映射可以在web.xml中编写，如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- Servlet 名称 到 类 的映射--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.chen.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Servlet 名称 到 URL 的映射 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="httpservlet基础">4-4 HttpServlet基础</h2><p>Step1：在Maven中导入相关依赖（Servlet和JSP）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Step2：创建java类，继承HttpServlet</p><p>Step3：重写doGet和doPost方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;DoGet方法正在被调用&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>        out.println(<span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;body&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;h2&gt;HelloServlet&lt;/h2&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;/body&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);<br>        <span class="hljs-comment">//super.doGet(req,resp);</span><br>        <span class="hljs-comment">// IDEA会自动加上父类的doGet方法</span><br>        <span class="hljs-comment">// 但这里不要调用，因为默认返回405错误</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp); <span class="hljs-comment">// doPost和doGet业务相同时，调用doGet即可</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context上下文">4-5 Context上下文</h2><p>ServletContext 也叫做 Servlet 上下文。这个对象全局唯一且被项目类所有Servlet 共享，所有叫全局应用程序共享对象</p><p>我们可以在ServletContext中保存全局参数。</p><p><strong>1）ServletContext保存参数</strong></p><p>保存参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CHEN&quot;</span>;<br>con.setAttribute(<span class="hljs-string">&quot;username&quot;</span>,username);<br>resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>out.println(<span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;body&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;h2&gt;设置成功&lt;/h2&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;/body&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);<br></code></pre></td></tr></table></figure><p>提取参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String) con.getAttribute(<span class="hljs-string">&quot;username&quot;</span>);<br><span class="hljs-comment">// 此处用到了ContextType。这个Context标识了网页显示的格式。</span><br><span class="hljs-comment">// text/html ： HTML格式</span><br>resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br><span class="hljs-comment">// 为了显示中文，还需要设置编码方式</span><br>resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>out.println(<span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;body&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;h2&gt;名字：&quot;</span>  + username + <span class="hljs-string">&quot;&lt;/h2&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;/body&gt;\n&quot;</span> +<br>        <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>2）web.xml保存初始化参数</strong></p><p>web.xml保存参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>msg<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>this is a temporary message<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><p>servlet提取参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> con.getInitParameter(<span class="hljs-string">&quot;msg&quot;</span>);<br>out.println(msg);<br></code></pre></td></tr></table></figure><p><strong>3）resources保存初始化参数</strong></p><p>properties保存参数</p><p>在资源文件夹中新建一个properties文件，保存参数信息。</p><figure><img src="/other/JavaWeb/image-20241212153029738.png" alt="image-20241212153029738"><figcaption aria-hidden="true">image-20241212153029738</figcaption></figure><p>例如，下面的db.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><p>servlet提取参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个文件在编译后，将保存在target/classes/路径下。</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/WEB-INF/classes/db.properties&quot;</span>);<br><span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>prop.load(is);<br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> prop.getProperty(<span class="hljs-string">&quot;username&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> prop.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>resp.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>out.println(username + <span class="hljs-string">&quot; -&gt; &quot;</span> + password);<br></code></pre></td></tr></table></figure><h2 id="下载文件验证码">4-5 下载文件、验证码</h2><p>下面两个实例说明了Response的基本用法。</p><p><strong>下载文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 响应设置</span><br>        resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C:\\Users\\chenz\\Desktop\\javaweb-02-servlet\\response\\src\\main\\resources\\java.png&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> realPath.substring(realPath.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>) + <span class="hljs-number">1</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=&quot;</span> + fileName);<br>        <br>        <span class="hljs-comment">// 输入输出流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(realPath);<br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">sot</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> ((len = fis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>            sot.write(buffer, <span class="hljs-number">0</span>, len);<br>            sot.flush();<br>        &#125;<br>        sot.close();<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：没有打开新的网页，输入网址直接下载附件</p><figure><img src="/other/JavaWeb/image-20241212223035609.png" alt="image-20241212223035609"><figcaption aria-hidden="true">image-20241212223035609</figcaption></figure><p><strong>验证码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><span class="hljs-comment">// 画图</span><br>        <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedImage</span>(<span class="hljs-number">80</span>,<span class="hljs-number">20</span>,BufferedImage.TYPE_INT_RGB);<br>        <span class="hljs-type">Graphics2D</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> (Graphics2D)image.getGraphics();<br>        g.setColor(Color.white);<br>        g.fillRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">80</span>,<span class="hljs-number">20</span>);<br>        g.setColor(Color.blue);<br>        g.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-literal">null</span>,Font.BOLD,<span class="hljs-number">20</span>));<br>        g.drawString(getNumber(),<span class="hljs-number">0</span>,<span class="hljs-number">20</span>);<br>        ImageIO.write(image,<span class="hljs-string">&quot;jpg&quot;</span>,resp.getOutputStream());<br><span class="hljs-comment">// 响应设置</span><br>        resp.setContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<br>        resp.setDateHeader(<span class="hljs-string">&quot;expires&quot;</span>,-<span class="hljs-number">1</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;refresh&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 返回随机数字符串</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">9999999</span>) + <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>-num.length(); i++) &#123;<br>            sb.append(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125;<br>        num = sb + num;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：显示如下的验证码，每3秒刷新一次</p><figure><img src="/other/JavaWeb/image-20241212223136099.png" alt="image-20241212223136099"><figcaption aria-hidden="true">image-20241212223136099</figcaption></figure><h2 id="表单">4-6 表单</h2><p><strong>Index.jsp</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;body&gt;<br><br>&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;</span> method = <span class="hljs-string">&quot;get&quot;</span>&gt;<br>    用户名&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name = <span class="hljs-string">&quot;username&quot;</span>&gt; &lt;br&gt;<br>    密码 &lt;input type=<span class="hljs-string">&quot;password&quot;</span> name = <span class="hljs-string">&quot;password&quot;</span>&gt; &lt;br&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span>&gt;<br>&lt;/form&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>注意，这里使用${pageContext.request.contextPath}，要求jsp版本在2.3以上；</p><p>此外，还需要更新web.xml中的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>RequestServlet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>        <span class="hljs-comment">// 提取参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>        out.println(<span class="hljs-string">&quot;username : &quot;</span> + username + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;password : &quot;</span> + password + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);<br>        <span class="hljs-comment">// 重定向</span><br>        resp.sendRedirect(req.getContextPath() + <span class="hljs-string">&quot;/success.jsp&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重定向和转发">4-7 重定向和转发</h2><p>请求转发（Forward）：<strong>发生在服务端程序内部</strong>，服务器端收到客户端的请求后，先将请求转发给目标地址，再将目标地址返回的结果转发给客户端。</p><p>请求重定向（Redirect）：服务器端收到客户端的请求后，给客户端返回记录了新地址的临时响应头。客户端需要再次向（重定向）的URL 地址发送请求。</p><p><strong>重定向</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedirectServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.sendRedirect(<span class="hljs-string">&quot;/response/image&quot;</span>);<br>        <span class="hljs-comment">// 重定向相当于下面这两行代码</span><br>        <span class="hljs-comment">// resp.setHeader(&quot;Location&quot;, &quot;/response/image&quot;); // 设置URL</span><br>        <span class="hljs-comment">// resp.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY); // 代码：302</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>转发</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// 请求转发</span><br>        <span class="hljs-comment">// 不改变URL</span><br>        req.getRequestDispatcher(<span class="hljs-string">&quot;/image&quot;</span>).forward(req, resp);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="会话">4-8 会话</h2><p>HTTP是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。</p><p>但服务器需要知道http请求是哪个用户发起的，从而判断用户是否有权限继续这个请求。</p><p>这个过程就是常说的会话管理。保存会话主要有两种实现方式：Cookie 和Session。</p><p><strong>1）Cookie</strong></p><p>Cookie是一种客户端技术，服务器将用户信息保存在Cookie中，并发送给客户端。</p><p>下次再次访问网址时，服务器可调用客户端Cookie中的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CookieServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>        req.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <br>        Cookie[] cookies = req.getCookies();<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">vis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 寻找名为name的cookie</span><br>        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;<br>            <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">&quot;name&quot;</span>)) &#123;<br>                out.println(<span class="hljs-string">&quot;你的名字是&quot;</span> + cookie.getValue());<br>                vis = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!vis) &#123;<br>            out.println(<span class="hljs-string">&quot;这是你第一次访问本站&quot;</span>);<br>            <span class="hljs-comment">// 创建并保存cookie</span><br>            resp.addCookie(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;chen&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于Cookie：</p><ul><li>一个Cookie只能保存一个信息，大小限制为4kb</li><li>一个浏览器最多保存300个Cookie</li><li>一个站点最多可发送20个Cookie</li></ul><p><strong>2）Session</strong></p><p>Session是一种服务器技术，服务器为每个用户（浏览器）建立一个Session。</p><p>Session和Cookie一样地保存用户信息。(例如：购物车的信息)</p><p>只要浏览器没关闭，Session就一直存在，避免“一次浏览，多次登录”的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SessionServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>        session.setAttribute(<span class="hljs-string">&quot;hobby&quot;</span>,<span class="hljs-string">&quot;basketball&quot;</span>);<br><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>        <span class="hljs-comment">// session 在首页创建之初就已经创建</span><br>        <span class="hljs-comment">// 必然是false</span><br>        <span class="hljs-keyword">if</span>(session.isNew())&#123;<br>            out.println(<span class="hljs-string">&quot;Session is new&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            out.println(<span class="hljs-string">&quot;Session is not new &lt;br&gt;&quot;</span> );<br>            out.println(session.getId() + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;hobby -&gt; &quot;</span> + session.getAttribute(<span class="hljs-string">&quot;hobby&quot;</span>));<br>        &#125;<br>        <span class="hljs-comment">// 删除元素</span><br>        <span class="hljs-comment">// session.removeAttribute(&quot;hobby&quot;);</span><br>        <span class="hljs-comment">// 手动注销session，重新创建后ID不同</span><br>        <span class="hljs-comment">// session.invalidate();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>web.xml设置Session自动注销</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 单位为分钟 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>24*60<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="jsp">5 JSP</h1><h2 id="jsp原理">5-1 JSP原理</h2><p>jsp本质是一个Servlet。JSP被首先被转换成Java-servlet文件，并被编译称为class字节码。用户访问的网页，实质是JSP转化并编译后的Servlet。</p><figure><img src="/other/JavaWeb/image-20241213113329565.png" alt="image-20241213113329565"><figcaption aria-hidden="true">image-20241213113329565</figcaption></figure><p>JSP转换为java-servlet的过程：</p><p>HTML -&gt; out.println("HTML")； Java代码 -&gt; 原封不动。</p><h2 id="jsp基础语法">5-2 JSP基础语法</h2><p>JSP四种基础构成</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%=JSP表达式%&gt;   <br>&lt;%JSP代码片段%&gt;<br>&lt;%!JSP全局声明%&gt;<br>&lt;!--注释--&gt;<br></code></pre></td></tr></table></figure><p>JSP表达式</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;h1&gt;<br>    &lt;%=<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date()%&gt;<br>&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p>JSP代码片段</p><p>&lt;%%&gt; 内的代码将在jsp-Servlet类的jsp_service方法中运行输出。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;h2&gt;<br>    &lt;%<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt;= <span class="hljs-number">100</span> ; i ++)&#123;<br>        sum += i;<br>    &#125;<br>    out.println(<span class="hljs-string">&quot;sum == &quot;</span> + sum);<br>    %&gt;<br>&lt;/h2&gt;<br></code></pre></td></tr></table></figure><p>JSP全局声明</p><p>&lt;%!%&gt; 内的方法和变量将声明在jsp-servlet类中</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%!<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        cnt++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am working...&quot;</span> + cnt;<br>    &#125;<br>%&gt;<br>&lt;h2&gt;<br>    &lt;%<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i ++)&#123;<br>        out.println(work() + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>);<br>    &#125;<br>    %&gt;<br>&lt;/h2&gt;<br></code></pre></td></tr></table></figure><h2 id="错误页面跳转">5-3 错误页面跳转</h2><p>在webapp目录下，新建error文件夹以存放错误跳转的jsp。</p><p>方法1：JSP page声明</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;!--错误跳转的路径--&gt;<br>&lt;%<span class="hljs-meta">@page</span> errorPage=<span class="hljs-string">&quot;error/500.jsp&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;body&gt;<br>&lt;h2&gt;Hello World!&lt;/h2&gt;<br>&lt;%<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>此时，若该页面发生任何错误，都会跳转500.jsp页面</p><p>方法2：web.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>   ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>500<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/error/500.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/error/404.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时，在任意网页发生500错误，跳转500.jsp；404同理。</p><h2 id="页面包含">5-4 页面包含</h2><p>1）静态包含</p><p><strong>＜%@ include file=”relativeURI”%＞</strong>可以叫作静态include（静态包含）。</p><p>本质是 “先包含，后编译” ，直接把子页面的jsp代码写入父页面了。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;%<span class="hljs-meta">@include</span> file =<span class="hljs-string">&quot;header.jsp&quot;</span>%&gt;<br>&lt;body&gt;<br>&lt;h1&gt;I am body&lt;/h1&gt;<br>&lt;/body&gt;<br>&lt;%<span class="hljs-meta">@include</span> file =<span class="hljs-string">&quot;header.jsp&quot;</span>%&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>2）动态包含</p><p><strong>＜jsp:include page=”relativeURI” flush=”true”/＞</strong>可以叫作动态include（动态包含）</p><p>本质是 “先编译，后包含” ，本质是三个jsp同时显示。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;jsp:<span class="hljs-type">include</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;header.jsp&quot;</span>/&gt;<br>&lt;body&gt;<br>&lt;h1&gt;I am body&lt;/h1&gt;<br>&lt;/body&gt;<br>&lt;jsp:<span class="hljs-type">include</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;footer.jsp&quot;</span>/&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="jsp内置对象">5-5 JSP内置对象</h2><p>JSP转成的Servlet中内置了9大对象，如下</p><ul><li>out对象：用于向客户端、浏览器<strong>输出</strong>数据。</li><li>request对象：来自<strong>客户端、浏览器的信息</strong>。</li><li>response对象：<strong>服务器的响应信息</strong>。</li><li>exception对象：jsp程序的异常和错误信息。</li><li>config对象：应用程序的配置信息。</li><li>page对象：当前jsp程序本身。</li><li>session对象：会话信息。</li><li>application对象：代表了当前应用程序的上下文。</li><li>pageContext对象：提供了对<strong>jsp页面所有对象</strong>以及命名空间的访问。</li></ul><p>其中，pageContext、request、session、application是主要的存储变量信息的四个对象，具有不同的生存期。</p><p>下面是一个参数提取示例。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;body&gt;<br>&lt;%<br>    pageContext.setAttribute(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-string">&quot;chen1&quot;</span>);<br>    request.setAttribute(<span class="hljs-string">&quot;name2&quot;</span>,<span class="hljs-string">&quot;chen2&quot;</span>);<br>    session.setAttribute(<span class="hljs-string">&quot;name3&quot;</span>,<span class="hljs-string">&quot;chen3&quot;</span>);<br>    application.setAttribute(<span class="hljs-string">&quot;name4&quot;</span>,<span class="hljs-string">&quot;chen4&quot;</span>);<br>%&gt;<br>&lt;!--可以使用对应对象的getAttribute方法查找<br>    此处使用pageContext的findAttribute方法，<br>    查找顺序依次是：pageContext -&gt; request -&gt; session -&gt; application -&gt; <span class="hljs-string">&quot;return null&quot;</span><br>--&gt;<br>&lt;%<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> (String) pageContext.findAttribute(<span class="hljs-string">&quot;name1&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name2</span> <span class="hljs-operator">=</span> (String) pageContext.findAttribute(<span class="hljs-string">&quot;name2&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name3</span> <span class="hljs-operator">=</span> (String) pageContext.findAttribute(<span class="hljs-string">&quot;name3&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name4</span> <span class="hljs-operator">=</span> (String) pageContext.findAttribute(<span class="hljs-string">&quot;name4&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name5</span> <span class="hljs-operator">=</span> (String) pageContext.findAttribute(<span class="hljs-string">&quot;name5&quot;</span>);<br>%&gt;<br>&lt;h1&gt;$&#123;name1&#125;&lt;/h1&gt;<br>&lt;h1&gt;$&#123;name2&#125;&lt;/h1&gt;<br>&lt;h1&gt;$&#123;name3&#125;&lt;/h1&gt;<br>&lt;h1&gt;$&#123;name4&#125;&lt;/h1&gt;<br>&lt;!--此处使用el表达式会不显示，但使用jsp取值表达式可以显示<span class="hljs-literal">null</span><br>&lt;h1&gt;$&#123;name5&#125;&lt;/h1&gt;<br>--&gt;<br>&lt;h1&gt;&lt;%=name5%&gt;&lt;/h1&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="jspjstl标签">5-6 JSP、JSTL标签</h2><p>JSP标签是对java代码的封装，而JSTL是对JSP原生标签的补充。</p><p>示例1：使用JSP原生标签实现forward转发</p><p>index.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:<span class="hljs-type">forward</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jsp1.jsp&quot;</span>&gt;<br>    &lt;jsp:<span class="hljs-type">param</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username&quot;</span> value = <span class="hljs-string">&quot;chen&quot;</span>/&gt;<br>    &lt;jsp:<span class="hljs-type">param</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;password&quot;</span> value = <span class="hljs-string">&quot;1234456&quot;</span>/&gt;<br>&lt;/jsp:forward&gt;<br></code></pre></td></tr></table></figure><p>jsp1.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String)request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> (String)request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>%&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;username: &lt;%=username%&gt;&lt;/h1&gt;<br>    &lt;h1&gt;password: &lt;%=password%&gt;&lt;/h1&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>JSTL： <a href="https://www.runoob.com/jsp/jsp-jstl.html">JSP标准标签库（JSTL） | 菜鸟教程</a></p><h2 id="el表达式">5-7 EL表达式</h2><p><a href="https://www.cnblogs.com/w-wfy/p/6414117.html">java----EL表达式 -wwfy - 博客园</a></p><h1 id="mvc架构">6 MVC架构</h1><h2 id="javabean">6-1 JavaBean</h2><p>JavaBean，也叫做“实体类”，是一个满足如下要求的java类：</p><ul><li>必须有一个无参构造</li><li>属性全为Private私有</li><li>属性有对应的set和get方法</li></ul><p>通常来说，JavaBean类被用作 类 &lt;-&gt;数据表 的 映射（ORM）。</p><p>比如对于下面这个表：</p><table><thead><tr><th>学生</th><th>学号</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>小明</td><td>1</td><td>男</td><td>18</td></tr><tr><td>小红</td><td>2</td><td>女</td><td>20</td></tr><tr><td>小刚</td><td>3</td><td>男</td><td>19</td></tr></tbody></table><p>新建一个Student类，来映射它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    Student()&#123;<br>        id = <span class="hljs-number">99999</span>;<br>        name = <span class="hljs-literal">null</span>;<br>        age = <span class="hljs-number">0</span>;<br>    &#125;<br>    Student(<span class="hljs-type">int</span> id, String name, <span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id_)</span> &#123;id = id_&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-built_in">this</span>.age = age; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> id; &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> age; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mvc架构解析">6-2 MVC架构解析</h2><figure><img src="/other/JavaWeb/image-20241213212944980.png" alt="image-20241213212944980"><figcaption aria-hidden="true">image-20241213212944980</figcaption></figure><h1 id="过滤器监听器">7 过滤器、监听器</h1><h2 id="filter过滤器">7-1 Filter过滤器</h2><p>Filter也称之为过滤器。</p><p>WEB开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp,Servlet,静态图片文件或静态html文件等进行拦截，从而实现一些特殊的功能。</p><p>使用过滤器可以实现：权限访问控制、过滤敏感词汇、压缩响应信息等。</p><p>下面的示例，使用过滤器解决了 中文乱码问题</p><p>CharacterEncodingFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterEncodingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-comment">// 处理编码</span><br>        servletRequest.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        servletResponse.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-comment">// 若存在，继续执行下一个过滤器</span><br>        System.out.println(<span class="hljs-string">&quot;filter working...&quot;</span>);<br>        filterChain.doFilter(servletRequest, servletResponse);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Filter destroyed&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;Filter initializing&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>web.xml配置filter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ShowServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.chen.ShowServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ShowServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/filter<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ShowServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/show<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.chen.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--只过滤/filter/*路径的servlet--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/filter/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2024-国赛题解</title>
    <link href="/competition/RAICOM-CAIP/2024-%E5%9B%BD%E8%B5%9B/"/>
    <url>/competition/RAICOM-CAIP/2024-%E5%9B%BD%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-大家一起查作弊字符串处理">RC-u1大家一起查作弊（字符串处理）</h1><blockquote><p>分数 15 作者 DAI, Longao 单位 杭州百腾教育科技有限公司</p></blockquote><p>在今年的睿抗比赛上，有同学的提交代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">asfiasfgwef12</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> tsadflas=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> masf11233=<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span>[]wasdf1213= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span> +<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span>[] vasf124l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span> + I];<br><span class="hljs-type">int</span>[][] ddasf1234p= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[masf11233<br>...<br></code></pre></td></tr></table></figure><p>你肯定很奇怪，这看上去代码似乎不像是正常写出来的代码呀？没错，这是这位同学在网络上购买了所谓的“保研综测套餐”，商家为逃避赛后查重，给这位同学发去了经过混淆的代码。然而经过技术支持方的努力，这位同学不仅被封禁，与TA购买了相同“套餐”的同学也利用技术手段全部查出，目前主办方已向警方报案，这些同学的“保研”梦很有可能会转变为“案底”梦……因此如果你在比赛前也购买了类似的服务，现在迷途知返还来得及——毕竟这个商家起码还做了一些努力，许多商家号称“一对一”，实际上将一份代码发给了数十位同学……</p><p>回到题目，虽然具体检查的手段无法公开，但我们可以尝试简化再简化的手段来找到被这样混淆的程序。对于给定的大量字符串，你首先要提取出所有的<strong>关键词</strong>。一个<strong>关键词</strong>的定义是：由大写字母、小写字母、数字组成的字符串，并且前后均为非大小写字母及数字（包含开头及换行符）。如以下的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] vasf124l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span> + I];<br></code></pre></td></tr></table></figure><p>关键词为：<code>int</code>、<code>vasf124l</code>、<code>new</code>、<code>int</code>、<code>10</code>以及<code>I</code>。</p><p>然后对于所有关键词，你需要计算<strong>可疑分数</strong>的和以及关键词平均长度。其中一个关键词的<strong>可疑分数</strong>如下定义：</p><ul><li>如果一个关键词同时包含大写字母、小写字母、数字，则分数 + 5 分；</li><li>否则，如同时包含（大写字母、数字）或（小写字母、数字）的，分数 + 3分；</li><li>否则，如同时包含（大写字母、小写字母）的，分数 + 1 分；</li><li>其余情况不加分。</li></ul><p>对于给定的数据，请你输出所有关键词的<strong>可疑分数</strong>的和、长度的和以及数量。</p><h3 id="输入格式">输入格式</h3><p>输入包含若干行字符串，表示待检测的程序。保证每行字符串的长度不超过1000（除了一行最后的换行符外），输入总长度不超过6×104，并且至少有一个关键词。</p><h3 id="输出格式">输出格式</h3><p>对于输入的所有字符串，第一行输出可疑分数的和，第二行输出关键词的总长度以及关键词的个数（以避免计算平均值带来的浮点误差），用一个空格隔开。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs in">static void nnmMNBkf3kfa()&#123;<br>    int fefvB4=2;<br>    int [][]fsdk9A=new int[fefvB4][fefvB4];<br>    fsdk9A[0][0]=1;<br>    for (int gfdgsUB3 = 0; gfdgsUB3 &lt; fefvB4; gfdgsUB3++) &#123;<br>        for (int fdnbXZ8 = 0; fdnbXZ8&lt;fefvB4-gfdgsUB3-1; fdnbXZ8++) &#123;<br>            fsdk9A[gfdgsUB3][fdnbXZ8+1]=fsdk9A[gfdgsUB3][fdnbXZ8]+gfdgsUB3+fdnbXZ8+2;<br>            fsdk9A[gfdgsUB3+1][fdnbXZ8]=fsdk9A[gfdgsUB3][fdnbXZ8]+gfdgsUB3+fdnbXZ8+1;<br>            break;<br>        &#125;<br>        break;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">155<br>276 54<br></code></pre></td></tr></table></figure><h3 id="解法">解法</h3><blockquote><p>比赛时用getline一直卡样例，后来用cin才过，不知道什么原因：)</p></blockquote><p>Step1：依次读入每个字符串，按非数字/字母字符进行分割。</p><p>Step2：计算每个字符串的得分，并统计。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string str;<br><span class="hljs-type">int</span> ans,lens,sum;<br>vector&lt;string&gt; v;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br><span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">while</span>(i &lt; len)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(s[i]) != <span class="hljs-number">4</span>)&#123;<br><span class="hljs-type">int</span> j = i;<br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">judge</span>(s[j]) != <span class="hljs-number">4</span>)&#123;<br>res = res + s[j];<br>j++;<br>&#125;<br>v.<span class="hljs-built_in">push_back</span>(res); <br>i = j;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>i++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">bool</span> f1 = <span class="hljs-literal">false</span>;<br><span class="hljs-type">bool</span> f2 = <span class="hljs-literal">false</span>;<br><span class="hljs-type">bool</span> f3 = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : s)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(it) == <span class="hljs-number">1</span>) f1 = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(it) == <span class="hljs-number">2</span>) f2 = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(it) == <span class="hljs-number">3</span>) f3 = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(f1 &amp;&amp; f2 &amp;&amp; f3) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span>((f1 || f2) &amp;&amp; f3) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(f1 &amp;&amp; f2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;str)&#123;<br>str = <span class="hljs-string">&quot; &quot;</span> + str + <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-built_in">process</span>(str);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : v)&#123;<br>ans += <span class="hljs-built_in">getScore</span>(it);<br>lens += it.<span class="hljs-built_in">length</span>();<br>sum += <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>cout&lt;&lt;lens&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;sum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="rc-u2-谁进线下了ii模拟">RC-u2 谁进线下了？II（模拟）</h1><blockquote><p>分数 20 作者 DAI, Longao 单位 杭州百腾教育科技有限公司</p></blockquote><p><em>Xepa Legends</em>是一个第一人称射击类大逃杀（“吃鸡”）游戏，每局游戏共有 20 支 3人小队参加，最后获胜的队伍被称为“捍卫者”。</p><p>最近 <em>Xepa Legends</em> 举行了亚太地区南赛区的线上比赛，争夺 7个前往德国曼海姆参加线下赛的资格，国内共有 14支队伍参与到了其中。因为比赛十分激烈，直到最后谁进了线下仍有巨大的疑问。小K 喜欢的国内知名战队 <em>DreamTear</em>因其队内选手<em>杀马特</em>表现不佳，正好卡在出线分数前后，请你赶紧帮帮小K，计算一下最后的分数情况，看看他喜欢的战队出线了没有吧！</p><p><em>Xepa Legends</em> 的常规赛共有 30 支队伍参加，被分为三组，进行<em>N</em> 轮比赛，每轮由三组中的两组组成 20支队伍的参赛阵容，进行若干场比赛，最后每个队伍会获得一个当轮比赛的排名。</p><p>对于每轮比赛，队伍会根据排名获得一个在当轮比赛的<strong>赋分</strong>：</p><table><thead><tr><th>排名</th><th>分数</th></tr></thead><tbody><tr><td>第一名</td><td>25 分</td></tr><tr><td>第二名</td><td>21 分</td></tr><tr><td>第三名</td><td>18 分</td></tr><tr><td>第四名</td><td>16 分</td></tr><tr><td>第五名</td><td>15 分</td></tr><tr><td>第六名</td><td>14 分</td></tr><tr><td>第七名</td><td>13 分</td></tr><tr><td>第八名</td><td>12 分</td></tr><tr><td>第九名</td><td>11 分</td></tr><tr><td>第十名</td><td>10 分</td></tr><tr><td>第十一名</td><td>9 分</td></tr><tr><td>第十二名</td><td>8 分</td></tr><tr><td>第十三名</td><td>7 分</td></tr><tr><td>第十四名</td><td>6 分</td></tr><tr><td>第十五名</td><td>5 分</td></tr><tr><td>第十六名</td><td>4 分</td></tr><tr><td>第十七名</td><td>3 分</td></tr><tr><td>第十八名</td><td>2 分</td></tr><tr><td>第十九名</td><td>1 分</td></tr><tr><td>第二十名</td><td>0 分</td></tr></tbody></table><p>给定若干轮比赛队伍获得的当轮比赛排名，请你计算出队伍的赋分，并在若干轮比赛后计算出总赋分，从而最终确定<em>DreamTear</em> 战队能否进入线下，还是只能耍耍花招了。</p><p>例如，</p><ul><li><em>DreamTear</em> 战队在第一轮比赛中获得了第 17名，第三轮比赛中获得了第 11 名，第四轮比赛中获得了第 11 名，那么<em>DreamTear</em> 战队可获 3 + 9 + 9 = 21 分的赋分；</li><li><em>KV</em> 战队在第一轮比赛中获得了第 10 名，第三轮比赛中获得了第 2名，第四轮比赛中获得了第 6 名，那么他们可获得 10 + 21 + 14 = 45分的赋分。</li></ul><p><em>注：本题与实际情况无关，所有比赛规则、队伍、队员名称均为虚构。</em></p><h3 id="输入格式-1">输入格式</h3><p>输入第一行是一个正整数 <em>N</em> (≤20)，表示有 <em>N</em>轮比赛。</p><p>接下来有 <em>N</em>部分输入，每部分是一轮比赛的情况。对每一场比赛，信息共分 20 行，第<em>i</em> 行（<em>i</em>=1,⋯,20）给出的两个非负整数 <em>c</em> 和<em>p</em> 表示编号为 <em>c</em> 的队伍在这轮比赛里获得了第 <em>p</em>名。</p><p>数据保证所有给定的情况中，排名永远大于等于 1 且小于等于20，队伍编号由 1 开始，不超过 30。</p><h3 id="输出格式-1">输出格式</h3><p>输出若干行，按分数从大到小依次输出队伍的编号及该队所有轮次游戏结束后的总分。如分数相同，队伍编号较小的先输出。</p><p>注意由于统计的时候比赛可能并没有完全结束，所以每个队伍参加的比赛轮数不一定相同，此时仍然正常计分统计即可。不要输出未参赛的队伍分数。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>1 1<br>2 2<br>9 3<br>6 4<br>7 5<br>11 6<br>3 7<br>13 8<br>8 9<br>16 10<br>4 11<br>19 12<br>17 13<br>5 14<br>12 15<br>15 16<br>14 17<br>10 18<br>20 19<br>18 20<br>5 11<br>10 12<br>30 13<br>22 14<br>1 1<br>28 20<br>21 16<br>26 17<br>2 2<br>24 3<br>4 4<br>29 5<br>8 6<br>7 15<br>6 7<br>3 8<br>9 9<br>25 10<br>23 19<br>27 18<br>19 20<br>26 19<br>27 18<br>18 17<br>21 16<br>12 15<br>28 14<br>20 13<br>17 12<br>14 11<br>13 10<br>23 9<br>29 8<br>22 7<br>30 6<br>15 5<br>24 4<br>25 3<br>16 2<br>11 1<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs out">1 50<br>2 42<br>11 39<br>24 34<br>16 31<br>6 29<br>9 29<br>25 28<br>29 27<br>3 25<br>4 25<br>8 25<br>13 22<br>30 21<br>7 20<br>15 19<br>22 19<br>5 15<br>17 15<br>14 12<br>23 12<br>10 10<br>12 10<br>19 8<br>20 8<br>21 8<br>28 6<br>26 4<br>27 4<br>18 3<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><p>依题意构造出team结构体，进行排序并输出。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">team</span>&#123;<br><span class="hljs-type">int</span> score;<br><span class="hljs-type">int</span> id;<br><br><span class="hljs-built_in">team</span>(<span class="hljs-type">int</span> score_,<span class="hljs-type">int</span> id_)&#123;<br>score = score_;<br>id = id_;<br>&#125;;<br><br><span class="hljs-built_in">team</span>()&#123;<br>score = <span class="hljs-number">0</span>;<br>id = <span class="hljs-number">-1</span>;<br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(team a, team b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.score != b.score) <span class="hljs-keyword">return</span> a.score &gt; b.score;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><br>vector&lt;team&gt; v;<br>team te[MAX];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> sco[<span class="hljs-number">21</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">25</span>,<span class="hljs-number">21</span>,<span class="hljs-number">18</span>,<span class="hljs-number">16</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">13</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">20</span> ; j ++)&#123;<br><span class="hljs-type">int</span> c,p;cin&gt;&gt;c&gt;&gt;p;<br>te[c].id = c;<br>te[c].score += sco[p];<br>len = <span class="hljs-built_in">max</span>(c,len);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(te[i].id != <span class="hljs-number">-1</span>)&#123;<br>v.<span class="hljs-built_in">push_back</span>(te[i]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmp);<br><span class="hljs-type">int</span> lenv = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; lenv ; i ++)&#123;<br>cout&lt;&lt;v[i].id&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v[i].score&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-势均力敌dfs">RC-u3 势均力敌（DFS）</h1><blockquote><p>分数 25 作者 陈越 单位 浙江大学</p></blockquote><p>用 <em>n</em>&gt;2 个不同的个位数字组成一个 <em>n</em> 位数，显然有<em>n</em>! 个不同的结果。可以证明，这 <em>n</em>!个数字可以被分为<strong>势均力敌</strong>的两组 ——即平方和相等、且个数也相等的两组。 本题就请你用程序验证一下这个结论。因为本题是一道简单题，所以规模很小，只考虑 <em>n</em>≤4 的情况。</p><h3 id="输入格式-2">输入格式</h3><p>输入第一行给出正整数 <em>n</em>（2&lt;<em>n</em>≤4），随后一行给出<em>n</em> 个不同的、在区间 [1, 9] 内的个位数字，其间以空格分隔。</p><h3 id="输出格式-2">输出格式</h3><p>将所有组成的 <em>n</em>! 个不同的 <em>n</em>位数分为平方和相等、且个数也相等的两组。但你只需要输出其中一组就可以了。每个数字占一行，共输出<em>n</em>!/2 行。 注意：解可能不唯一，输出任何一组解就可以。</p><h3 id="输入样例-2">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>5 2 1<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">125<br>512<br>251<br></code></pre></td></tr></table></figure><h3 id="解法-2">解法</h3><p>依题n&lt;=4，数据量较小，可用DFS枚举。</p><p>Step1：枚举出所有可能的数字。</p><p>Step2：枚举所有可能的分组，找到第一种可行解后输出。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">5</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>vector&lt;<span class="hljs-type">int</span>&gt; temp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep,string s)</span></span>&#123; <span class="hljs-comment">//枚举出所有可能的数字</span><br><span class="hljs-keyword">if</span>(dep == n)&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : s)&#123;<br>res = res*<span class="hljs-number">10</span> + (it - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>v.<span class="hljs-built_in">push_back</span>(res);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!vis[i])&#123;<br>vis[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(dep + <span class="hljs-number">1</span>, s + <span class="hljs-built_in">char</span>(<span class="hljs-string">&#x27;0&#x27;</span> + a[i]));<br>vis[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> sum1, <span class="hljs-type">int</span> sum2)</span></span>&#123; <span class="hljs-comment">//枚举所有可能的分组</span><br><span class="hljs-keyword">if</span>(dep == (<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>())&#123;<br><span class="hljs-keyword">if</span>(sum1 == sum2)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : temp)&#123;<br>cout&lt;&lt;it&lt;&lt;endl;<br>&#125;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>temp.<span class="hljs-built_in">push_back</span>(v[dep]);<br><span class="hljs-built_in">dfs2</span>(dep<span class="hljs-number">+1</span>,sum1 + v[dep]*v[dep],sum2);<br>temp.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">dfs2</span>(dep<span class="hljs-number">+1</span>,sum1,sum2 + v[dep]*v[dep]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-city-不-citydijkstra">RC-u4 City 不 City（Dijkstra）</h1><blockquote><p>分数 30 作者 陈越 单位 浙江大学</p></blockquote><p>“City 不 City”因为一位外国友人保保熊直播旅游时总是用奇怪的腔调说“好city，啊！”而走红中国社交网络，成为网络热梗。事实上，有一些叛逆的年轻人在旅行时会刻意避开网红打卡点，选择一些小众的特色地方小城镇，不追求city，而喜欢说“好 country，啊”。下面给定各个城镇的旅游热度和城镇间的旅行花销，请你为前来咨询的旅行者规划一条最经济的路线，并且尽可能避开热度很高的网红点。</p><h3 id="输入格式-3">输入格式</h3><p>输入第一行首先给出 4 个正整数：<em>n</em> 和<em>m</em>（1&lt;<em>n</em>≤103，1≤<em>m</em>≤5<em>n</em>），依次为城镇数量（于是城镇编号从1 到 <em>n</em>）和城镇间的通路条数；<em>s</em> 和 <em>t</em>依次为旅行者的出发地和目的地的城镇编号。 随后一行给出 <em>n</em>个不超过 100 的正整数，依次为 <em>n</em> 个城镇的旅游热度。 再后面是<em>m</em>行，每行给出一条通路连接的两个城镇的编号、这条通路的最小花销（其数值为不超过103 的正整数）。通路是双向的，题目保证任一对城镇间至多给出一条通路。同一行的数字间均以空格分隔。</p><h3 id="输出格式-3">输出格式</h3><p>题目要求从 <em>s</em> 到 <em>t</em>的最小花销路线；若这样的路线不唯一，则取<strong>途径</strong>城镇的最高旅游热度值最小的那条路线。在一行中输出从 <em>s</em> 到 <em>t</em>的最小花销、以及途经城镇的最高旅游热度值（若没有途经的城镇，则热度值为0）。数值间以 1 个空格分隔，行首尾不得有多余空格。 若从 <em>s</em>根本走不到 <em>t</em>，则在一行中输出 <code>Impossible</code>。</p><h3 id="输入样例-1-1">输入样例 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs in">8 14 7 8<br>100 20 30 10 50 80 100 100<br>7 1 1<br>7 2 2<br>7 3 1<br>7 4 2<br>1 2 1<br>1 5 2<br>2 5 1<br>3 4 1<br>3 5 3<br>3 6 2<br>4 6 1<br>5 6 1<br>5 8 1<br>6 8 2<br></code></pre></td></tr></table></figure><h3 id="输出样例-1-1">输出样例 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">4 50<br></code></pre></td></tr></table></figure><h3 id="样例解释">样例解释</h3><p>从 7 到 8 的最短路径有 3 条，其中 2 条都经过城镇1，于是对应的最高旅游热度值是城镇 1 的热度值 100。解路径为7-&gt;2-&gt;5-&gt;8，途径城镇 2 和 5，对应的最高旅游热度值是城镇 5的热度值50。在最短路径长度相等的情况下，取热度值小的解，故输出的热度值为50。</p><h3 id="输入样例-2-1">输入样例 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs in">3 1 1 2<br>10 20 30<br>1 3 1<br></code></pre></td></tr></table></figure><h3 id="输出样例-2-1">输出样例 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">Impossible<br></code></pre></td></tr></table></figure><h3 id="解法-3">解法</h3><p>本题是多权值的单源最短路问题，考虑使用Dijkstra来做。</p><p>需要更新路径的条件为：</p><p>A. 新路径比老路径更短</p><p>B. 新路径和老路径一样长，但是途径点的最大热度更小</p><blockquote><p>Dijkstra状态转移方程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &gt; dist[f] + edge[f][j])&#123;<br>&gt;dist[j] = dist[f] + edge[f][j];<br>&gt;val[j] = <span class="hljs-built_in">max</span>(val[f],w[j]);<br>&gt;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] == dist[f] + edge[f][j] &amp;&amp; val[j] &gt; <span class="hljs-built_in">max</span>(val[f],w[j]))&#123;<br>&gt;dist[j] = dist[f] + edge[f][j];<br>&gt;val[j] = <span class="hljs-built_in">max</span>(val[f],w[j]);<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">50</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n,m,s,t;<br><span class="hljs-type">int</span> w[MAX];<br><span class="hljs-type">int</span> edge[MAX][MAX];<span class="hljs-comment">// n &lt;= 1000, 用邻接矩阵即可</span><br><span class="hljs-type">int</span> val[MAX],dist[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>dist[i] = edge[s][i];<br><span class="hljs-keyword">if</span>(edge[s][i] != INF) val[i] = w[i];<br>&#125;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &gt; dist[f] + edge[f][j])&#123;<br>dist[j] = dist[f] + edge[f][j];<br>val[j] = <span class="hljs-built_in">max</span>(val[f],w[j]);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] == dist[f] + edge[f][j] &amp;&amp; val[j] &gt; <span class="hljs-built_in">max</span>(val[f],w[j]))&#123;<br>dist[j] = dist[f] + edge[f][j];<br>val[j] = <span class="hljs-built_in">max</span>(val[f],w[j]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i];<br>&#125;<br>w[s] = w[t] = <span class="hljs-number">0</span>; <span class="hljs-comment">//依题意，不考虑起点和终点的热度</span><br><span class="hljs-built_in">memset</span>(edge,INF,<span class="hljs-built_in">sizeof</span>(edge));<br><span class="hljs-built_in">memset</span>(val,INF,<span class="hljs-built_in">sizeof</span>(val));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>edge[a][b] = c;<br>edge[b][a] = c;<br>&#125;<br><span class="hljs-built_in">Dijkstra</span>();<br><span class="hljs-keyword">if</span>(dist[t] == INF)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Impossible&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;dist[t]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;val[t];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-贪心消消乐">RC-u5 贪心消消乐</h1><blockquote><p>分数 30 作者 陈越 单位 浙江大学</p></blockquote><figure><img src="/competition/RAICOM-CAIP/2024-%E5%9B%BD%E8%B5%9B/a607e42e-9f51-43a1-b430-0ca9f3e99e74.jpg" alt="f1.jpg"><figcaption aria-hidden="true">f1.jpg</figcaption></figure><p>“消消乐”是以消去方块赢取分数的游戏。这里介绍一种超级简单的玩法：玩家每次按住并拖动鼠标，在屏幕上划出一个矩形，则矩形内的方块就被消去，玩家得到所有被消去的方块的分数之和。每个方块上的小动物对应不同的得分，例如消去上图中的绿色青蛙得 2分、消去紫色猫头鹰得 5 分、消去黄色小鸡得 9 分、消去蓝色小牛得 1分、消去红色狐狸得 3 分、消去棕色小熊得 8分。有些方块是冰块，消去冰块会被扣分，所以冰块上标注了负分。有些方块是黑洞，玩家的矩形内不能包含任何黑洞，否则所有分数都被黑洞吸走。在一个矩形被消去后，其上方的方块会掉落以填补空缺，而多出的空缺被黑洞填补。本题请你帮助玩家实现一个基于贪心策略的自动消除程序，每次都争取获得最多的分数，直到无法继续获得更多的分数。</p><h3 id="输入格式-4">输入格式</h3><p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出一个不超过 100的正整数 <em>N</em>，对应正方形游戏屏幕的高度和宽度。随后 <em>N</em>行，每行给出 <em>N</em> 个数字，代表对应方块的分数，其中黑洞用 0表示，小动物用正整数分表示，冰块用负整数分表示。数值均在 [−100,100]区间内。</p><h3 id="输出格式-4">输出格式</h3><p>每一步的消除策略占一行，格式为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">(<span class="hljs-built_in">x1</span>, y1) (<span class="hljs-built_in">x2</span>, y2) 得分<br></code></pre></td></tr></table></figure><p>其中 <code>(x1, y1)</code>为矩形左上角的横纵坐标，<code>(x2, y2)</code>为矩形右下角的横纵坐标，<code>得分</code>为消去这个矩形的得分。这里我们将游戏屏幕的左上角坐标定义为(1,1)，右下角坐标定义为 (<em>N</em>,<em>N</em>)。 最后一行给出总分。注意：当有多个矩形同时对应最大得分时，优先选择 <code>x1</code>最小的；如果 <code>x1</code> 一样，则优先选择 <code>y1</code>最小的；如果 <code>y1</code> 也一样，则优先选择 <code>x2</code>最小的；如果 <code>x2</code> 还是一样，则优先选择 <code>y2</code>最小的。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">4<br>0 2 5 0<br>9 2 -6 2<br>-4 1 -4 3<br>-1 8 0 -2<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs out">(1, 2) (2, 4) 15<br>(3, 1) (3, 1) 5<br>(4, 2) (4, 3) 5<br>(2, 4) (2, 4) 2<br>27<br></code></pre></td></tr></table></figure><h3 id="样例解释-1">样例解释</h3><p>游戏的初始界面如题面所示。消去过程如下： <img src="/competition/RAICOM-CAIP/2024-%E5%9B%BD%E8%B5%9B/5c78dd3c-b9c3-47cf-bd31-957a3b3476ff.jpg" alt="f2.jpg"><img src="/competition/RAICOM-CAIP/2024-%E5%9B%BD%E8%B5%9B/28536b9d-440b-4421-8bdc-3fd97bff6023.jpg" alt="f3.jpg"> <img src="/competition/RAICOM-CAIP/2024-%E5%9B%BD%E8%B5%9B/a38050b9-c411-4e06-b0ef-c6fa9b9a26e4.jpg" alt="f4.jpg"></p><h3 id="解法-4">解法</h3><h3 id="代码-4">代码</h3><blockquote><p>以后补：）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CAIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2024-省赛题解</title>
    <link href="/competition/RAICOM-CAIP/2024-%E7%9C%81%E8%B5%9B/"/>
    <url>/competition/RAICOM-CAIP/2024-%E7%9C%81%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-热热热">RC-u1 热҈热҈热҈</h1><p>热҈热҈热҈……最近热得打的字都出汗了！</p><p>幸好某连锁餐厅开启了气温大于等于 35度即可获得一杯免费雪碧的活动。但不知为何，在每个星期四的时候，这个活动会暂停一天……</p><p>现在给定连续的若干天的气温情况以及给定的第一天是星期几，请你算出有多少天你可以喝到免费的雪碧，又有多少天是因为星期四而导致你喝不到雪碧的。</p><h3 id="输入格式">输入格式</h3><p>输入第一行是两个正整数 <em>N</em>, <em>W</em>(1≤<em>N</em>≤50,1≤<em>W</em>≤7)，表示给定连续的 <em>N</em>天，下面给定的第一天是星期 <em>W</em>（7 等于星期天）。</p><p>接下来的一行给出 <em>N</em> 个用一个空格隔开的、小于 60 的整数，第<em>i</em> 个数表示第 <em>i</em> 天的温度。保证温度大于等于 -273度。</p><h3 id="输出格式">输出格式</h3><p>输出两个数，第一个是你能喝到免费雪碧的天数，第二个是你本来能喝到免费雪碧、但因为是星期四而无法喝到的天数。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">15 3<br>33 35 34 36 37 40 32 31 30 29 28 29 33 38 40<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">5 1<br></code></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,d;<br><span class="hljs-type">int</span> sum,res;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;d;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> t;cin&gt;&gt;t;<br><span class="hljs-keyword">if</span>(t &gt;= <span class="hljs-number">35</span> &amp;&amp; d != <span class="hljs-number">4</span>) sum++;<br><span class="hljs-keyword">if</span>(t &gt;= <span class="hljs-number">35</span> &amp;&amp; d == <span class="hljs-number">4</span>) res++;<br><span class="hljs-keyword">if</span>(d + <span class="hljs-number">1</span> == <span class="hljs-number">8</span>) d = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> d++;<br>&#125;<br>cout&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;res;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u2-谁进线下了">RC-u2 谁进线下了？</h1><p><em>Xepa Legends</em>是一个第一人称射击类大逃杀（“吃鸡”）游戏，每轮游戏共有 20 支 3人小队参加，最后获胜的队伍被称为“捍卫者”。</p><p>最近 <em>Xepa Legends</em> 举行了亚太地区南赛区的线上比赛，争夺 7个前往德国曼海姆参加线下赛的资格，国内共有 14支队伍参与到了其中。因为比赛十分激烈，直到最后谁进了线下仍有巨大的疑问。小K 喜欢的国内知名战队 DreamTear因其队内选手<em>杀马特</em>表现不佳，正好卡在出线分数前后，请你赶紧帮帮小K，计算一下最后的分数情况，看看他喜欢的战队出线了没有吧！</p><p><em>Xepa Legends</em> 的比赛共进行 <em>N</em>场游戏，在每场游戏中，每支队伍在游戏中会获得一个排名和一个杀敌数（击败其他队伍玩家的数量），一支队伍在一场游戏的得分为<strong>杀敌数+排名分</strong>，排名分由队伍当场的排名根据以下表格求得：</p><table><thead><tr><th>排名</th><th>分数</th></tr></thead><tbody><tr><td>第一名</td><td>12 分</td></tr><tr><td>第二名</td><td>9 分</td></tr><tr><td>第三名</td><td>7 分</td></tr><tr><td>第四名</td><td>5 分</td></tr><tr><td>第五名</td><td>4 分</td></tr><tr><td>第六名至第七名</td><td>3 分</td></tr><tr><td>第八名至第十名</td><td>2 分</td></tr><tr><td>第十一名至第十五名</td><td>1 分</td></tr><tr><td>第十六名至第二十名</td><td>0 分</td></tr></tbody></table><p>例如，</p><ul><li><em>DreamTear</em> 战队在第三场比赛获得了第三名、有 6个杀敌数，那么他们将获得 7 + 6 = 13 分；</li><li><em>KV</em> 战队在第二场比赛获得了第 19 名、有 1个杀敌数，那么他们将获得 0 + 1 = 1 分；</li><li><em>SRN</em> 战队在第四场比赛获得了第 1 名、有 9个杀敌数，那么他们将获得 12 + 9 = 21 分。</li></ul><p><em>注：本题与实际情况无关，所有比赛规则、队伍、队员名称均为虚构。</em></p><h3 id="输入格式-1">输入格式</h3><p>输入第一行是一个正整数 <em>N</em> (≤20)，表示有 <em>N</em>场比赛。</p><p>接下来有 <em>N</em>部分输入，每部分是一场比赛的情况。对每一场比赛，信息共分 20 行，第<em>i</em> 行（<em>i</em>=1,⋯,20）给出的两个非负整数 <em>p</em> 和<em>k</em> 表示第 <em>i</em> 支队伍在这场比赛里获得了第 <em>p</em>名、杀敌数为 <em>k</em>。</p><p>数据保证所有给定的情况中，排名永远大于等于 1 且小于等于20，杀敌数小于等于 57。</p><h3 id="输出格式-1">输出格式</h3><p>输出 20行，按编号从小到大依次输出队伍的编号及该队全部游戏结束时的总分。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>6 2<br>7 3<br>11 5<br>10 1<br>2 9<br>5 8<br>14 3<br>4 3<br>1 6<br>18 1<br>12 1<br>20 0<br>13 0<br>3 2<br>16 4<br>8 1<br>19 0<br>9 4<br>17 1<br>15 0<br>8 2<br>19 1<br>12 2<br>1 9<br>10 1<br>7 5<br>18 0<br>14 0<br>5 2<br>4 4<br>2 5<br>6 2<br>16 3<br>13 1<br>20 0<br>3 7<br>9 3<br>15 0<br>17 5<br>11 3<br>18 0<br>5 2<br>2 9<br>9 4<br>4 7<br>10 3<br>16 0<br>1 6<br>20 0<br>15 1<br>6 0<br>3 6<br>14 3<br>7 4<br>19 0<br>17 0<br>8 9<br>11 0<br>13 5<br>12 0<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs out">1 9<br>2 13<br>3 27<br>4 30<br>5 33<br>6 25<br>7 4<br>8 27<br>9 24<br>10 12<br>11 19<br>12 18<br>13 8<br>14 18<br>15 4<br>16 17<br>17 16<br>18 8<br>19 12<br>20 6<br></code></pre></td></tr></table></figure><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> sco[<span class="hljs-number">21</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span>(r == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-number">6</span> &amp;&amp; r &lt;= <span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-number">8</span> &amp;&amp; r &lt;= <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-number">11</span> &amp;&amp; r &lt;= <span class="hljs-number">15</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">20</span> ; j ++)&#123;<br><span class="hljs-type">int</span> p,k;cin&gt;&gt;p&gt;&gt;k;<br>sco[j] += <span class="hljs-built_in">getScore</span>(p);<br>sco[j] += k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">20</span> ; i ++)&#123;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;sco[i]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-暖炉与水豚模拟">RC-u3 暖炉与水豚（模拟）</h1><p>PapiCon（<span class="citation" data-cites="PapilloteContet">@PapilloteContet</span>）出了许多有意思的谜题，其中有一道关于水豚的谜题是这样的：</p><figure><img src="/competition/RAICOM-CAIP/2024-%E7%9C%81%E8%B5%9B/92d6785e-10a2-4673-af83-e2aaad99de57.jpeg" alt="GGwLLL_bwAA8cC4.jpeg"><figcaption aria-hidden="true">GGwLLL_bwAA8cC4.jpeg</figcaption></figure><p><em>来源：x.com/PapilloteContet</em></p><p>在一个 <em>N</em>×<em>M</em>的矩阵中有若干水豚以及暖炉，暖炉可以辐射以它自身为中心的 3×3范围里的水豚，使其变得暖呼呼的。谜题里存在一只冷的要命的水豚，你需要移动其中的一个暖炉，使所有水豚都变得暖呼呼的。</p><p>在往下读题前，如果你有兴趣的话，不妨思考一下如何解答这个谜题。（思考结果与题目无关，可跳过。）</p><p>这个谜题的关键在于，单纯从图中能看到的暖炉来说是无解的，但如果注意到，第3 行第 6列的水豚明明周围没有暖炉，却也处于暖呼呼的状态，就能推测出来图中的那个对话框挡住了一个暖炉，只要移动这个暖炉就可以完成题目的要求。</p><p>现在我们将谜题一般化，对于给定的一个 <em>N</em>×<em>M</em>的矩阵、对应的所有水豚状态、以及<strong>能看到的</strong>暖炉摆放情况，已知最多只有一只水豚的状态不太对劲（周围没有暖炉却暖呼呼的），你需要推测有哪些格子<strong>可能</strong>藏了暖炉。一个空格<strong>可能</strong>藏了暖炉可以理解为：当前空格设置暖炉后整个矩阵的状态会从不合法变为合法。</p><h3 id="输入格式-2">输入格式</h3><p>输入第一行是两个正整数 <em>N</em>, <em>M</em>(1≤<em>N</em>,<em>M</em>≤1000)，表示矩阵的大小。</p><p>接下来的 <em>N</em> 行，每行有 <em>M</em> 个字符，第 <em>i</em>行的第 <em>j</em> 个字符表示矩阵中对应位置的状态，其中：</p><ul><li><code>.</code> 表示空格（或者说，看上去是空格的格子）；</li><li><code>c</code> 表示很冷的水豚；</li><li><code>w</code> 表示暖呼呼的水豚；</li><li><code>m</code> 表示暖炉。</li></ul><h3 id="输出格式-2">输出格式</h3><p>输出若干行，每行两个正整数 <em>r</em> 和 <em>c</em>，表示第<em>r</em> 行第 <em>c</em> 列有可能藏了一个暖炉，有多个可能时，先按<em>r</em> 从小到大输出，<em>r</em> 相同时再按 <em>c</em>从小到大输出。如果没有一个格子可能藏了暖炉，则在一行中输出<code>Too cold!</code>。 行与列均从 1 开始编号。</p><h3 id="输入样例-2">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">6 8<br>wm....mw<br>.w..ww..<br>..wm.wwm<br>w.w....w<br>.m.c.m..<br>w.....w.<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs out">2 7<br>3 5<br>4 6<br>4 7<br></code></pre></td></tr></table></figure><h3 id="解法">解法</h3><p>Step1：找到不合法的豚鼠：温暖，但是没被暖炉照到</p><p>Step2：找到该豚鼠周围，所有可放置暖炉的位置，并判断是否合法</p><p>Step3：存储所有暖炉的合法位置，逐个输出</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">char</span> a[MAX][MAX];<br><span class="hljs-type">bool</span> isWarm[MAX][MAX];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">putLight</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//放下暖炉后温暖9格区域</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-type">int</span> nx = x + dirx[i];<br><span class="hljs-type">int</span> ny = y + diry[i];<br><span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= m)&#123;<br>isWarm[nx][ny] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//放置的暖炉是否合法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-type">int</span> nx = x + dirx[i];<br><span class="hljs-type">int</span> ny = y + diry[i];<br><span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= m)&#123;<br><span class="hljs-keyword">if</span>(a[nx][ny] == <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPos</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-comment">//找到所有可放置暖炉的位置并判断</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; <span class="hljs-number">9</span> ; i ++)&#123;<br><span class="hljs-type">int</span> nx = x + dirx[i];<br><span class="hljs-type">int</span> ny = y + diry[i];<br><span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= m)&#123;<br><span class="hljs-keyword">if</span>(a[nx][ny] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; <span class="hljs-built_in">judge</span>(nx,ny))&#123;<br>ans.<span class="hljs-built_in">push_back</span>(&#123;nx,ny&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;a[i][j];<br><span class="hljs-keyword">if</span>(a[i][j] == <span class="hljs-string">&#x27;m&#x27;</span>) <span class="hljs-built_in">putLight</span>(i,j);<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//找到不合法的豚鼠：温暖，但是没被暖炉照到</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j] == <span class="hljs-string">&#x27;w&#x27;</span> &amp;&amp; !isWarm[i][j])&#123;<br><span class="hljs-built_in">findPos</span>(i,j);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;<span class="hljs-string">&quot;Too cold!&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ans)&#123;<br>cout&lt;&lt;it.first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.second&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-章鱼图的判断并查集bfs">RC-u4章鱼图的判断（并查集+BFS）</h1><p>对于无向图<em>G</em>=(<em>V</em>,<em>E</em>)，我们将有且只有一个环的、大于 2个顶点的无向连通图称之为<strong>章鱼图</strong>，因为其形状像是一个环（身体）带着若干个树（触手），故得名。</p><p>给定一个无向图，请你判断是不是只有一个章鱼子图存在。</p><h3 id="输入格式-3">输入格式</h3><p>输入第一行是一个正整数 <em>T</em>(1≤<em>T</em>≤5)，表示数据的组数。</p><p>每组数据的第一行是两个正整数 <em>N</em>,<em>M</em>(1≤<em>N</em>,<em>M</em>≤105)，表示给定的无向图有 <em>N</em>个点，<em>M</em> 条边。</p><p>接下来的 <em>M</em>行，每行给出一条边两个端点的顶点编号。注意：顶点编号从 1开始，并且题目保证任何边不会重复给出，且没有自环。</p><h3 id="输出格式-3">输出格式</h3><p>对于每组数据，如果给定的图里只有一个章鱼子图，则在一行中输出<code>Yes</code> 和章鱼子图环的大小（及环中顶点数），其间以 1个空格分隔。</p><p>否则，则在一行中输出 <code>No</code> 和图中章鱼子图的个数，其间以 1个空格分隔。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>10 10<br>1 3<br>3 5<br>5 7<br>7 9<br>1 2<br>2 4<br>2 6<br>3 8<br>9 10<br>1 9<br>10 10<br>1 3<br>3 5<br>5 7<br>7 9<br>9 1<br>1 2<br>2 4<br>4 8<br>8 10<br>10 1<br>10 10<br>1 3<br>3 5<br>5 7<br>7 9<br>9 1<br>2 4<br>4 8<br>8 10<br>10 2<br>10 6<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">Yes 5<br>No 0<br>No 2<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><blockquote><p>题中说的“章鱼子图”，实际上是：“是章鱼图的连通分量”</p><p>如果出现两个环，要么有两张章鱼子图，要么原图不是章鱼子图，一定不符合题目条件</p></blockquote><p>Step1：并查集求每个连通分量的环的个数，并记录环的两个端点</p><p>Step2：BFS求环的长度</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n,m,t;<br><span class="hljs-type">int</span> r1,r2; <span class="hljs-comment">//环的两个端点</span><br><span class="hljs-type">int</span> pre[MAX],cnt[MAX],d[MAX]; <span class="hljs-comment">//cnt -- 连通子图 i 内环的个数</span><br><span class="hljs-type">bool</span> visited[MAX];<br>vector&lt;<span class="hljs-type">int</span> &gt; e[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == pre[x]) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span></span>&#123;<span class="hljs-comment">//给两个端点，求环的长度</span><br>queue&lt;<span class="hljs-type">int</span> &gt; q;<br>q.<span class="hljs-built_in">push</span>(s);<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[f])&#123;<br><span class="hljs-keyword">if</span>(!visited[it])&#123;<br><span class="hljs-keyword">if</span>(it == t &amp;&amp; f == s) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//切断环的两个端点之边</span><br>d[it] = d[f] + <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(it);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[t]<span class="hljs-number">+1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>pre[i] = i;<br>e[i].<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cnt));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;<br>e[a].<span class="hljs-built_in">push_back</span>(b);<br>e[b].<span class="hljs-built_in">push_back</span>(a);<br><br><span class="hljs-type">int</span> fa = <span class="hljs-built_in">find</span>(a);<br><span class="hljs-type">int</span> fb = <span class="hljs-built_in">find</span>(b);<br><br><span class="hljs-keyword">if</span>(fa == fb)&#123; <span class="hljs-comment">//若已经连通的两点之间，存在一条边，那么存在环</span><br>cnt[fb]++;<br>r1 = a;<br>r2 = b;<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//合并</span><br>pre[fa] = fb;<br>cnt[fb] += cnt[fa];<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i) == i &amp;&amp; cnt[i] == <span class="hljs-number">1</span>)&#123;<br>sum++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(sum == <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Yes &quot;</span>&lt;&lt;<span class="hljs-built_in">bfs</span>(r1,r2)&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;No &quot;</span>&lt;&lt;sum&lt;&lt;endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-工作安排01背包">RC-u5 工作安排（01背包）</h1><p>小 K 有 <em>N</em> 项工作等待完成，第 <em>i</em> 项工作需要花 *t**i*单位时间，必须在 *d**i* 时刻或之前完成，报酬为 *p**i*。假设小 K工作时刻从 0开始，且同一时刻只能做一项工作、工作一旦开始则不可中断或切换至其他工作，请你帮小K 规划一下如何选择合适的工作，使小 K 可以获得最多的报酬。</p><h3 id="输入格式-4">输入格式</h3><p>输入第一行是一个正整数 <em>T</em> (≤5)，表示数据的组数。</p><p>接下来有 <em>T</em> 组数据，每组数据第一行是一个正整数 <em>N</em>(≤5000)，表示待完成工作的数量。接下来的 <em>N</em> 行，每行三个非负整数<em>t<strong>i<em>、</em>d</strong>i</em>、*p**i* (均≤5000；1≤<em>i</em>≤<em>N</em>)，表示第 <em>i</em>项工作需要花费的时间、截止时间以及报酬。</p><h3 id="输出格式-4">输出格式</h3><p>对于每组数据，输出小 K 能获得最多的报酬是多少。</p><h3 id="输入样例-4">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>5<br>1 2 50<br>3 3 100<br>1 5 1<br>3 2 5000<br>4 5 30<br>5<br>1 2 50<br>3 3 20<br>1 5 1<br>3 2 5000<br>4 5 30<br>5<br>1 2 50<br>3 3 100<br>1 5 1<br>3 2 5000<br>5 5 800<br></code></pre></td></tr></table></figure><h3 id="输出样例-4">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">101<br>80<br>800<br></code></pre></td></tr></table></figure><h3 id="解法-2">解法</h3><p>状态转移方程：<span class="math inline">\(dp[j] = max(dp[j], dp[t -ta[i].d] + ta[i].p)\)</span></p><blockquote><p>dp[j] : 到达时间j时，能做获得的最大报酬</p><p>ta[i].d：任务i的截止时间</p><p>ta[i].p：任务i的报酬</p></blockquote><p>与普通的01背包不同的地方在于，</p><p>这题为每个任务规定的能采用的时间上限，即：截止时间 - 任务时间，</p><p>因此，为了保证每个任务都在优化的考虑范围内，需要根据截止时间对任务进行排序。</p><h3 id="代码-4">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">5050</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span>&#123;<br><span class="hljs-type">int</span> t,d,p;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> task &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> d &lt; rhs.d;<br>&#125;<br>&#125;ta[MAX];<br><br><span class="hljs-type">int</span> t,n;<br><span class="hljs-type">int</span> dp[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;ta[i].t&gt;&gt;ta[i].d&gt;&gt;ta[i].p;<br>&#125;<br><span class="hljs-built_in">sort</span>(ta,ta+n);<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = ta[i].d ; j &gt;= ta[i].t ; j --)&#123;<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j - ta[i].t] + ta[i].p);<br>ans = <span class="hljs-built_in">max</span>(dp[j],ans);<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-built_in">solve</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CAIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2023-省赛题解</title>
    <link href="/competition/RAICOM-CAIP/2023-%E7%9C%81%E8%B5%9B/"/>
    <url>/competition/RAICOM-CAIP/2023-%E7%9C%81%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-亚运奖牌榜模拟">RC-u1 亚运奖牌榜（模拟）</h1><p>2022 年第 19届亚运会即将在杭州召开，杭州已经做好准备欢迎全亚洲的观众一同参与亚运盛会了！</p><p>你正在开发一款跟亚运奖牌计算相关的App。给定两个国家的获奖情况，你的任务是计算这两个国家/地区的奖牌情况，并确定哪个国家/地区要排在奖牌榜的前面。</p><h3 id="输入格式">输入格式</h3><p>输入第一行是一个正整数 <em>N</em> (1≤<em>N</em>≤1000)，表示总共有<em>N</em> 条获奖记录。</p><p>接下来的每一行都是形如以下的一条记录：</p><p><em>C<strong>i<em>,</em>P</strong>i</em></p><p>其中 <em>C<strong>i<em>=0,1，0 表示是第一个国家/地区，1表示是第二个国家/地区；</em>P</strong>i</em>=1,2,3，1 表示金牌，2表示银牌，3 表示铜牌。</p><h3 id="输出格式">输出格式</h3><p>首先输出两行，第一行是第一个国家/地区的金牌、银牌、铜牌获得数，用空格隔开；第二行是第二个国家/地区的奖牌获奖情况，要求与格式同第一个国家/地区。</p><p>最后一行，如果是第一个国家/地区排在前面，输出<code>The first win!</code>，否则输出 <code>The second win!</code>。</p><p>排在前面的定义是：先比较金牌数，金牌数较大的排在前面；如金牌数相等，比较银牌数，银牌数较大的在前面；如金牌银牌数都相等，则比较铜牌数，铜牌数较大的在前面。</p><p>保证数据不存在奖牌数完全相同的情况。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs in">15<br>0 1<br>0 2<br>0 3<br>0 1<br>0 1<br>0 2<br>0 3<br>1 3<br>1 3<br>1 3<br>1 3<br>1 2<br>1 1<br>1 1<br>1 1<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">3 2 2<br>3 1 4<br>The first win!<br></code></pre></td></tr></table></figure><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> type[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(type[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] != type[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> type[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; type[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(type[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] != type[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> type[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] &gt; type[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">return</span> type[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] &gt; type[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> c,p;<br>cin&gt;&gt;c&gt;&gt;p;<br>type[c][p]++;<br>&#125;<br>cout&lt;&lt;type[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;type[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;type[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]&lt;&lt;endl;<br>cout&lt;&lt;type[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;type[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;type[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]&lt;&lt;endl;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>()) cout&lt;&lt;<span class="hljs-string">&quot;The first win!&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;The second win!&quot;</span>&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u2-出院字符串处理">RC-u2 出院（字符串处理）</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>：最近出了一个饮料营养等级你们知道吗？例如无糖的饮料是 <span class="hljs-selector-tag">A</span> 级，可乐是 D 级……<br><span class="hljs-selector-tag">B</span>：那……无糖可乐是什么级别？<br>C：AD 级吧。<br><span class="hljs-selector-tag">A</span>：出院！<br><span class="hljs-selector-tag">B</span>：出什么院，你也给我进去！<br></code></pre></td></tr></table></figure><p>以上是某群中一段有趣的对话。请你按照里面的逻辑，在已知某些饮料的等级的情况下，给饮料定级。定级的方法是：</p><ul><li>如果是已知等级的饮料，直接输出等级；</li><li>对于一个新饮料的名字，你需要将名字拆成两个已知等级的部分，然后输出这个级别。例如：Diet是A，Coke是D，那么DietCoke就是AD；</li><li>如果新饮料无法拆解或者有多种拆解方法，统一定为 D 级。</li></ul><h3 id="输入格式-1">输入格式</h3><p>输入第一行是两个正整数 <em>N</em>,<em>M</em>(1≤<em>N</em>,<em>M</em>≤100)，表示已知的饮料有 <em>N</em>种，需要定级的饮料有 <em>M</em> 种。</p><p>接下来首先是 <em>N</em>行，每行是一个字符串和一个字符，表示一种饮料的名字和对应的等级，等级只有<em>A</em>,<em>B</em>,<em>C</em>,<em>D</em> 四种。</p><p>然后是 <em>M</em>行，每行是一个字符串，表示需要定级的饮料的名字。</p><p>所有饮料名字只包含有大小写字母，长度不超过30，给定拥有等级的饮料的名字不会重复。</p><h3 id="输出格式-1">输出格式</h3><p>对于每一个需要定级的饮料，输出定好的定级。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs in">5 6<br>Diet A<br>LowSugarTea B<br>Milk C<br>Coke D<br>Water A<br>DietCoke<br>Pepsi<br>Milk<br>CokeWater<br>GoodMilk<br>dietCoke<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs out">AD<br>D<br>C<br>DA<br>D<br>D<br></code></pre></td></tr></table></figure><p><strong>题目引用自睿抗机器人开发者大赛真题（2023年）。</strong></p><h3 id="解法">解法</h3><p>使用哈希表（unordered_map）映射饮料名-&gt;饮料类型。</p><p>按两种情况讨论，如果直接存在该饮料，输出名字即可；</p><p>如果不存在，寻找有多少种组合（2种，饮料名可复用），为1种时输出复合名称，否则输出D。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;string,string&gt; mp;<br><span class="hljs-type">int</span> n,m,cnt;<br>string res;<br>vector&lt;string&gt; v;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>string name,type;<br>cin&gt;&gt;name&gt;&gt;type;<br>v.<span class="hljs-built_in">push_back</span>(name);<br>mp[name] = type;<br>&#125;<br><span class="hljs-keyword">while</span>(m--)&#123;<br>string s;cin&gt;&gt;s;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(s) != <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;mp[s]&lt;&lt;endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[i] + v[j] == s)&#123;<br>res = mp[v[i]] + mp[v[j]];<br>cnt++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)&#123;<br>cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;D&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-骰子游戏dfs">RC-u3 骰子游戏（DFS）</h1><p>在某个游戏中有一个骰子游戏。在游戏中，你需要投掷 5个标准六面骰子（骰子为一个正方体，6个面上分别有1、2、3、4、5、6中的一个数字，骰子的质量均匀），投出的点数根据组合会获得一个“获胜等级”。获胜等级从高到低如下：</p><ul><li>五个同点数 - 五个骰子显示相同的点数</li><li>四个同点数 - 四个骰子显示相同的点数</li><li>葫芦 - 一对和一个三个同点数（如1、1、3、3、3）</li><li>六高顺子 - 投出的点数为 2、3、4、5、6</li><li>五高顺子 - 投出的点数为 1、2、3、4、5</li><li>三个同点数 - 三个骰子显示相同的点数（如1、1、1、2、3）</li><li>两对 - 投出的点数中有两对是相同的（如 1、1、2、2、3）</li><li>一对 - 投出的点数有一对是相同的（如 1、1、2、3、4）</li><li>无 - 除去以上的其他情况</li></ul><p>给定你已经投出的一次结果，现在假设你可以选择任意个骰子重投一次，请问怎么样操作，才能最大化在重骰后获得更好的获胜等级的概率呢？</p><p>注意：更好的获胜等级需要严格地比当前的获胜等级更好，例如1、1、2、2、3 如果重骰后变为 1、1、3、3、4并不比当前的获胜等级更好。</p><h3 id="输入格式-2">输入格式</h3><p>输入第一行是一个正整数 <em>T</em>(1≤<em>T</em>≤10)，表示接下来有多少组数据。 每组数据只有一行 5个数字，表示第一次投出的 5 个骰子的点数。</p><h3 id="输出格式-2">输出格式</h3><p>对于每组数据输出三个整数，其中第一个整数为为了获得最大的概率需要重新骰几个骰子，后面的两个整数为重骰骰子后概率的最简分数，其中第二个整数为分子，第三个整数为分母。如果分子为0，分母为 1。</p><p>如果有多种获得最大概率的情况，取重骰的骰子数最少的方案。</p><h3 id="输入样例-2">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>1 1 2 2 3<br>1 1 2 3 4<br>1 1 1 2 3<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">3 4 9<br>3 13 18<br>2 4 9<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><p>这题的数据较小，使用二重DFS来搜索每一种情况</p><p>首先枚举可能选择的骰子数量cnt</p><p>dfs1 ---- 搜索可能重投的位置（例如：cnt =2时，可能选择1，2，也可能选2，3等等）</p><p>dfs2 ---- 在dfs1的基础上，搜索重投后所有可能的情况。</p><p>最后使用辗转相除法求最大公约数，来简化分子分母。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">5</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; v; <span class="hljs-comment">//存储选择的骰子位置</span><br><span class="hljs-type">int</span> t,cnt,type;<br><span class="hljs-type">int</span> resCases,cases,total; <span class="hljs-comment">//正在计算的事件总数，</span><br><span class="hljs-type">int</span> ans1,ans2,ans3; <span class="hljs-comment">//最优解</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">return</span> (y == <span class="hljs-number">0</span> ? x : <span class="hljs-built_in">gcd</span>(y,x%y));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> t[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i ++)&#123;<br>t[i] = a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(t,t<span class="hljs-number">+5</span>);<br><span class="hljs-comment">//五个同点数 9</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>&#125;<br><span class="hljs-comment">//四个同点数 8</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>&#125;<br><span class="hljs-comment">//葫芦 7</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>&#125;<br><span class="hljs-comment">//六高顺子 6</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span> &amp;&amp; t[<span class="hljs-number">1</span>] == <span class="hljs-number">3</span> &amp;&amp; t[<span class="hljs-number">2</span>] == <span class="hljs-number">4</span> &amp;&amp; t[<span class="hljs-number">3</span>] == <span class="hljs-number">5</span> &amp;&amp; t[<span class="hljs-number">4</span>] == <span class="hljs-number">6</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>&#125;<br><span class="hljs-comment">//五高顺子 5 </span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; t[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span> &amp;&amp; t[<span class="hljs-number">2</span>] == <span class="hljs-number">3</span> &amp;&amp; t[<span class="hljs-number">3</span>] == <span class="hljs-number">4</span> &amp;&amp; t[<span class="hljs-number">4</span>] == <span class="hljs-number">5</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-comment">//三个同点数 4</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-comment">//两对 3</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] &amp;&amp; t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-comment">//一对 2</span><br><span class="hljs-keyword">if</span>(t[<span class="hljs-number">0</span>] == t[<span class="hljs-number">1</span>] || t[<span class="hljs-number">1</span>] == t[<span class="hljs-number">2</span>] || t[<span class="hljs-number">2</span>] == t[<span class="hljs-number">3</span>] || t[<span class="hljs-number">3</span>] == t[<span class="hljs-number">4</span>])&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//无 1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == cnt)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">getType</span>() &gt; type)&#123;<br>cases++;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">6</span> ; i ++)&#123;<br><span class="hljs-type">int</span> tep = a[v[dep]];<br>a[v[dep]] = i;<br><span class="hljs-built_in">dfs2</span>(dep<span class="hljs-number">+1</span>);<br>a[v[dep]] = tep;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == cnt)&#123;<br>cases = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//计算cases</span><br><span class="hljs-type">int</span> sum = (<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">6</span>,cnt);<br><span class="hljs-keyword">if</span>(cases*total &gt;= resCases*sum)&#123;<br>resCases = cases;<br>total = sum;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;<br>vis[i] = <span class="hljs-literal">true</span>;<br>v.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">dfs1</span>(dep<span class="hljs-number">+1</span>);<br>vis[i] = <span class="hljs-literal">false</span>;<br>v.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>        <br>type = <span class="hljs-built_in">getType</span>();<br>ans1 = ans2 = <span class="hljs-number">0</span>;<br>ans3 = <span class="hljs-number">1</span>;<br>vector&lt;<span class="hljs-type">int</span> &gt; tep;<span class="hljs-comment">//所有可能的重投数</span><br><span class="hljs-keyword">if</span>(type == <span class="hljs-number">9</span>) tep = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">else</span> tep = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : tep)&#123; <span class="hljs-comment">//枚举选择几个骰子</span><br>cnt = it;<br>resCases = <span class="hljs-number">0</span>;<br>total = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//计算resCases</span><br><span class="hljs-keyword">if</span>(resCases*ans3 &gt;= ans2*total)&#123;<br>ans1 = cnt;<br>ans2 = resCases;<br>ans3 = total;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans2/<span class="hljs-built_in">gcd</span>(ans2,ans3)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans3/<span class="hljs-built_in">gcd</span>(ans2,ans3)&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-相对论大师dfs剪枝">RC-u4 相对论大师（DFS剪枝）</h1><p>在某个直播间里，观众常常会发送类似这样的弹幕：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">鱼越大，鱼刺越大；鱼刺越大，肉越少；肉越少，鱼越小；所以鱼越大，鱼越小<br></code></pre></td></tr></table></figure><p>这样通过一连串推导得出一个搞笑的结论的弹幕发送者被称为“相对论大师”。</p><p>现在给定一系列已有的推论，请你从给定的推论中挑选一些，组成一条类似于上面的弹幕，成为一名“相对论大师”。</p><h3 id="输入格式-3">输入格式</h3><p>输入第一行是一个正整数 <em>N</em>(1≤<em>N</em>≤1000），表示总共有多少条推论。</p><p>接下来的 <em>N</em> 行，每行有两对四个元素，形如下：</p><p><code>A 0 B 1</code> 每对元素表示一个论点：第一个是一个长度不大于 5的、只包含大小写字母的字符串，称为论点的核心；第二个数字固定为 0 或者1，代表论点核心的方向属性。为简单理解，你可以将 0 理解为正面方向，1理解为负面方向。例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">YuCi</span> <span class="hljs-number">0</span> Rou <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>就可以理解为<code>鱼刺大，肉少</code> 。</p><p>于是一行中的两个论点就形成一条推论，表示第一个核心某个方向的属性能推出第二个核心的某个方向的属性，即<code>鱼刺越大，肉越少</code>。</p><h3 id="输出格式-3">输出格式</h3><p>按照弹幕格式输出一行，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Yu</span> <span class="hljs-number">0</span> YuCi <span class="hljs-number">0</span> YuCi <span class="hljs-number">0</span> Rou <span class="hljs-number">1</span> Rou <span class="hljs-number">1</span> Yu <span class="hljs-number">1</span> = Yu <span class="hljs-number">0</span> Yu <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>具体格式要求为：在一行中输出从起始论点到最终论点的所有推论，论点格式与输入相同，论点间以1个空格分隔。随后输出等号（等号前后均有1个空格），最后是相互矛盾的起始和终止论点。</p><p>如果有多种方案，选择使用推论最少的；推论条数相同的输出任意一种方案均可。</p><p>在方案中每条推论仅可使用一次。保证有解，且给定的推论中没有相同的推论。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs in">5<br>Yu 0 Yuci 0<br>Rou 1 Yu 1<br>Yuci 0 Rou 1<br>Yuci 0 Gutou 0<br>Gutou 0 Rou 0<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">Yu 0 Yuci 0 Yuci 0 Rou 1 Rou 1 Yu 1 = Yu 0 Yu 1<br></code></pre></td></tr></table></figure><h3 id="提示">提示</h3><p>本题返回结果若为<strong>格式错误</strong>均可视为<strong>答案错误</strong>。</p><h3 id="解法-2">解法</h3><p>使用DFS递归搜索所有的组合，</p><p>在组合时，需要判断当前字符串是否合法，进行剪枝。</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e5</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">order</span>&#123;<br>string s1,s2;<br><span class="hljs-type">bool</span> f1,f2;<br>&#125;orders[MAX];<br><br>vector&lt;<span class="hljs-type">int</span> &gt; ans,res;<br>string sts;<br><span class="hljs-type">bool</span> stf;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span></span>&#123;<br><br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>sts = orders[i].s1;<br>stf = orders[i].f1;<br>res.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>);<br>res.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(dep &gt; n) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!ans.<span class="hljs-built_in">empty</span>() &amp;&amp; res.<span class="hljs-built_in">size</span>() &gt; ans.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-type">int</span> b = res.<span class="hljs-built_in">back</span>();<br><span class="hljs-keyword">if</span>(sts == orders[b].s2 &amp;&amp; !(stf == orders[b].f2) )&#123;<br><span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">empty</span>() || res.<span class="hljs-built_in">size</span>() &lt; ans.<span class="hljs-built_in">size</span>())&#123;<br>ans = res;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(orders[i].s1 == orders[b].s2 &amp;&amp; orders[i].f1 == orders[b].f2)&#123;<br>res.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>);<br>res.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;orders[i].s1&gt;&gt;orders[i].f1&gt;&gt;orders[i].s2&gt;&gt;orders[i].f2;<br>&#125;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ans)&#123;<br>cout&lt;&lt;orders[it].s1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[it].f1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[it].s2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[it].f2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-type">int</span> fr = ans.<span class="hljs-built_in">front</span>();<br><span class="hljs-type">int</span> ba = ans.<span class="hljs-built_in">back</span>();<br>cout&lt;&lt;<span class="hljs-string">&quot;= &quot;</span>&lt;&lt;orders[fr].s1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[fr].f1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[ba].s2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;orders[ba].f2&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-相对成功与相对失败最长不下降子序列">RC-u5相对成功与相对失败（最长不下降子序列）</h1><p><em>注意：题面内容表达纯属娱乐，与现实无关！</em></p><p>网上常有人说：看 XX只能度过一个相对成功/失败的人生。不妨假设把这个句式套用在“参加睿抗比赛“以及“玩手机游戏”上，那么有：</p><ul><li>“参加睿抗比赛”必然比“不参加睿抗比赛”要成功；</li><li>“玩手机游戏“必然比“不玩手机游戏”要失败。</li></ul><p>现在有 <em>N</em>个人，已知这些人自己填写的是否参加了睿抗比赛以及是否玩手机游戏的情况，以及他们实际上的成功程度的排序顺序，请问最少有多少人在填写情况时说谎了？</p><h3 id="输入格式-4">输入格式</h3><p>输出第一行为一个正整数 <em>T</em>(1≤<em>T</em>≤5)，表示数据组数。</p><p>每组数据第一行是一个正整数 <em>N</em>(1≤<em>N</em>≤105)，表示总共的人数。</p><p>接下来的 <em>N</em> 行，第 <em>i</em> 行有两个数字<em>A<strong>i<em>,</em>B</strong>i</em>，表示第 <em>i</em>位参赛选手是否参加了睿抗比赛以及是否玩手机游戏，0 为没有参加/没有玩，1为参加了/玩了。</p><p>最后一行有 <em>N</em> 个数，为一个选手编号 1 到 <em>N</em>的排列，表示选手成功程度的排序。排序顺序从最成功到最失败。</p><p>选手编号从 1 开始。</p><h3 id="输出格式-4">输出格式</h3><p>对于每组数据，输出一个整数，表示最少的说谎人数。</p><h3 id="输入样例-4">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>5<br>1 0<br>1 0<br>0 0<br>0 0<br>0 1<br>1 2 3 4 5<br>5<br>1 0<br>1 0<br>0 0<br>0 0<br>0 1<br>5 4 3 2 1<br>5<br>1 0<br>0 1<br>0 0<br>0 1<br>1 1<br>4 2 1 3 5<br></code></pre></td></tr></table></figure><h3 id="输出样例-4">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">0<br>3<br>2<br></code></pre></td></tr></table></figure><h3 id="解法-3">解法</h3><p>要求最短的不合法的序列，等效于最长的合法序列，</p><p>又有，最长的合法序列 == 最长的不下降子序列。</p><p>而根据题目给定的排序方法，可将对象分别赋值为1，2，3（此处也可以用结构体排序方法），并用LIS模板求出最长不下降子序列。</p><p>最后，答案 == 总长度 - 最长不下降子序列长度。</p><p>注意：此题的最长不下降子序列需要使用 二分+贪心优化为 O(N*logN)</p><h3 id="代码-4">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> t,n,cnt;<br><span class="hljs-type">int</span> tep[MAX],a[MAX],query[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">bool</span> f1,f2;cin&gt;&gt;f1&gt;&gt;f2;<br><span class="hljs-keyword">if</span>(f1 &amp;&amp; !f2) tep[i] = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!f1 &amp;&amp; f2) tep[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> tep[i] = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> x;cin&gt;&gt;x;<br>a[n<span class="hljs-number">-1</span>-i] = tep[x<span class="hljs-number">-1</span>];<br>&#125;<br>cnt = <span class="hljs-number">0</span>;<br>query[cnt++] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt;= query[cnt<span class="hljs-number">-1</span>])&#123;<br>query[cnt++] = a[i];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-built_in">upper_bound</span>(query,query+cnt,a[i]) - query;<br>query[f] = a[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;n-cnt&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CAIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2022-国赛题解</title>
    <link href="/competition/RAICOM-CAIP/2022-%E5%9B%BD%E8%B5%9B/"/>
    <url>/competition/RAICOM-CAIP/2022-%E5%9B%BD%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-智能红绿灯">RC-u1 智能红绿灯</h1><p>为了最大化通行效率同时照顾老年人穿行马路，在某养老社区前，某科技公司设置了一个智能红绿灯。</p><p>这个红绿灯是这样设计的：</p><ol type="1"><li>路的两旁设置了一个按钮，老年人希望通行马路时会按下按钮；</li><li>在没有人按按钮的时候，红绿灯一直为绿灯；</li><li>当红绿灯为绿灯时，有人按下按钮，第一次按下按钮的 15秒后绿灯会转红；</li><li>转红后，红灯会持续 30 秒，方便老年人穿行马路；</li><li>在 30 秒的红灯期间，假如有人再次按下按钮，则红灯会再延续 15秒；</li><li>延续一次后不会再次延续。</li></ol><p>现在给定按钮被按下的时间点，请你输出这个智能红绿灯的红灯时间区间。</p><p>注意：我们假设同一秒内，红绿灯先变化，然后按钮再被按下。每 1秒理解为一个时间点。例如：在第 1 秒按下按钮，则第 16秒开始变红；如果没有人在第 16 - 45 秒这个闭区间内按下按钮，则到第 46秒开始变绿。而在第 46 秒按下按钮的人，需要等 15 秒后才有红灯。</p><h2 id="输入格式">输入格式</h2><p>输入第一行为 <em>N</em>(1≤<em>N</em>≤1000)，表示按钮被按下的次数。</p><p>接下来一行 <em>N</em>个非负整数，表示按钮被按下的时间点。一个时间点按钮有可能会被多次按下，给出的时间点保证是不递减的。</p><p>时间点的范围不超过 <span class="math inline">\(10^4\)</span>。</p><h2 id="输出格式">输出格式</h2><p>输出若干行，按起始时间从小到大输出互不相交的红灯的时间区间。</p><h2 id="输入样例">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">10<br>3 4 5 6 33 45 49 70 90 100<br></code></pre></td></tr></table></figure><h2 id="输出样例">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">18 62<br>85 129<br></code></pre></td></tr></table></figure><h2 id="解法">解法</h2><p>用l,r两个变量维护一个红灯区间，每次输入判断一下。</p><p>注意：这里红灯区间只能叠加一次15s，需要用f记录一下。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,t,l,r; <span class="hljs-comment">//[l,r-1]红灯区间</span><br><span class="hljs-type">bool</span> f;<span class="hljs-comment">//保证红灯范围内最多加一次15s</span><br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br>cin&gt;&gt;t;<br>l = t<span class="hljs-number">+15</span>;<br>r = t<span class="hljs-number">+45</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">if</span>(!f &amp;&amp; t &gt;= l &amp;&amp; t &lt; r)&#123;<br>r += <span class="hljs-number">15</span>;<br>f = <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &gt;= r)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(l,r<span class="hljs-number">-1</span>));<br>l = t<span class="hljs-number">+15</span>;<br>r = t<span class="hljs-number">+45</span>;<br>f = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(l,r<span class="hljs-number">-1</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ans)&#123;<br>cout&lt;&lt;it.first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.second&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u2-女王的大敕令">RC-u2 女王的大敕令</h1><p>副本是游戏里的一个特色玩法，主要为玩家带来装备、道具、游戏资源的产出，满足玩家的游戏进程。</p><p>在 MMORPG《最终幻想14》里，有一个攻略人数最大达到 48人的副本“零式贡希尔德神庙”，其中守关 BOSS“天佑女王”有一个很有趣的技能：“女王的大敕令”。</p><p>技能在一个 5×5的棋盘上展开。每位玩家根据给定的两个步长，从某个方格出发，在棋盘上先走<em>D</em>1 步，再走 <em>D</em>2步。其中“步长”指的是<strong>曼哈顿距离</strong>，即：设两个方格的坐标分别为<span class="math inline">\((X_i,Y_i)\)</span> 以及 <span class="math inline">\((X_j,Y_j)\)</span>，则这两个方格的曼哈顿距离 <span class="math inline">\(D=|X_i - X_j|+|Y_i - Y_j|\)</span>。</p><p>例如下图中的 A 点与 B 点的曼哈顿距离为 5：</p><figure><img src="/competition/RAICOM-CAIP/2022-%E5%9B%BD%E8%B5%9B/0641c1d8-cf11-4012-b132-60162aed4c06.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>技能开始时，场地外围会出现 4只小怪，东南西北（即棋盘的右、下、左、上）方向各出现一只小怪，且小怪一定出现在某行或某列对应的位置上。第<em>i</em> 只小怪会顺时针朝固定方向移动 <span class="math inline">\(n_i\)</span>步（题目保证不会移出界，即移动后仍然在对应着某行/某列的位置上），且：</p><ul><li>北边的小怪固定向右移动</li><li>东边的小怪固定向下移动</li><li>南边的小怪固定向左移动</li><li>西边的小怪固定向上移动</li></ul><p>小怪出现后，棋盘上还会出现一个发光的格子，这是玩家移动的目标点，如图所示：</p><figure><img src="/competition/RAICOM-CAIP/2022-%E5%9B%BD%E8%B5%9B/838a75ee-7c3b-4be1-9030-0f5b5a07be37.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>玩家必须在不被小怪杀死的前提下，按规定步长，用两个回合到达目标点。技能流程如下：</p><p>1、玩家先选择一个起始方格；</p><p>2、东、西两侧的小怪开始按照固定方向移动，移动完毕后 <strong>4只</strong>小怪会<strong>同时</strong>开展攻击，其中东、西两侧的小怪攻击自己所对应的一整行，南、北两侧的小怪攻击自己所对应的一整列。玩家若处在攻击区内则任务失败。</p><p>3、玩家移动 <em>D</em>1 步，到达某个方格；</p><p>4、南、北两侧的小怪开始按照固定方向移动，移动完毕后 <strong>4只</strong>小怪会<strong>同时</strong>开展攻击，同第 2 步；</p><p>5、玩家移动 <em>D</em>2 步，此时必须到达目标点，否则任务失败。</p><p>以下是上面的 4 只小怪都移动后的攻击范围的示意图：</p><figure><img src="/competition/RAICOM-CAIP/2022-%E5%9B%BD%E8%B5%9B/0dcdaa5c-361c-4d81-8d81-a9c34f32a237.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>给定小怪起始位置以及移动步数 *n**i*和目标点位置，请输出所有安全的移动方案，包括起始点以及第一次移动的目的地。</p><h2 id="输入格式-1">输入格式</h2><p>输入第一行是四个数<em>C</em>1,<em>C</em>2,<em>R</em>1,<em>R</em>2，分别表示：</p><ul><li>北边（上面）的小怪 1 在第 <em>C</em>1 列的位置上；</li><li>南边（下面）的小怪 2 在第 <em>C</em>2 列的位置上；</li><li>西边（左边）的小怪 3 在第 <em>R</em>1 行的位置上；</li><li>东边（右边）的小怪 4 在第 <em>R</em>2 行的位置上。</li></ul><p>输入第二行是四个数 <span class="math inline">\(n_i（i=1,⋯,4）\)</span>，按照上面的顺序给出小怪移动的步数，保证小怪移动后仍然处于某行或某列对应的位置上。</p><p>输入第三行是四个数 <span class="math inline">\(row,col,D1,D2\)</span>，依次表示目标点的位置，以及玩家要走的两个步长。这里某方格的“位置<span class="math inline">\((row,col)\)</span>指的是该方格的行号、列号组成的二元组。</p><p>我们假设左上角的方格位置为 <span class="math inline">\((1,1)\)</span>。</p><h2 id="输出格式-1">输出格式</h2><p>输出安全移动的方案，方案由两个位置共四个数组成，前两个数为初始选择的方格的位置，后两个数为第一次停留的位置。</p><p>对于多个方案的情况，先按初始方格位置从小到大输出，初始方格相同时按第一次停留位置从小到大输出。一个坐标<span class="math inline">\((r_i,c_i)\)</span> 比另一个坐标 <span class="math inline">\((r_j,c_j)\)</span> 小，当且仅当 <span class="math inline">\(r_i&lt;r_j\)</span>，或 <span class="math inline">\(r_i=r_j\)</span> 的同时有 <span class="math inline">\(c_i&lt;c_j\)</span>。</p><h2 id="输入样例-1">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs in">2 4 4 2<br>1 2 3 2<br>5 3 3 4<br></code></pre></td></tr></table></figure><h2 id="输出样例-1">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">2 1 2 4<br>2 3 3 1<br>2 3 3 5<br></code></pre></td></tr></table></figure><h2 id="解法-1">解法</h2><p>我的程序用了一个DFS，</p><p>第一步：按曼哈顿距离D1，遍历一下中间节点</p><p>第二步：判断能不能从中间节点，以D2的距离，走到终点</p><blockquote><p>这题其实没那么复杂，用四重循环遍历两个点坐标，再判断曼哈顿距离就可以。</p></blockquote><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> c1,c2,r1,r2;<span class="hljs-comment">//北，南，西，东</span><br><span class="hljs-type">int</span> t1,t2,t3,t4;<br><span class="hljs-type">int</span> fx,fy,d1,d2;<br><span class="hljs-type">int</span> sx,sy,mx,my;<br><br><span class="hljs-type">int</span> dirx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> diry[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">res</span>&#123;<br><span class="hljs-type">int</span> x1,y1,x2,y2;<br><span class="hljs-built_in">res</span>(<span class="hljs-type">int</span> x1_,<span class="hljs-type">int</span> y1_,<span class="hljs-type">int</span> x2_,<span class="hljs-type">int</span> y2_)&#123;<br>x1 = x1_;<br>y1 = y1_;<br>x2 = x2_;<br>y2 = y2_;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> res &amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(x1 != rhs.x1) <span class="hljs-keyword">return</span> x1 &lt; rhs.x1;<br><span class="hljs-keyword">if</span>(y1 != rhs.y1) <span class="hljs-keyword">return</span> y1 &lt; rhs.y1;<br><span class="hljs-keyword">if</span>(x2 != rhs.x2) <span class="hljs-keyword">return</span> x2 &lt; rhs.x2;<br><span class="hljs-keyword">if</span>(y2 != rhs.y2) <span class="hljs-keyword">return</span> y2 &lt; rhs.y2;<br>&#125;<br><br>&#125;;<br>vector&lt;res&gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">2</span>)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">res</span>(sx,sy,mx,my));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(sx == r1 - t3 || sx == r2 + t4 || sy == c1 || sy == c2)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= d1 ; i ++)&#123;<br><span class="hljs-type">int</span> j = d1 - i;<br><span class="hljs-type">int</span> s = <span class="hljs-number">4</span>; <span class="hljs-comment">//如果i,j为0，有重复的情况，用s去重。</span><br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) s = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; k &lt; s ; k ++)&#123; <span class="hljs-comment">//遍历中间节点</span><br>mx = sx + i*dirx[k];<br>my = sy + j*diry[k];<br><span class="hljs-keyword">if</span>(mx &gt;= <span class="hljs-number">1</span> &amp;&amp; mx &lt;= <span class="hljs-number">5</span> &amp;&amp; my &gt;= <span class="hljs-number">1</span> &amp;&amp; my &lt;= <span class="hljs-number">5</span>) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">if</span>(mx == r1 - t3 || mx == r2 + t4 || my == c1 + t1 || my == c2 - t2)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">bool</span> arv = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= d2 ; i ++)&#123;<br><span class="hljs-type">int</span> j = d2 - i;<br><span class="hljs-type">int</span> s = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) s = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; k &lt; s ; k ++)&#123; <span class="hljs-comment">//判断能不能走到终点</span><br><span class="hljs-keyword">if</span>(mx + i*dirx[k] == fx &amp;&amp; my + j*diry[k] == fy)&#123;<br>arv = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(arv) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;r1&gt;&gt;r2;<br>cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3&gt;&gt;t4;<br>cin&gt;&gt;fx&gt;&gt;fy&gt;&gt;d1&gt;&gt;d2;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">5</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">5</span> ; j ++)&#123;<br>sx = i;<br>sy = j;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(res it : ans)&#123;<br>cout&lt;&lt;it.x1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.y1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.x2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it.y2&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-战利品分配">RC-u3 战利品分配</h1><p>在某个战争游戏中，多个玩家组成一个大型军团，攻下若干城池，并获得战利品。</p><p>具体而言，游戏中有 <em>N</em> 个城市，并以 <em>M</em> 条长度为 1的无向道路连接，玩家们组成的军团从 <em>S</em> 号城市开始进攻，目的地是<em>T</em> 号城市，每个城市攻下后的战利品价值为 <span class="math inline">\(p_i\)</span>。</p><p>为了合理地分配战利品，军团们定下了规矩：假设军团里有 <em>K</em>位玩家，那么从 <em>S</em> 号城市开始，第 1 个攻下的城市分配给第 1位玩家，第 2 个攻下的分配给第 2 位玩家，……，第 <em>K</em>个攻下的分配给第 <em>K</em> 位玩家，第 <em>K</em>+1个攻下的则重新开始计算，分配给第 1 位玩家，以此类推。</p><p>军团很强，路上所有的城市都可以轻松进攻下来。你作为军团的指挥，可以指定玩家的进攻路线。但玩家们都希望尽快结束游戏，因此<em>S</em> 到 <em>T</em>的距离必须是最短的。你需要做的是在最短距离的限制下选择对自己最好的线路，获得尽可能高的战利品价值。请输出你的答案。</p><h2 id="输入格式-2">输入格式</h2><p>输入第一行是四个数 <em>N</em>,<em>M</em>,<em>K</em>,<em>P</em>(1≤<em>N</em>,<em>M</em>≤105,1≤<em>K</em>≤104,1≤<em>P</em>≤<em>K</em>)，表示城市数量（于是城市从1 到 <em>N</em> 编号）、连接道路数量以及你在军团中的 <em>K</em>位玩家中排第 <em>P</em> 位（即你战利品分配在第 <em>P</em> 位）。</p><p>第二行是 <em>N</em> 个被空格隔开的非负整数，第 <em>i</em> 个数对应*p**i* (0≤*p**i<em>≤104)，表示编号为 </em>i*的城市的战利品价值（<em>i</em>=1,⋯,<em>N</em>）。</p><p>然后的 <em>M</em> 行，每行给出两个用空格分隔的正整数 <em>U</em> 和<em>V</em>，表示编号为 <em>U</em> 和 <em>V</em>的城市之间有道路连接。</p><p>最后的一行是两个正整数<em>S</em>,<em>T</em>，表示开始的城市编号与目的地的城市编号。开始和目的地的城市也是可以进攻并获取战利品的。</p><h2 id="输出格式-2">输出格式</h2><p>输出一行，表示你可以取得的最大价值。</p><h2 id="输入样例-2">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs in">9 11 2 2<br>100 150 130 50 30 20 200 0 70<br>1 2<br>1 3<br>2 3<br>2 4<br>2 5<br>3 6<br>4 7<br>5 7<br>6 8<br>7 9<br>8 9<br>1 9<br></code></pre></td></tr></table></figure><h2 id="输出样例-2">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">350<br></code></pre></td></tr></table></figure><h2 id="解法-2">解法</h2><p>无权图的单源最短路问题，考虑使用BFS来做</p><p>在层序遍历时，维护路径的价值sum，从多条最短路中选择一条价值最高的，即为答案。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-type">int</span> n,m,k,p,s,t,ans;<br><span class="hljs-type">int</span> val[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br>vector&lt;<span class="hljs-type">int</span> &gt; edge[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">step</span>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> dep;<br><span class="hljs-type">int</span> sum;<br><br><span class="hljs-built_in">step</span>(<span class="hljs-type">int</span> x_,<span class="hljs-type">int</span> dep_,<span class="hljs-type">int</span> sum_)&#123;<br>x = x_;<br>dep = dep_;<br>sum = sum_;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;step&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">step</span>(s,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br><span class="hljs-type">int</span> min_ = INT_MAX;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().x;<br><span class="hljs-type">int</span> dep = q.<span class="hljs-built_in">front</span>().dep;<br><span class="hljs-type">int</span> sum = q.<span class="hljs-built_in">front</span>().sum;<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-keyword">if</span>(dep &gt; min_) <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span>(dep % k == <span class="hljs-number">0</span> &amp;&amp; k == p) sum += val[x]; <span class="hljs-comment">//k==p需要特判</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dep%k == p) sum += val[x];<br><br><span class="hljs-keyword">if</span>(x == t &amp;&amp; dep &lt;= min_)&#123;<br>ans = <span class="hljs-built_in">max</span>(sum,ans);<br>min_ = dep;<br>&#125;<br>        <br>visited[x] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : edge[x])&#123;<br><span class="hljs-keyword">if</span>(!visited[it]) q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">step</span>(it,dep<span class="hljs-number">+1</span>,sum));<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;val[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;<br>edge[a].<span class="hljs-built_in">push_back</span>(b);<br>edge[b].<span class="hljs-built_in">push_back</span>(a);<br>&#125;<br>cin&gt;&gt;s&gt;&gt;t;<br><span class="hljs-built_in">bfs</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-变牛的最快方法">RC-u4 变牛的最快方法</h1><p><img src="/competition/RAICOM-CAIP/2022-%E5%9B%BD%E8%B5%9B/3b6f7584-a4ba-4d73-a4f5-49b956dd3604.png" alt="shu.png"> <img src="/competition/RAICOM-CAIP/2022-%E5%9B%BD%E8%B5%9B/9d18450d-de04-4437-9da4-22f633b8f806.png" alt="niu.png"></p><p>这里问的是把任意一种动物的图像变成牛的方法……比如把一只鼠的图像变换成牛的图像。方法如下：</p><ul><li>首先把屏幕上的像素点进行编号；</li><li>然后把两只动物的外轮廓像素点编号按顺时针记录下来；</li><li>用最少的变换次数将鼠的轮廓变成牛的 —— 这里仅允许对鼠的轮廓进行 3钟操作：</li></ul><ol type="1"><li>插入一个像素编号</li><li>删除一个像素编号</li><li>更改一个像素编号</li></ol><h2 id="输入格式-3">输入格式</h2><p>输入分别在两行中给出两种动物的轮廓像素点编号，编号为 (0,106]区间内的整数，允许重复。轮廓以编号 −1结尾，这个编号不算在轮廓内。题目保证每种动物的轮廓包含不超过 1000个像素点。</p><h2 id="输出格式-3">输出格式</h2><p>在第一行中输出从第一只动物变换成第二只动物需要的最少变换次数。</p><p>在第二行中顺次描述对第一只动物轮廓的每个像素所作的操作：</p><ul><li>如果这个像素被删除，则在对应位置输出 0</li><li>如果这个像素被改变，则在对应位置输出 1</li><li>如果这个像素不变，则在对应位置输出 2</li><li>如果这个像素前面或者后面插入了一个像素，则在插入的位置输出 3</li></ul><p>答案可能不唯一，输出任何一种可能的解都可以。行首尾和数字间均无空格。</p><h2 id="输入样例-3">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">13 5 6 20 2 20 1 13 9 20 3 28 3 34 6 25 233 -1<br>3 5 6 20 6 20 3 5 9 3 9 20 3 6 6 25 233 -1<br></code></pre></td></tr></table></figure><h2 id="输出样例-3">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">8<br>122212112023121222<br></code></pre></td></tr></table></figure><h2 id="样例解释">样例解释</h2><p>1、13 更改为 3，随后 5、6、20 不变 2、2 更改为 6，下一个 20 不变 3、1更改为 3 4、第二个 13 更改为 5，随后 9 不变 5、删除下一个 20，后面的 3不变 6、在 28 的前面插入 9 7、28 更改为 20，后面的 3 不变 8、34 更改为6，后面的 6、25、233 不变</p><h2 id="解法-3">解法</h2><p>动态规划经典 之 最短编辑距离+路径回溯</p><p>递推式：<span class="math inline">\(dp[i][j] = min(dp[i-1][j] +1,dp[i][j-1] + 1,dp[i-1][j-1] + (a1[i] != a2[j]))\)</span></p><p>当前最优的状态 = 删除/插入/不变/变换这四种操作执行后，耗费次数最小的。</p><p>路径回溯需要在dp数组生成过程中维护pre（路径）数组和op（操作）数组。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">int</span> l1,l2;<br><span class="hljs-type">int</span> a1[MAX],a2[MAX];<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pre[MAX][MAX];<br><span class="hljs-type">int</span> op[MAX][MAX],dp[MAX][MAX];<br><br><span class="hljs-comment">//删除 0 改变 1 不变 2 插入 3</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><br><span class="hljs-keyword">while</span>(cin&gt;&gt;a1[++l1])&#123;<br><span class="hljs-keyword">if</span>(a1[l1] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l1--;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;a2[++l2])&#123;<br><span class="hljs-keyword">if</span>(a2[l2] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l2--;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l1 ; i ++)&#123;<br>pre[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>dp[i][<span class="hljs-number">0</span>] = i;<br>op[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l2 ; i ++)&#123;<br>pre[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);<br>dp[<span class="hljs-number">0</span>][i] = i;<br>op[<span class="hljs-number">0</span>][i] = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l1 ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= l2 ; j ++)&#123;<br><span class="hljs-type">int</span> add = dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 3</span><br><span class="hljs-type">int</span> del = dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 0</span><br><span class="hljs-type">int</span> rpl = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + (a1[i] != a2[j]); <span class="hljs-comment">//1 ; 2</span><br><span class="hljs-type">int</span> min_ = <span class="hljs-built_in">min</span>(add,<span class="hljs-built_in">min</span>(del,rpl));<br><br><span class="hljs-keyword">if</span>(min_ == add)&#123;<br>dp[i][j] = add;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i,j<span class="hljs-number">-1</span>);<br>op[i][j] = <span class="hljs-number">3</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min_ == del)&#123;<br>dp[i][j] = del;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j);<br>op[i][j] = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dp[i][j] = rpl;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>);<br>op[i][j] = a1[i] == a2[j] ? <span class="hljs-number">2</span>:<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br><span class="hljs-comment">//路径回溯</span><br><span class="hljs-type">int</span> x = l1;<br><span class="hljs-type">int</span> y = l2;<br>stack&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">while</span>(x||y)&#123;<br>ans.<span class="hljs-built_in">push</span>(op[x][y]);<br><span class="hljs-keyword">auto</span> back = pre[x][y];<br>x = back.first;<br>y = back.second;<br>&#125;<br><span class="hljs-keyword">while</span>(!ans.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;ans.<span class="hljs-built_in">top</span>();<br>ans.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-养老社区">RC-u5 养老社区</h1><p>作为智能看护的一部分，你需要评估某个养老社区是否适合开展智能看护的服务。</p><p>这个养老社区有若干幢住宅楼，每个住宅楼有一个种类，住宅楼之间由长度为1 的道路连接，道路都是双向道路且没有构成环 ——你可以简单地认为养老社区的路构成了一棵树。</p><p>假设我们能找到三个住宅楼，这三个住宅楼两两之间的最短距离相等，并且三个住宅楼的种类不一样，那么我们称这三个住宅楼组成的三元组为<strong>适合智能看护的</strong>，指的是为了服务这三个住宅楼，我们可能可以方便地找到适合建设服务中心的地方。一个社区的<strong>适合度</strong>指的是能够找到多少本质不同的<strong>适合智能看护的</strong>住宅楼三元组。</p><p>本质不同两个的三元组指的是：三元组内元素任意排列后，两个三元组仍然不相等。</p><p>给定这个养老社区的情况，请你求出这个社区的适合度。</p><h2 id="输入格式-4">输入格式</h2><p>输入第一行是一个正整数 <em>N</em>(1≤<em>N</em>≤2×103)，表示养老社区里住宅楼的数量（于是住宅楼从 1 到<em>N</em> 编号）。</p><p>接下来 <em>N</em>−1 行，每行给出空格分隔的两个正整数 <em>U</em> 和<em>V</em>，表示编号为 <em>U</em> 和 <em>V</em> 的住宅楼之间有一条长度为1 的道路。</p><p>最后一行给出 <em>N</em> 个数，第 <em>i</em> 个数表示编号为 <em>i</em>的住宅楼的种类为<em>T<strong>i<em>（1≤</em>T</strong>i</em>≤<em>N</em>）。</p><p>保证给定的数据会将所有住宅楼连接成一棵完整的树。</p><h2 id="输出格式-4">输出格式</h2><p>输出一行一个正整数，表示社区的适合度。</p><h2 id="输入样例-4">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs in">11<br>1 2<br>1 3<br>1 4<br>2 5<br>2 6<br>3 7<br>3 8<br>4 9<br>4 10<br>1 11<br>1 2 3 4 5 6 7 8 9 9 10<br></code></pre></td></tr></table></figure><h2 id="输出样例-4">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">14<br></code></pre></td></tr></table></figure><h2 id="解法-4">解法</h2><p>多源无权图最短路问题（n &lt;= 2000），考虑使用n次的BFS。</p><p>首先，使用n次BFS，得到每个点的最短路径数组。</p><p>然后，三重循环遍历每个三元组，判断是否符合条件即可。</p><blockquote><p>一次写的时候，用Floyd去做:），实测能过 5/8个样例。</p></blockquote><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">2e3</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> type[MAX];<br><span class="hljs-type">int</span> dist[MAX][MAX];<span class="hljs-comment">//dist[i][j]:i-&gt;j的最短路</span><br><span class="hljs-type">bool</span> visited[MAX];<br>vector&lt;<span class="hljs-type">int</span>&gt; edge[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<br>queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q;<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br>q.<span class="hljs-built_in">push</span>(&#123;st,<span class="hljs-number">0</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>().first;<span class="hljs-type">int</span> dep = q.<span class="hljs-built_in">front</span>().second;q.<span class="hljs-built_in">pop</span>();<br>dist[st][x] = <span class="hljs-built_in">min</span>(dist[st][x],dep);<br>visited[x] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : edge[x])&#123;<br><span class="hljs-keyword">if</span>(!visited[it]) q.<span class="hljs-built_in">push</span>(&#123;it,dep<span class="hljs-number">+1</span>&#125;);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n;<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>edge[x].<span class="hljs-built_in">push_back</span>(y);<br>edge[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;type[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-built_in">bfs</span>(i);<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(type[i] == type[j] || dist[i][j] == INF) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这里必须优化，不然过不了</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = j<span class="hljs-number">+1</span> ; u &lt;= n ; u ++)&#123;<br><span class="hljs-keyword">if</span>(type[i] != type[j] &amp;&amp; type[j] != type[u] &amp;&amp; type[i] != type[u]<br>&amp;&amp; dist[i][j] != INF &amp;&amp; dist[i][j] == dist[j][u] &amp;&amp; dist[i][j] == dist[i][u])&#123;<br>ans++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CAIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2022-省赛题解</title>
    <link href="/competition/RAICOM-CAIP/2022-%E7%9C%81%E8%B5%9B/"/>
    <url>/competition/RAICOM-CAIP/2022-%E7%9C%81%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="rc-u1-不要浪费金币模拟">RC-u1 不要浪费金币（模拟）</h1><p>哲哲最近在玩一个游戏，击杀怪物能获得金币 —— 这里记击杀第 <em>i</em>个怪物获得的金币数量为 *P**i*。</p><p>然而这个游戏允许拥有的金币数量是有上限的，当超过时，超过上限的部分就会被系统光明正大地吃掉，哲哲就拿不到了。</p><p>为了不浪费金币，哲哲决定，当下一个要击杀的怪物可获得的金币会导致自己拥有的金币数量超过上限时，就去消费一次，把自己已有的金币全部用完。</p><p>现在给定哲哲将要击杀的一系列怪物对应的金币数量，请你计算一下哲哲去消费了几次。</p><h3 id="输入格式">输入格式</h3><p>输入第一行是两个整数 <em>N</em>,<em>M</em>（1≤<em>N</em>≤103,1≤<em>M</em>≤106），表示击杀的怪物数量以及系统允许拥有金币数量的上限。</p><p>接下来一行是由空格隔开的 <em>N</em> 个数*P**i<em>（</em>i<em>=1,⋯,</em>N<em>），依次表示击杀第 </em>i*个怪物能获得的金币数量。假设哲哲是按输入顺序击杀怪物的，并且每个 *P**i*都是 不超过 106 的非负整数。</p><h3 id="输出格式">输出格式</h3><p>在一行中输出哲哲去消费的次数。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">10 10<br>1 2 3 4 1 2 3 5 11 1<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">4<br></code></pre></td></tr></table></figure><h3 id="样例解释">样例解释</h3><p>消费时间点为：第四个怪物击杀后、第七个怪物击杀后、第八个怪物击杀后、第九个怪物击杀后。</p><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> ans,sum;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> t; cin&gt;&gt;t;<br><span class="hljs-keyword">if</span>(sum + t &gt; m)&#123;<br>ans++;<br>sum = <span class="hljs-number">0</span>;<br>&#125;<br>sum += t;<br>&#125;<br>cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u2-智能服药助手模拟">RC-u2 智能服药助手（模拟）</h1><p>智能看护中很重要的环节是安排需要服药的老年人的服药计划。</p><p>已知机器人需要照顾的某位老年人需要服用 <em>N</em>种药物，但某些药物不宜间隔过短服用 —— 比如降糖药一般遵医嘱日服 3次，两次之间需要间隔至少 4小时。当需要服用的药物比较多，医嘱比较复杂时，如何保证每位老人的服药计划是安全合理的，就成为一个挑战。</p><p>本题给定一套服药计划，请你检查一下计划是否存在问题。</p><h3 id="输入格式-1">输入格式</h3><p>输入第一行给出两个整数<em>N</em>,<em>M</em>（1≤<em>N</em>,<em>M</em>≤103），表示老人需要服用<em>N</em> 种药物（药物种类从 1 到 <em>N</em> 编号），对应的服药计划有<em>M</em> 条记录。</p><p>接下来首先在一行中给出 <em>N</em> 个用空格隔开的整数 *T**i*（−1≤<em>T<strong>i<em>≤100,</em>T</strong>i</em>\=0)，表示编号为<em>i</em> 的药物需要间隔至少 *T**i* 个单位时间服用。如果 *T**i* 为−1，则说明这种药物没有间隔要求。</p><p>接下来的 <em>M</em>行，每行给出一条服药计划中的记录，格式为：首先给出两个非负整数<em>t</em> 和 <em>k</em>(0≤<em>t</em>≤109,0≤<em>k</em>≤<em>N</em>)，表示服药的时刻为<em>t</em>，服用了 <em>k</em> 种药物；然后紧接着列出 <em>k</em>个数，每个数对应 <em>t</em>时刻要吃的药物种类的编号。一行中的数字之间以空格分隔。</p><p>题目保证：记录按照服药时刻 <em>t</em>的递增顺序给出；每一时刻服用的药物种类各不相同。注意：同一种药物可能需要在不同的时刻重复服用。如果一位老人在*t**i* 时刻和 *t**j* 时刻服用了同一种药物，则他服用的间隔时间为∣<em>t<strong>i<em>−</em>t</strong>j</em>∣。</p><h3 id="输出格式-1">输出格式</h3><p>按照输入顺序检查每一条记录中的每一种药物。如果在 <code>Y</code>时刻不宜服用药物 <code>X</code>，则在一行中输出：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Don<span class="hljs-symbol">&#x27;t</span> take X <span class="hljs-keyword">at</span> Y!<br></code></pre></td></tr></table></figure><p>注意：老人收到提醒后会按照提醒不服用指定的药物。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs in">10 6<br>1 2 3 4 5 -1 -1 -1 -1 -1<br>0 1 1<br>1 2 1 2<br>2 1 2<br>3 2 1 3<br>5 3 1 3 4<br>6 2 1 4<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">Don&#x27;t take 2 at 2!<br>Don&#x27;t take 3 at 5!<br>Don&#x27;t take 4 at 6!<br></code></pre></td></tr></table></figure><h3 id="代码-1">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e4</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> last[MAX],gap[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;gap[i];<br>&#125;<br><span class="hljs-built_in">memset</span>(last,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(last));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> t,k;cin&gt;&gt;t&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= k ; j ++)&#123;<br><span class="hljs-type">int</span> pi;cin&gt;&gt;pi;<br><span class="hljs-keyword">if</span>(last[pi] != <span class="hljs-number">-1</span> &amp;&amp; t - last[pi] &lt; gap[pi])&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Don&#x27;t take &quot;</span>&lt;&lt;pi&lt;&lt;<span class="hljs-string">&quot; at &quot;</span>&lt;&lt;t&lt;&lt;<span class="hljs-string">&quot;!&quot;</span>&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span> last[pi] = t;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u3-跑团机器人字符串处理">RC-u3 跑团机器人（字符串处理）</h1><p>在桌面角色扮演游戏（TRPG，俗称“跑团”）中，玩家需要掷出若干个骰子，根据掷出的结果推进游戏进度。在线上同样可以跑团，方法是由玩家们向机器人发出指令，由机器人随机产生每个需要掷出的骰子的结果。</p><p>玩家向机器人发出的指令是一个仅涉及加法和减法的表达式，即对若干个数字进行一系列加法或减法计算。这些数字可以是直接给出的非负整数（数字不超过1000），也可以是若干个骰子掷出的结果。</p><p>“掷骰子”这个动作对应的指令格式为 <em>x</em>d<em>y</em>，表示摇动<em>x</em> 个 <em>y</em>面的骰子（1≤<em>x</em>≤1000,2≤<em>y</em>≤1000）。当 <em>x</em> 为 1时，1 可以省略。</p><p>例如指令 <code>2d3+3-d4</code> 的意思是：先掷出 2 个 3面骰子（你不必考虑现实中是否存在这样的骰子），不妨假设结果为 1 和 3，则<code>2d3</code> 的结果就是两个骰子的面值之和 4；然后计算 4 +3，得到结果为 7；再掷出 1 个 4 面骰子，不妨假设结果为 2，则计算 7 - 2得到最终结果 5。</p><p>本题就请你计算玩家输入的指令里，不同种类的骰子需要掷出几个，以及可能得到的结果在什么区间范围内。</p><h3 id="输入格式-2">输入格式</h3><p>输入在一行中给出一条符合题目描述的玩家输入机器人的指令。题目保证指令长度不超过2∗104。</p><h3 id="输出格式-2">输出格式</h3><p>首先输出不同种类的骰子分别需要掷出几个。每种骰子的信息占一行，依次输出骰子的面数和投掷的数量，按面数从小到大输出。</p><p>输入指令保证至少有一个骰子需要掷出。</p><p>最后一行输出两个数，表示根据输入指令可以得到的最小结果和最大结果。</p><p>同一行数字间以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例-2">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">d6+3d5+2-2d3+2d5<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs out">3 2<br>5 5<br>6 1<br>2 31<br></code></pre></td></tr></table></figure><h3 id="解法">解法</h3><p>预处理：输入字符串左侧连接+号</p><p>从左到右读字符串，每次读到+/-号，往后读取直到下一个+/-为止的字符串，存储为res；</p><p>根据d在res中的位置（如果没有，为常量，需要特判）分类讨论。</p><h3 id="代码-2">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br>string s;<br>string res;<br><span class="hljs-type">int</span> min_;<br><span class="hljs-type">int</span> max_;<br><span class="hljs-type">int</span> cnt[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hasD</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> idxD = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>(); i ++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;d&#x27;</span>)&#123;<br>idxD = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> idxD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Stoi</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br>ans = ans*<span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br>s = <span class="hljs-string">&quot;+&quot;</span> + s;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>())&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br><span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>;<br>res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(k &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>() &amp;&amp; s[k] != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; s[k] != <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>res = res + s[k++];<br>&#125;<br>i = k;<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">hasD</span>(res);<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">-1</span>)&#123;<br>min_ += <span class="hljs-built_in">Stoi</span>(res);<br>max_ += <span class="hljs-built_in">Stoi</span>(res);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> type = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,res.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>));<br>max_ += type;<br>min_ += <span class="hljs-number">1</span>;<br>cnt[type] ++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,p));<br><span class="hljs-type">int</span> type = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(p<span class="hljs-number">+1</span>,res.<span class="hljs-built_in">length</span>()-p));<br>max_ += type*num;<br>min_ += num;<br>cnt[type] += num;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br><span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>;<br>res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(k &lt; (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>() &amp;&amp; s[k] != <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; s[k] != <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>res += s[k++];<br>&#125;<br>i = k;<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">hasD</span>(res);<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">-1</span>)&#123;<br>min_ -= <span class="hljs-built_in">Stoi</span>(res);<br>max_ -= <span class="hljs-built_in">Stoi</span>(res);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> type = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,res.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>));<br>max_ -= <span class="hljs-number">1</span>;<br>min_ -= type;<br>cnt[type] ++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,p));<br><span class="hljs-type">int</span> type = <span class="hljs-built_in">Stoi</span>(res.<span class="hljs-built_in">substr</span>(p<span class="hljs-number">+1</span>,res.<span class="hljs-built_in">length</span>()-p));<br>max_ -= num;<br>min_ -= type*num;<br>cnt[type] += num;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">1000</span> ; i ++)&#123;<br><span class="hljs-keyword">if</span>(cnt[i] != <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;endl;<br>&#125;<br>&#125;<br>cout&lt;&lt;min_&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;max_&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u4-攻略分队dfs">RC-u4 攻略分队（DFS）</h1><p>副本是游戏里的一个特色玩法，主要为玩家带来装备、道具、游戏资源的产出，满足玩家的游戏进程。</p><p>在 MMORPG《最终幻想14》里，有一个攻略人数最大达到 56人的副本“巴尔德西昂兵武塔”，因为有在副本里死亡不能复活、机制比较整蛊等特点，一度被玩家视作洪水猛兽。</p><p>在副本的开始，我们会遇到第一个难关：攻略的玩家要分为两组，同时讨伐副本BOSS “欧文”和“亚特”。</p><p>已知以下信息：</p><ol type="1"><li>玩家会组成 6 支队伍进入副本，其中第 <em>i</em> 队有 *V**i*位玩家（<em>i</em>=1,⋯,6）。</li><li>每支队伍可能会有一些特殊角色：MT（主坦克）、工兵（负责探测陷阱）和指挥（负责指挥玩家）。</li></ol><p>我们的任务是合理安排玩家的分组，以最大程度增加副本通过概率。分组的原则如下：</p><ol type="1"><li>要将所有队伍分成 2 组，每支队伍必须且仅属于其中一组；</li><li>每组<strong>必须</strong>有至少一个 MT（主坦克）。</li></ol><p>如果满足上述原则的分组方案不唯一，则按照下列规则确定唯一解：</p><ol type="1"><li>优先选择每组有至少一个指挥和至少一个工兵的方案；</li><li>如果规则 1 无法满足，则优先选择每组至少有一个指挥的方案；</li><li>如果所有方案都不满足规则 2，或经过前 2个规则筛选后，分组方案仍不唯一，则选择两边人数尽可能接近（即两边人数差尽可能小）的方案；</li><li>如果满足规则 3的方案还不唯一，选择讨伐“欧文”的人数<strong>大于等于</strong>讨伐“亚特”的人数的方案；</li><li>如果满足规则 4的方案还不唯一，选择讨伐“欧文”的队伍编号方案中最小的一个。</li></ol><p>注：一个队伍编号方案<em>A</em>={<em>a</em>1&lt;⋯&lt;<em>a<strong>m<em>} 比</em>B<em>={</em>b<em>1&lt;⋯&lt;</em>b</strong>n</em>} 小，当且仅当存在1≤<em>k</em>≤min(<em>m</em>,<em>n</em>) 使得<em>a<strong>i<em>=</em>b</strong>i</em> 对所有0&lt;<em>i</em>&lt;<em>k</em> 成立，且<em>a<strong>k<em>&lt;</em>b</strong>k</em>。</p><p>本题就请你给出满足所有分组原则的分配方案。</p><p><em>感谢 王宪泉 同学对规则 4 的指正，于 2022-08-04 修改</em></p><h3 id="输入格式-3">输入格式</h3><p>输入第一行给出 6 支队伍的玩家数量，即 6 个非负整数 *V**i*(0≤*V**i<em>≤8,1≤</em>i*≤6)。队伍人数为 0 时表示队伍不存在。</p><p>随后 6 行，按队伍编号顺序，每行给出一支队伍的特殊角色，格式为<code>ABC</code>，其中 <code>A</code> 对应 MT，<code>B</code>对应工兵，<code>C</code> 对应指挥。三种角色对应取值 0 或 1，0表示没有该角色，1 表示有。</p><p>注：由于可能存在一人兼任多个特殊角色的情况，所以一支队伍中的特殊角色数量有可能大于该队伍的玩家数量。</p><h3 id="输出格式-3">输出格式</h3><p>输出分两行，第一行输出讨伐“欧文”的队伍编号，第二行输出讨伐“亚特”的队伍编号。同一行中的编号按升序输出，以1 个空格分隔，行首尾不得有多余空格。</p><p>如果不存在合法的方案，输出<code>GG</code>。</p><h3 id="输入样例1">输入样例1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">6 8 7 5 3 0<br>010<br>101<br>110<br>001<br>111<br>000<br></code></pre></td></tr></table></figure><h3 id="输出样例1">输出样例1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">2 3<br>1 4 5<br></code></pre></td></tr></table></figure><h3 id="输入样例2">输入样例2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">6 8 7 5 3 0<br>010<br>101<br>010<br>001<br>011<br>000<br></code></pre></td></tr></table></figure><h3 id="输出样例2">输出样例2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">GG<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><p>使用DFS生成每一种解，6个队伍，一共是2^6种解。</p><p>创建结构体Solusion，存储每一种解，根据题目给定的条件，对数组排序。</p><p>数组[0]即为最优解，若最优解无法满足：每组都有MT这个初始条件，则无解，输出GG。</p><h2 id="代码-3">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">6</span>];<br><span class="hljs-type">bool</span> hasType[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Solusion</span>&#123;<br>vector&lt;<span class="hljs-type">int</span> &gt; ou;<br>vector&lt;<span class="hljs-type">int</span> &gt; ya;<br><span class="hljs-type">bool</span> hasType0; <span class="hljs-comment">//有MT</span><br><span class="hljs-type">bool</span> hasType2;<span class="hljs-comment">//每组至少有一个指挥</span><br><span class="hljs-type">bool</span> hasType1_2;<span class="hljs-comment">//每组至少有一个工兵和指挥</span><br><span class="hljs-type">int</span> gap; <span class="hljs-comment">//差距</span><br><span class="hljs-type">bool</span> isOuMore; <span class="hljs-comment">//ou数量 &gt;= ya数量</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">bool</span> ouType[<span class="hljs-number">3</span>];<br><span class="hljs-type">bool</span> yaType[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">memset</span>(ouType,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(ouType));<br><span class="hljs-built_in">memset</span>(yaType,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(yaType));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ou)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">3</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(hasType[it][j])&#123;<br>ouType[j] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ya)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">3</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(hasType[it][j])&#123;<br>yaType[j] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>hasType0 = ouType[<span class="hljs-number">0</span>]&amp;&amp;yaType[<span class="hljs-number">0</span>];<br>hasType2 = ouType[<span class="hljs-number">2</span>]&amp;&amp;yaType[<span class="hljs-number">2</span>];<br>hasType1_2 = ouType[<span class="hljs-number">2</span>]&amp;&amp;ouType[<span class="hljs-number">1</span>]&amp;&amp;yaType[<span class="hljs-number">2</span>]&amp;&amp;yaType[<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> ouSize = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> yaSize = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ou)&#123;<br>ouSize += cnt[it];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ya)&#123;<br>yaSize += cnt[it];<br>&#125;<br>gap = <span class="hljs-built_in">abs</span>(ouSize - yaSize);<br>isOuMore = (ouSize &gt;= yaSize);<br>&#125;<br>&#125;sol;<br>vector&lt;Solusion&gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> dep, Solusion tep)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep == <span class="hljs-number">6</span>)&#123;<br>tep.<span class="hljs-built_in">init</span>();<br>ans.<span class="hljs-built_in">push_back</span>(tep);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt[dep] == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>,tep);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>tep.ou.<span class="hljs-built_in">push_back</span>(dep);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>,tep);<br>tep.ou.<span class="hljs-built_in">pop_back</span>();<br>tep.ya.<span class="hljs-built_in">push_back</span>(dep);<br><span class="hljs-built_in">dfs</span>(dep<span class="hljs-number">+1</span>,tep);<br>tep.ya.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpSol</span><span class="hljs-params">(<span class="hljs-type">const</span> Solusion&amp; a,<span class="hljs-type">const</span> Solusion&amp; b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.hasType0 != b.hasType0) <span class="hljs-keyword">return</span> a.hasType0 &gt; b.hasType0;<br><span class="hljs-keyword">if</span>(a.hasType1_2 != b.hasType1_2) <span class="hljs-keyword">return</span> a.hasType1_2 &gt; b.hasType1_2;<br><span class="hljs-keyword">if</span>(a.hasType2 != b.hasType2) <span class="hljs-keyword">return</span> a.hasType2 &gt; b.hasType2;<br><span class="hljs-keyword">if</span>(a.gap != b.gap) <span class="hljs-keyword">return</span> a.gap &lt; b.gap;<br><span class="hljs-keyword">if</span>(a.isOuMore != b.isOuMore) <span class="hljs-keyword">return</span> a.isOuMore &gt; b.isOuMore;<br><span class="hljs-keyword">return</span> a.ou &lt; b.ou;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">6</span> ; i ++)&#123;<br>cin&gt;&gt;cnt[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">6</span> ; i ++)&#123;<br>string s;cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j ++)&#123;<br><span class="hljs-keyword">if</span>(s[j] == <span class="hljs-string">&#x27;0&#x27;</span>) hasType[i][j] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[j] == <span class="hljs-string">&#x27;1&#x27;</span>) hasType[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,sol);<br><span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>(),cmpSol);<br><br><span class="hljs-keyword">if</span>(ans[<span class="hljs-number">0</span>].hasType0 == <span class="hljs-literal">false</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;GG&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].ou.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;ans[<span class="hljs-number">0</span>].ou[i]<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">if</span>(i != (<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].ou.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;cout&lt;&lt;endl;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; (<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].ya.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br>cout&lt;&lt;ans[<span class="hljs-number">0</span>].ya[i]<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">if</span>(i != (<span class="hljs-type">int</span>)ans[<span class="hljs-number">0</span>].ya.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;cout&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rc-u5-树与二分图二分图">RC-u5 树与二分图（二分图）</h1><p>设 <em>G</em>=(<em>V</em>,<em>E</em>) 是一个无向图，如果顶点集合<em>V</em> 可分割为两个互不相交的子集(<em>A</em>,<em>B</em>)，并且每条边 (<em>i</em>,<em>j</em>)∈<em>E</em>的两个端点 <em>i</em> 和 <em>j</em> 分别属于这两个不同的顶点子集，则称图<em>G</em> 为一个二分图。</p><p>现在给定一棵树<em>T</em>，要求选择树中两个<strong>没有边相连</strong>的结点 <em>i</em>和 <em>j</em>，使得将无向边 (<em>i</em>,<em>j</em>) 加进 <em>T</em>后能够构成二分图。你的任务是计算满足这个要求的选择方案有多少种。</p><h3 id="输入格式-4">输入格式</h3><p>输入第一行给出一个正整数 <em>N</em>(2≤<em>N</em>≤106)，表示树中结点的个数。</p><p>接下来 <em>N</em>−1行，每行给出树中一条边的两端结点编号，以空格分隔。结点编号从 1开始。题目保证输入给出的是一棵树中所有的边。</p><h3 id="输出格式-4">输出格式</h3><p>在一行中输出方案数。注意：连接 (1,2) 和 (2,1) 视作同一个方案。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs in">7<br>1 2<br>2 3<br>2 4<br>2 5<br>2 6<br>4 7<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">4<br></code></pre></td></tr></table></figure><h3 id="解法-2">解法</h3><p>要解这道题，首先要知道：</p><p>1.树本身是一个按层序奇偶划分的二分图。</p><p>2.完全二分图边的个数为：N * M ，即将两个集合中点数量之积</p><p>这道题的本质是求：将一颗给定的树构造成完全二分图需要几条边。</p><p>即：完全二分图的边 - 给定树的边。</p><h3 id="代码-4">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br>ll n;<br>ll cnt[<span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> vis[MAX];<br>vector&lt;ll&gt; sons[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">count</span><span class="hljs-params">(ll node,ll type)</span></span>&#123;<br>cnt[type]++;<br>vis[node] = <span class="hljs-literal">true</span>;<br>ll next = type ? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : sons[node])&#123;<br><span class="hljs-keyword">if</span>(!vis[it]) <span class="hljs-built_in">count</span>(it,next);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br>ll x,y;cin&gt;&gt;x&gt;&gt;y;<br>sons[x].<span class="hljs-built_in">push_back</span>(y);<br>sons[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>cout&lt;&lt;cnt[<span class="hljs-number">0</span>]*cnt[<span class="hljs-number">1</span>] - (n<span class="hljs-number">-1</span>)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CAIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAICOM-CAIP-2021-省赛题解</title>
    <link href="/competition/RAICOM-CAIP/2021-%E7%9C%81%E8%B5%9B/"/>
    <url>/competition/RAICOM-CAIP/2021-%E7%9C%81%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="懂的都懂dfs">1：懂的都懂（DFS）</h1><figure><img src="/competition/RAICOM-CAIP/2021-%E7%9C%81%E8%B5%9B/adc22dc9-7cd0-417c-9274-3d0678474c6e.jpg" alt="b3ceb051352ac65c29767cc3ecf2b21192138add.jpg"><figcaption aria-hidden="true">b3ceb051352ac65c29767cc3ecf2b21192138add.jpg</figcaption></figure><p>众所周知，在互联网上有很多话是不好直接说出来的，不过一些模糊的图片仍然能让网友看懂你在说什么。然而对这种言论依然一定要出重拳，所以请你实现一个简单的匹配算法。</p><p>现在我们采集了原图的一些特征数据，由 <em>N</em> 个小于 255的非负整数组成，假设对于给定的若干张由 *M**i* 个同样小于 255的非负整数组成的新图的特征数据，每个数据都可以由原图中任意四个不同数据的平均值计算而来，则称新图为原图的相似图片。对于给出的数据，请你判断是不是相似图片。</p><p>注意，不同数据指的并非是数据的值不同，而是不能取同一个数据多次。对于两个相同值的数据，如果给出两次，则可以取两次。</p><h3 id="输入格式">输入格式</h3><p>输入第一行是两个整数 <em>N</em>,<em>K</em> (1 ≤ <em>N</em> ≤ 50, 1 ≤<em>K</em> ≤ 200)，表示采集的原图的特征数据个数和新图的张数。接下来一行为 <em>N</em> 个小于 255 的非负整数，表示原图的特征数据。最后的 <em>K</em> 行，每行第一个数是 <em>Mi</em> (1 ≤ <em>Mi</em> ≤200)，表示新图的特征数据个数。然后是 <em>Mi</em> 个小于 255的非负整数，表示新图的特征数据。</p><h3 id="输出格式">输出格式</h3><p>对于每一张新图，如果为相似图片，则在一行中输出 Yes，否则输出 No。</p><h3 id="输入样例">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs in">5 3<br>4 8 12 20 40<br>3 11 16 19<br>3 12 16 19<br>10 11 11 11 11 11 11 11 11 11 11<br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">Yes<br>No<br>Yes<br></code></pre></td></tr></table></figure><h3 id="解法">解法</h3><p>使用DFS枚举每一种可能平均数，使用set去重并存储。（也可以用四重循环枚举）</p><p>最后，对每次输入的值进行判断。</p><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e4</span>;<br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[MAX];<br>set&lt;<span class="hljs-type">int</span> &gt; st;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getSet</span><span class="hljs-params">(<span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> dep, <span class="hljs-type">int</span> cnt)</span></span>&#123;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">4</span>)&#123;<br>st.<span class="hljs-built_in">insert</span>(sum);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(dep == n || cnt &gt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">getSet</span>(sum + a[dep],dep<span class="hljs-number">+1</span>,cnt<span class="hljs-number">+1</span>);<br><span class="hljs-built_in">getSet</span>(sum,dep<span class="hljs-number">+1</span>,cnt);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-built_in">getSet</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">while</span>(k--)&#123;<br><span class="hljs-type">int</span> m;cin&gt;&gt;m;<br>string ans = <span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> tep;cin&gt;&gt;tep;<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(tep*<span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) ans = <span class="hljs-string">&quot;No&quot;</span>; <br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="芬兰木棋几何">2：芬兰木棋（几何）</h1><figure><img src="/competition/RAICOM-CAIP/2021-%E7%9C%81%E8%B5%9B/62b483d4-0b40-41bd-a8b1-be4a0aeae56a.png" alt="WX20200212-152528.png"><figcaption aria-hidden="true">WX20200212-152528.png</figcaption></figure><p>芬兰木棋（Mölkky，又称芬兰木柱）是源自芬兰的一项运动。哲哲将这个运动改造成了赛博朋克单人版，现在场上一开始有<em>N</em>根立起的小木棋（上面分别标有一个非负整数），哲哲投掷一根大木棋去击倒这些小木棋以获得分数。分数规则如下：</p><ul><li>如果仅击倒 1 根木棋，则得木棋上的分数。</li><li>如果击倒 2 根或以上的木棋，则只得击倒根数的分数。（例如击倒 5根，则得 5 分。）</li></ul><p>哲哲固定站在 (0,0) 点上，四周放着若干个小木棋(<em>X<strong>i<em>,</em>Y</strong>i</em>)，坐标均为整数。每次哲哲可以朝一个方向扔出大木棋，大木棋会打倒这个方向上离哲哲最近的<em>k</em> 个小木棋。哲哲游戏水平很高超，所以这个 <em>k</em>可以自由控制。</p><p>请问哲哲最多能拿多少分，在获得最多分数的情况下最少需要扔出多少次大木棋？</p><p><em>规则与真实规则有较大出入，真实游玩时请以国际莫尔基组织的规则为准</em></p><h3 id="输入格式-1">输入格式</h3><p>输入第一行是一个正整数 <em>N</em> (1 ≤ <em>N</em> ≤105)，表示场上一开始有 <em>N</em> 个木棋。</p><p>接下来 <em>N</em> 行，每行 3 个整数<em>X<strong>i<em>,</em>Y</strong>i</em>,<em>P<strong>i<em>，分别表示木棋放置在(</em>X</strong>i</em>,<em>Y<strong>i<em>)，木棋上的分数是</em>P</strong>i</em>。坐标在 32 位整数范围内，分数为小于等于 1000的正整数。</p><p>保证 (0,0) 点没有木棋，也没有木棋重叠放置。</p><h3 id="输出格式-1">输出格式</h3><p>输出一行两个数，表示最多分数以及获得最多分数最少需要投掷大木棋多少次。</p><h3 id="输入样例-1">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs in">11<br>1 2 2<br>2 4 3<br>3 6 4<br>-1 2 2<br>-2 4 3<br>-3 6 4<br>-1 -2 1<br>-2 -4 1<br>-3 -6 1<br>-4 -8 2<br>2 -1 999<br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">1022 9<br></code></pre></td></tr></table></figure><h3 id="解法-1">解法</h3><p>对于每个点，用结构体存储信息。</p><p>计算（0，0）- （a,b）的斜率k，使用map&lt;double,a&gt;映射到某个集合上。</p><p>每个集合代表一条直线。</p><p>对同一条直线上的每个点，进行遍历计算：</p><p>对于1的序列，一次全部打倒最优；对于其他数字，逐个击倒最优。</p><h3 id="代码-1">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-type">int</span> n,idx,sum,cnt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br><span class="hljs-type">int</span> x,y,w;<br><br><span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x_,<span class="hljs-type">int</span> y_,<span class="hljs-type">int</span> w_)&#123;<br>x = x_;<br>y = y_;<br>w = w_;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point &amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(x != rhs.x) <span class="hljs-keyword">return</span> x &lt; rhs.x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> y &lt; rhs.y;<br>&#125;<br>&#125;;<br><br>vector&lt;Point&gt; v[MAX];<br>unordered_map&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span> &gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br>idx = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)&#123;<br>v[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Point</span>(x,y,w));<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-type">double</span> k = (<span class="hljs-number">1.0</span>*y)/x;<br><span class="hljs-keyword">if</span>(!mp[k]) mp[k] = idx++;<br>v[mp[k]].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Point</span>(x,y,w));<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; idx ; i ++)&#123;<br><span class="hljs-built_in">sort</span>(v[i].<span class="hljs-built_in">begin</span>(),v[i].<span class="hljs-built_in">end</span>());<br><span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(Point it : v[i])&#123;<br>sum += it.w;<br><span class="hljs-keyword">if</span>(it.w == last &amp;&amp; it.w == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span> cnt++;<br>last = it.w;<br>&#125;<br>&#125;<br>cout&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="打怪升级floyddijkstra">3：打怪升级（Floyd+Dijkstra）</h1><figure><img src="/competition/RAICOM-CAIP/2021-%E7%9C%81%E8%B5%9B/f21ac592-3c21-4205-aa10-cb39d706afb4.jpeg" alt="dgsj.JPG"><figcaption aria-hidden="true">dgsj.JPG</figcaption></figure><p>很多游戏都有打怪升级的环节，玩家需要打败一系列怪兽去赢取成就和徽章。这里我们考虑一种简单的打怪升级游戏，游戏规则是，给定有<em>N</em>个堡垒的地图，堡垒之间有道路相连，每条道路上有一只怪兽把守。怪兽本身有能量，手里的武器有价值。打败怪兽需要的能量等于怪兽本身的能量，而怪兽一旦被打败，武器就归玩家所有—— 当然缴获的武器价值越高，玩家就越开心。</p><p>你的任务有两件：</p><ul><li><ol type="1"><li>帮助玩家确定一个最合算的空降位置，即空降到地图中的某个堡垒，使得玩家从这个空降点出发，到攻下最难攻克（即耗费能量最多）的那个堡垒所需要的能量最小；</li></ol></li><li><ol type="1"><li>从这个空降点出发，帮助玩家找到攻克任意一个其想要攻克的堡垒的最省能量的路径。如果这种路径不唯一，则选择沿途缴获武器总价值最高的解，题目保证这种解是唯一的。</li></ol></li></ul><h3 id="输入格式-2">输入格式</h3><p>输入第一行给出两个正整数 <em>N</em> (≤1000) 和 <em>M</em>，其中<em>N</em> 是堡垒总数，<em>M</em> 是怪兽总数。为简单起见，我们将堡垒从 1到 <em>N</em> 编号。随后 <em>M</em> 行，第 <em>i</em> 行给出了第<em>i</em> 只怪兽的信息，格式如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">B1 </span><span class="hljs-keyword">B2 </span>怪兽能量 武器价值<br></code></pre></td></tr></table></figure><p>其中 <code>B1</code> 和 <code>B2</code>是怪兽把守的道路两端的堡垒编号。题目保证每对堡垒之间只有一只怪兽把守，并且<code>怪兽能量</code> 和 <code>武器价值</code> 都是不超过 100的正整数。</p><p>再后面是一个正整数 <em>K</em>（≤<em>N</em>）和玩家想要攻克的<em>K</em> 个目标堡垒的编号。</p><h3 id="输出格式-2">输出格式</h3><p>首先在一行中输出玩空降的堡垒编号<code>B0</code>。如果有多种可能，则输出编号最小的那个。</p><p>随后依次为玩家想要攻克的每个堡垒 <code>B</code>推荐最省能量的攻克路径，并列出需要耗费的能量值和沿途缴获武器的总价值。注意如果最省力的路径不唯一，则选择沿途缴获武器总价值最高的解。格式为：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">B0-&gt;途经堡垒<span class="hljs-number">1</span>-&gt;...-&gt;B<br>总耗费能量 武器总价值<br></code></pre></td></tr></table></figure><h3 id="输入样例-2">输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs in">6 12<br>1 2 10 5<br>2 3 16 20<br>3 1 4 2<br>2 4 20 22<br>4 5 2 2<br>5 3 12 6<br>4 6 8 5<br>6 5 10 5<br>6 1 20 25<br>1 5 8 5<br>2 5 2 1<br>2 6 8 5<br>4<br>2 3 6 5<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs out">5<br>5-&gt;2<br>2 1<br>5-&gt;1-&gt;3<br>12 7<br>5-&gt;4-&gt;6<br>10 7<br>5<br>0 0<br></code></pre></td></tr></table></figure><h3 id="解法-2">解法</h3><p>使用Floyd找到起点，根据该起点，使用双权值的Dijkstra求"最短路"，并记录路径。</p><h3 id="代码-2">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">50</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> d;<br><span class="hljs-type">int</span> w;<br><br><span class="hljs-built_in">Edge</span>()&#123;<br>d = INF;<br>w = -INF;<br>&#125;<br><span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> d_,<span class="hljs-type">int</span> w_)&#123;<br>d = d_;<br>w = w_;<br>&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> n,m,k,s;<br>Edge edge[MAX][MAX];<br><span class="hljs-type">int</span> dist[MAX],val[MAX],path[MAX];<br><span class="hljs-type">int</span> flEdge[MAX][MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>flEdge[i][j] = edge[i][j].d;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">1</span> ; t &lt;= n ; t ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(flEdge[i][t] == INF) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>flEdge[i][j] = <span class="hljs-built_in">min</span>(flEdge[i][j],flEdge[i][t] + flEdge[t][j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> max_ = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(j != i) max_ = <span class="hljs-built_in">max</span>(max_,flEdge[i][j]);<br>&#125;<br><span class="hljs-keyword">if</span>(max_ &lt; min_)&#123;<br>min_ = max_;<br>res = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>dist[i] = edge[s][i].d;<br>val[i] = edge[s][i].w;<br>path[i] = s;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ;i ++)&#123;<br><span class="hljs-type">int</span> now = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>now = j;<br>&#125; <br>&#125;<br>visited[now] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &gt; dist[now] + edge[now][j].d)&#123;<br>dist[j] = dist[now] + edge[now][j].d;<br>val[j] = val[now] + edge[now][j].w;<br>path[j] = now;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] == dist[now] + edge[now][j].d &amp;&amp; val[j] &lt; val[now] + edge[now][j].w)&#123;<br>dist[j] = dist[now] + edge[now][j].d;<br>val[j] = val[now] + edge[now][j].w;<br>path[j] = now;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> x,y,d,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;d&gt;&gt;w;<br>edge[x][y] = <span class="hljs-built_in">Edge</span>(d,w);<br>edge[y][x] = <span class="hljs-built_in">Edge</span>(d,w);<br>&#125;<br>s = <span class="hljs-built_in">floyd</span>();<br>cout&lt;&lt;s&lt;&lt;endl;<br><span class="hljs-built_in">dijkstra</span>();<br>cin&gt;&gt;k;<br><span class="hljs-keyword">while</span>(k--)&#123;<br><span class="hljs-type">int</span> to;cin&gt;&gt;to;<br><span class="hljs-type">int</span> tep = to;<br>stack&lt;<span class="hljs-type">int</span> &gt; st;<br><span class="hljs-keyword">while</span>(tep != s)&#123;<br>st.<span class="hljs-built_in">push</span>(tep);<br>tep = path[tep];<br>&#125;st.<span class="hljs-built_in">push</span>(s);<br><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;st.<span class="hljs-built_in">top</span>();<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>() != to) cout&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;cout&lt;&lt;endl;<br><span class="hljs-type">int</span> res1 = dist[to] == INF?<span class="hljs-number">0</span>:dist[to];<br><span class="hljs-type">int</span> res2 = val[to] == -INF?<span class="hljs-number">0</span>:val[to];<br>cout&lt;&lt;res1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;res2&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="疫情防控并查集">4：疫情防控（并查集）</h1><p>疫情尚未结束，严防疫情反复。为了做好疫情防控工作，国内设置了地区风险等级，对于中高风险地区的人员采取限制移动、居家隔离等手段。</p><p>为了研究疫情防控对于跨地区交通运输的影响，假设现在有 <em>N</em>个机场，<em>M</em>条航线，每天都会新增一个防控地区，一个防控地区会导致一个机场无法正常运作，航线也自然无法正常运行，每天会有*Q**i* 对旅客从 *X**i* 机场前往 *Y**i*机场，请计算有多少对旅客会受到影响无法完成行程。</p><p>旅客只要能直达或通过若干次中转，且乘坐的所有航线的出发和到达机场都正常运作，即视作可完成行程。</p><h3 id="输入格式-3">输入格式</h3><p>输入第一行是三个整数 <em>N</em>,<em>M</em>,<em>D</em>(1≤<em>N</em>≤5×104, 1≤<em>M</em>≤2×105, 1≤<em>D</em>≤103),表示机场数、航线数以及新增防控地区的天数。</p><p>接下来首先有 <em>M</em> 行，每行给出空格分隔的两个数字 <em>A</em> 和<em>B</em>，表示编号为 <em>A</em> 和 <em>B</em>的机场之间有一条航线。航线是双向的，机场编号从 1 到 <em>N</em>。</p><p>然后是 <em>D</em> 块输入，每块输入内第一行为空格分隔的两个整数<em>C</em> 和 <em>Q</em> （1≤<em>Q</em>≤103)，表示新增机场编号为<em>C</em> 所在的城市为防控地区，今天有 <em>Q</em>段行程。数据保证新增的城市之前一定不是防控地区。</p><p>接下来的 <em>Q</em> 行，每行是空格分隔的两个数字 <em>X</em> 和<em>Y</em>，表示编号为 <em>X</em> 和 <em>Y</em>的机场的一段行程。行程有可能包括之前就已经成为防控地区的城市。</p><h3 id="输出格式-3">输出格式</h3><p>对于每天的询问，请在一行中输出在新增了一个防控地区后当天的行程有多少不能成行。</p><h3 id="输入样例-3">输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs in">5 5 3<br>1 2<br>1 3<br>1 5<br>2 5<br>3 4<br>4 3<br>1 3<br>1 4<br>2 3<br>5 3<br>3 4<br>2 3<br>3 5<br>1 3<br>2 3<br>2 5<br>3 4<br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">1<br>2<br>3<br></code></pre></td></tr></table></figure><h3 id="解法-3">解法</h3><p>本质是：需要多次判断两点是否连通，在这个过程中，逐步从图中删除点，维护连通性。</p><p>考虑使用并查集，并查集在查找过程中会优化路径，进行删除操作后无法保证图联通的正确性。</p><p>但是，加入新边的操作能够保证连通性正确。</p><p>因此，可以在创建图时只保留始终未被删除的点，并将每次的操作存储。</p><p>从后往前遍历每次操作，查询连通性并统计，并不断恢复被删除的点。</p><h3 id="代码-3">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">5e4</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> n,m,d;<br><span class="hljs-type">int</span> pre[MAX],back[MAX];<br><span class="hljs-type">bool</span> deleted[MAX];<br>stack&lt;<span class="hljs-type">int</span> &gt; ans;<br>vector&lt;<span class="hljs-type">int</span> &gt; e[MAX];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; querys[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initSet</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>pre[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(pre[x] == x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x);<br><span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(fx != fy) pre[fx] = fy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;<br><span class="hljs-built_in">initSet</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;<br>e[x].<span class="hljs-built_in">push_back</span>(y);<br>e[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; d ; i ++)&#123;<br><span class="hljs-type">int</span> cnt;<br>cin&gt;&gt;back[i]&gt;&gt;cnt;<br>deleted[back[i]] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(cnt--)&#123;<br><span class="hljs-type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;<br>querys[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(a,b));<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(deleted[i]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> to : e[i])&#123;<br><span class="hljs-keyword">if</span>(deleted[to]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">Union</span>(i,to);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = d<span class="hljs-number">-1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; q : querys[i])&#123;<br><span class="hljs-type">int</span> x = q.first;<br><span class="hljs-type">int</span> y = q.second;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x) != <span class="hljs-built_in">find</span>(y)) res++;<br>&#125;<br>ans.<span class="hljs-built_in">push</span>(res);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> to : e[back[i]])&#123;<br><span class="hljs-keyword">if</span>(deleted[to]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">Union</span>(back[i],to);<br>&#125;<br>deleted[back[i]] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">while</span>(!ans.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;ans.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>ans.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CAIP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS-BFS</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/DFS-BFS/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/DFS-BFS/</url>
    
    <content type="html"><![CDATA[<h1 id="dfs模板">DFS模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    visited[x] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//do something</span><br>    <span class="hljs-keyword">for</span>(...)&#123;<br>        <span class="hljs-comment">//judge next node</span><br>        <span class="hljs-keyword">if</span>(!visited[nx] &amp;&amp; ...)&#123;<br>            <span class="hljs-built_in">dfs</span>(nx);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bfs模板">BFS模板</h1><p>写法1：由于在插入队列时，没有标记visited，导致queue中出现重复点，但是可被continue过滤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(visited[f]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// must write</span><br>        visited[f] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// do something</span><br>        <span class="hljs-keyword">for</span>(...)&#123;<br>            <span class="hljs-comment">// judge next node</span><br>            <span class="hljs-keyword">if</span>(!visited[f] &amp;&amp; ...)&#123;<br>                q.<span class="hljs-built_in">push</span>(nx)  <br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>写法2：在输入时就标记新点，queue中无重复点，这种写法更好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    visited[s] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// must write</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//do something</span><br>        <br>        <span class="hljs-keyword">for</span>(...)&#123;<br>            <span class="hljs-comment">//judge next node</span><br>            <span class="hljs-keyword">if</span>(!visited[nx] &amp;&amp; ...)&#123;<br>                visited[nx] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(nx);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCD-LCM</title>
    <link href="/algorithm/%E6%95%B0%E8%AE%BA/GCD-LCM/"/>
    <url>/algorithm/%E6%95%B0%E8%AE%BA/GCD-LCM/</url>
    
    <content type="html"><![CDATA[<h1 id="gcd-最大公约数">GCD-最大公约数</h1><p>辗转相除法：两个数的最大公约数等于其中较小的数字和二者之间余数的最大公约数</p><p>假设有两个数字[12921，4234]。将两数中较大的那一个看作是被除数A，将较小的那一个看作是除数B二者相除的商记作C，余数记作D。这样我们就可以得到一个等式：</p><p>​ A = B×C + D</p><p>而辗转相除法的所要用到的原理则是：(A , B) = (B , D)</p><p>(12921,4234) -&gt; (4234,219) -&gt; (219,73) -&gt; (73,0)</p><p>当较小的那个数为0时，较大的那个数就是最大公约数</p><p>c++函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//适当的时候，int换成ll</span><br><span class="hljs-keyword">if</span> (x &lt; y)<br><span class="hljs-built_in">swap</span>(x,y); <span class="hljs-comment">//确保x大于y</span><br><span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> x; <span class="hljs-comment">//y == 0时，返回x</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(y,x%y); <span class="hljs-comment">//y ！= 0，继续运算</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">return</span> y == <span class="hljs-number">0</span> ? x : <span class="hljs-built_in">gcd</span>(y, x%y);<br>&#125;<br></code></pre></td></tr></table></figure><p>库函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> __gcd(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="lcm-最小公倍数">LCM-最小公倍数</h1><p>若要求最小公倍数，只需要将两数的乘积除以最大公约数就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;  <span class="hljs-comment">//两个数的最小公倍数等于乘积/最大公约数</span><br><span class="hljs-keyword">return</span> (x*y)/<span class="hljs-built_in">gcd</span>(x,y); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛通用技巧</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/OI%E9%80%9A%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/OI%E9%80%9A%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="inf">1.INF</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-comment">//或者</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br></code></pre></td></tr></table></figure><p>INF这个常量表示最大值</p><p>通常令INF = 0x3f3f3f3f</p><p>相比于INT_MAX，这个值有3个好处：</p><ol type="1"><li>0x3f3f3f3f的十进制是1061109567，也就是10<sup>9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10</sup>9的，所以它==可以作为无穷大使用而不致出现数据大于无穷大的情形。==</li><li>另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bitint的表示范围，所以0x3f3f3f3f还==满足了我们“无穷大加无穷大还是无穷大”的需求==。</li><li>最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以==要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))==。</li></ol><h1 id="llull">2.LL/ULL</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br></code></pre></td></tr></table></figure><h1 id="debug函数">3.debug函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="hljs-string">&quot; == &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br></code></pre></td></tr></table></figure><h1 id="cincout加速">4.cin/cout加速</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>)<br><span class="hljs-comment">//这个函数是一个“是否兼容stdio”的开关，C++为了兼容C，保证程序在使用了std::printf和std::cout的时候不发生混乱，将输出流绑到了一起。</span><br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//解除cin与cout的绑定</span><br>cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-comment">//效率比cout&lt;&lt;endl更高</span><br></code></pre></td></tr></table></figure><p>cin cout 和 scanf printf：</p><p>==做题的时候尽量使用scanf printf==，因为cin cout 比 scanfprintf慢20倍左右！</p><p>一旦遇到大数据量，光是读入就有可能跪掉。</p><p>可以使用std::ios::sync_with_stdio(false)这条语句关掉scanf 和cin的同步加快效率。</p><p>但==cin 仍然慢 5倍左右==，而且一旦使用了这条语句，scanf和cin混用可能就会造成一些奇怪的问题。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其他算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和、差分</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>对于一个普通的数组而言，求区间和效率----O(n)；区间修改效率----O(n)；单点修改效率----O(1)</p><p>为了更方便地进行区间操作，我们需要构造前后缀数组。</p><h1 id="前缀和">前缀和</h1><p>前缀和指的是用使用一个数组表示另一个数组1-i下标的和。</p><p>例如：int arr[n]，Prefix[i] 表示 1-i 的arr[i]的和</p><p>前缀和数组：求区间和效率----O(1)；区间修改效率----O(n)；单点修改效率----O(n)</p><ul><li>前缀和数组的思想也可以拓展到求 数组 1-i 下标的最大值/最小值</li><li>求后缀数组和求前缀数组是相同操作</li></ul><h2 id="例题1最大数组和">例题1：最大数组和</h2><p><a href="https://www.lanqiao.cn/problems/3260/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=最大数组和">1.最大数组和- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br>ll t,n,k;<br>ll a[MAX];<br>ll leftsum[MAX],rightsum[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-built_in">memset</span>(leftsum,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(leftsum));<br><span class="hljs-built_in">memset</span>(rightsum,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(rightsum));<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br>ll total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>total += a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a+n<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>leftsum[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span> leftsum[i] = leftsum[i<span class="hljs-number">-1</span>] + a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>(i == n)&#123;<br>rightsum[i] = a[i];<br>&#125;<br><span class="hljs-keyword">else</span> rightsum[i] = rightsum[i<span class="hljs-number">+1</span>] + a[i];<br>&#125;<br>ll ans = LONG_LONG_MIN;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= k ; i ++)&#123;<br><span class="hljs-type">int</span> j = k - i;<br>ans = <span class="hljs-built_in">max</span>(ans,total - leftsum[<span class="hljs-number">2</span>*i] - rightsum[n<span class="hljs-number">+1</span>-j]);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题2大石头的搬运工">例题2：大石头的搬运工</h2><p><a href="https://www.lanqiao.cn/problems/3829/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=大石头的搬运工">1.大石头的搬运工- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n;<br>ll Left[MAX];<br>ll Right[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">rock</span>&#123;<br><span class="hljs-type">int</span> w;<br><span class="hljs-type">int</span> p;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> rock &amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(w != rhs.w) <span class="hljs-keyword">return</span> p &lt; rhs.p;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> w &lt; rhs.w;<br>&#125;<br>&#125;r[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make_prefix</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ll s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) Left[i] = Left[i<span class="hljs-number">-1</span>] + s*(r[i].p - r[i<span class="hljs-number">-1</span>].p);<br>s += r[i].w;<br>&#125;<br>s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span> ; i &gt;= <span class="hljs-number">0</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>(i &lt; n<span class="hljs-number">-1</span>) Right[i] = Right[i<span class="hljs-number">+1</span>] + s*(r[i<span class="hljs-number">+1</span>].p - r[i].p);<br>s += r[i].w;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;<br>r[i].w = x;<br>r[i].p = y;<br>&#125;<br><span class="hljs-built_in">sort</span>(r,r+n);<br><span class="hljs-built_in">make_prefix</span>();<br>ll min_ = LONG_LONG_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>min_ = <span class="hljs-built_in">min</span>(min_,Left[i]+Right[i]);<br>&#125;<br>cout&lt;&lt;min_;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题3四元组问题">例题3：四元组问题</h2><p>----单调栈+前缀和</p><p>----单调栈可以用来求1-i的 最大 和 次大</p><p><a href="https://www.lanqiao.cn/problems/3416/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=四元组问题">1.四元组问题- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[MAX],min_[MAX];<br>stack&lt;<span class="hljs-type">int</span> &gt; st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>min_[n<span class="hljs-number">-1</span>] = a[n<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ; i &gt;= <span class="hljs-number">0</span> ; i --)&#123;<br>min_[i] = (min_[i<span class="hljs-number">+1</span>],a[i]);<br>&#125;<br><span class="hljs-type">int</span> A = <span class="hljs-number">-999</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-comment">//判断是否符合最终条件</span><br><span class="hljs-keyword">if</span>(A &gt; a[i] &amp;&amp; a[i] &gt; min_[i<span class="hljs-number">+1</span>])&#123; <span class="hljs-comment">// A &gt; C &gt; D ,利用后缀最小值,求出三等于关系</span><br>cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//对A和B值的更新</span><br>        <span class="hljs-comment">//如果出现一个新的最大值，上次的最大值就会被弹出并保存，也就是次大</span><br>        <span class="hljs-comment">//但这里a[i]不是B的值，我们并不记录B的值，因为后续比较A、C、D无需使用</span><br><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &lt; a[i])&#123; <span class="hljs-comment">// B &gt; A ,利用单调栈求出最大和次大</span><br>A = <span class="hljs-built_in">max</span>(st.<span class="hljs-built_in">top</span>(),A);<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br>st.<span class="hljs-built_in">push</span>(a[i]);<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="差分">差分</h1><p>差分数组就是用一个数组表示另一个数据的相邻差，以便进行区间修改操作。</p><p>差分数组的 前缀和 就是 原数组。</p><p>在需要恢复原数组时，需要求差分数组求前缀和。</p><p>前缀和数组：</p><p>1）求区间和效率----O(2*n)</p><p>2）区间修改效率----O(1)</p><p>3）单点修改效率----O(n)</p><h2 id="例题1肖恩的投球游戏">例题1：肖恩的投球游戏</h2><p><a href="https://www.lanqiao.cn/problems/3693/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=肖恩的投球">2.肖恩的投球游戏- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br>ll diff[MAX];<br>ll arr[MAX];<br>ll n,q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123; <span class="hljs-comment">//从1开始，arr[0] == 0</span><br>cin&gt;&gt;arr[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<span class="hljs-comment">//生成差分数组</span><br>diff[i] = arr[i] - arr[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">while</span>(q--)&#123;  <span class="hljs-comment">//区间修改</span><br>ll l,r,m;cin&gt;&gt;l&gt;&gt;r&gt;&gt;m;<br>diff[l] += m;<br>diff[r<span class="hljs-number">+1</span>] -= m;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123; <span class="hljs-comment">//数组还原</span><br>diff[i] += diff[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;diff[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题2泡澡">例题2：泡澡</h2><p><a href="https://www.lanqiao.cn/problems/3898/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=泡澡">1.泡澡- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2</span>*(<span class="hljs-number">1e5</span>) + <span class="hljs-number">10</span>;<br>ll arr[MAX];<br>ll diff[MAX];<br>ll n,max_water,rside,lside;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;max_water;<br><span class="hljs-built_in">memset</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(arr));<br><span class="hljs-keyword">while</span>(n--)&#123;<br>ll l,r,w;<br>cin&gt;&gt;l&gt;&gt;r&gt;&gt;w;<br>        <span class="hljs-comment">//注意：本题的区间是[l，r)</span><br>diff[l] += w;<br>diff[r] -= w; <br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= N ; i ++)&#123;<br>diff[i] += diff[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//恢复原数组</span><br><span class="hljs-keyword">if</span>(diff[i] &gt; max_water)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维差分">二维差分</h1><p>主要用来进行二维数组的正方形区间修改操作，可优化时间复杂度为O(1)</p><p>二维差分数组的定义是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">diff[i][j] = arr[i][j] - arr[i<span class="hljs-number">-1</span>][j] - arr[i][j<span class="hljs-number">-1</span>] + arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//主对角线两点 - 副对角线两点</span><br></code></pre></td></tr></table></figure><p>二维前缀和数组的定义是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">sum[i][j] = sum[i<span class="hljs-number">-1</span>][j] + sum[i][j<span class="hljs-number">-1</span>] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + sum[i][j];<br><span class="hljs-comment">//借此用差分数组恢复原数组</span><br>diff[i][j] = diff[i<span class="hljs-number">-1</span>][j] + diff[i][j<span class="hljs-number">-1</span>] - diff[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + diff[i][j];<br></code></pre></td></tr></table></figure><h2 id="例题1地毯">例题1：地毯</h2><p><a href="https://www.luogu.com.cn/problem/P3397">P3397 地毯 - 洛谷 |计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br>ll arr[MAX][MAX];<br>ll diff[MAX][MAX];<br>ll n,t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(arr));<br><span class="hljs-built_in">memset</span>(diff,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(diff));<br>cin&gt;&gt;n&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br>ll x1,x2,y1,y2;<br>cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        <span class="hljs-comment">//主对角线两点++</span><br>diff[x1][y1] ++;<br>diff[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>] ++;<br><span class="hljs-comment">//副对角线两点--</span><br>        diff[x2<span class="hljs-number">+1</span>][y1] --;<br>diff[x1][y2<span class="hljs-number">+1</span>] --;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>            <span class="hljs-comment">//数组还原公式</span><br>arr[i][j] = arr[i<span class="hljs-number">-1</span>][j] + arr[i][j<span class="hljs-number">-1</span>] - arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + diff[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>cout&lt;&lt;arr[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题2肖恩的投球游戏加强版">例题2：肖恩的投球游戏（加强版）</h2><p><a href="https://www.lanqiao.cn/problems/3694/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=肖恩的投球">竞赛中心- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">10</span>;<br><br>ll diff[MAX][MAX];<br>ll arr[MAX][MAX];<br>ll n,m,t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>cin&gt;&gt;arr[i][j];<br>&#125;<br>&#125; <span class="hljs-comment">//输入原数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>diff[i][j] = arr[i][j] - arr[i<span class="hljs-number">-1</span>][j] - arr[i][j<span class="hljs-number">-1</span>] + arr[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125; <span class="hljs-comment">//构造二维差分数组</span><br><span class="hljs-keyword">while</span>(t--)&#123; <span class="hljs-comment">//区域增减操作</span><br>ll x1,y1,x2,y2,v;<br>cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;v;<br>diff[x1][y1] += v;<br>diff[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>] += v;<br>diff[x1][y2<span class="hljs-number">+1</span>] -= v;<br>diff[x2<span class="hljs-number">+1</span>][y1] -= v;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123; <span class="hljs-comment">//二维差分求前缀和，得到修改后的数组</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>diff[i][j] = diff[i<span class="hljs-number">-1</span>][j] + diff[i][j<span class="hljs-number">-1</span>] - diff[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + diff[i][j];<br>cout&lt;&lt;diff[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其他算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短编辑距离</title>
    <link href="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="最短编辑距离levenshtein-distance">最短编辑距离：LevenshteinDistance</h1><h1 id="ld模板">1-LD模板</h1><p><a href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离 -洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h2 id="题目描述">题目描述</h2><p>设 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>是两个字符串。我们要用最少的字符操作次数，将字符串 <span class="math inline">\(A\)</span> 转换为字符串 <span class="math inline">\(B\)</span>。这里所说的字符操作共有三种：</p><ol type="1"><li>删除一个字符；</li><li>插入一个字符；</li><li>将一个字符改为另一个字符。</li></ol><p><span class="math inline">\(A, B\)</span> 均只包含小写字母。</p><h2 id="输入格式">输入格式</h2><p>第一行为字符串 <span class="math inline">\(A\)</span>；第二行为字符串<span class="math inline">\(B\)</span>；字符串 <span class="math inline">\(A, B\)</span> 的长度均小于 <span class="math inline">\(2000\)</span>。</p><h2 id="输出格式">输出格式</h2><p>只有一个正整数，为最少字符操作次数。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sfdqxbw</span><br><span class="hljs-attribute">gfdgw</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>对于 <span class="math inline">\(100 \%\)</span> 的数据，<span class="math inline">\(1 \le |A|, |B| \le 2000\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">2050</span>;<br><br><span class="hljs-type">int</span> dp[MAX][MAX];<br>string s1,s2;<br><span class="hljs-type">int</span> l1,l2;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s1&gt;&gt;s2;<br>l1 = s<span class="hljs-number">1.l</span>ength();<br>l2 = s<span class="hljs-number">2.l</span>ength();<br>s1 = <span class="hljs-string">&quot; &quot;</span> + s1;<br>s2 = <span class="hljs-string">&quot; &quot;</span> + s2;<br>    <span class="hljs-comment">//初始化边界</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l1 ; i ++)&#123;<br>dp[i][<span class="hljs-number">0</span>] = i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l2; i ++)&#123;<br>dp[<span class="hljs-number">0</span>][i] = i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l1 ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= l2 ; j ++)&#123;<br><span class="hljs-keyword">if</span>(s1[i] == s2[j])&#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//跳过</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>, dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//插入，删除</span><br>dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//修改</span><br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ld路径回溯">2-LD+路径回溯</h1><h2 id="caip-2022-rc-u4-变牛的最快方法">CAIP 2022 RC-u4变牛的最快方法</h2><p><img src="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/3b6f7584-a4ba-4d73-a4f5-49b956dd3604.png" alt="shu.png"> <img src="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/9d18450d-de04-4437-9da4-22f633b8f806.png" alt="niu.png"></p><p>这里问的是把任意一种动物的图像变成牛的方法……比如把一只鼠的图像变换成牛的图像。方法如下：</p><ul><li>首先把屏幕上的像素点进行编号；</li><li>然后把两只动物的外轮廓像素点编号按顺时针记录下来；</li><li>用最少的变换次数将鼠的轮廓变成牛的 —— 这里仅允许对鼠的轮廓进行 3钟操作：</li></ul><ol type="1"><li>插入一个像素编号</li><li>删除一个像素编号</li><li>更改一个像素编号</li></ol><h2 id="输入格式-1">输入格式</h2><p>输入分别在两行中给出两种动物的轮廓像素点编号，编号为 (0,106]区间内的整数，允许重复。轮廓以编号 −1结尾，这个编号不算在轮廓内。题目保证每种动物的轮廓包含不超过 1000个像素点。</p><h2 id="输出格式-1">输出格式</h2><p>在第一行中输出从第一只动物变换成第二只动物需要的最少变换次数。</p><p>在第二行中顺次描述对第一只动物轮廓的每个像素所作的操作：</p><ul><li>如果这个像素被删除，则在对应位置输出 0</li><li>如果这个像素被改变，则在对应位置输出 1</li><li>如果这个像素不变，则在对应位置输出 2</li><li>如果这个像素前面或者后面插入了一个像素，则在插入的位置输出 3</li></ul><p>答案可能不唯一，输出任何一种可能的解都可以。行首尾和数字间均无空格。</p><h2 id="输入样例">输入样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">13 5 6 20 2 20 1 13 9 20 3 28 3 34 6 25 233 -1<br>3 5 6 20 6 20 3 5 9 3 9 20 3 6 6 25 233 -1<br></code></pre></td></tr></table></figure><h2 id="输出样例">输出样例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">8<br>122212112023121222<br></code></pre></td></tr></table></figure><h2 id="样例解释">样例解释</h2><p>1、13 更改为 3，随后 5、6、20 不变 2、2 更改为 6，下一个 20 不变 3、1更改为 3 4、第二个 13 更改为 5，随后 9 不变 5、删除下一个 20，后面的 3不变 6、在 28 的前面插入 9 7、28 更改为 20，后面的 3 不变 8、34 更改为6，后面的 6、25、233 不变</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1050</span>;<br><br><span class="hljs-type">int</span> l1,l2;<br><span class="hljs-type">int</span> a1[MAX],a2[MAX];<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pre[MAX][MAX];<br><span class="hljs-type">int</span> op[MAX][MAX],dp[MAX][MAX];<br><br><span class="hljs-comment">//删除 0</span><br><span class="hljs-comment">//改变 1</span><br><span class="hljs-comment">//不变 2</span><br><span class="hljs-comment">//插入 3</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><br><span class="hljs-keyword">while</span>(cin&gt;&gt;a1[++l1])&#123;<br><span class="hljs-keyword">if</span>(a1[l1] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l1--;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;a2[++l2])&#123;<br><span class="hljs-keyword">if</span>(a2[l2] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l2--;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l1 ; i ++)&#123;<br>pre[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>dp[i][<span class="hljs-number">0</span>] = i;<br>op[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l2 ; i ++)&#123;<br>pre[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);<br>dp[<span class="hljs-number">0</span>][i] = i;<br>op[<span class="hljs-number">0</span>][i] = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l1 ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= l2 ; j ++)&#123;<br><span class="hljs-type">int</span> add = dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 3</span><br><span class="hljs-type">int</span> del = dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 0</span><br><span class="hljs-type">int</span> rpl = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + (a1[i] != a2[j]); <span class="hljs-comment">//1 ; 2</span><br><span class="hljs-type">int</span> min_ = <span class="hljs-built_in">min</span>(add,<span class="hljs-built_in">min</span>(del,rpl));<br><br><span class="hljs-keyword">if</span>(min_ == add)&#123;<br>dp[i][j] = add;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i,j<span class="hljs-number">-1</span>);<br>op[i][j] = <span class="hljs-number">3</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min_ == del)&#123;<br>dp[i][j] = del;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j);<br>op[i][j] = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dp[i][j] = rpl;<br>pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>);<br>op[i][j] = a1[i] == a2[j] ? <span class="hljs-number">2</span>:<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br><br><span class="hljs-type">int</span> x = l1;<br><span class="hljs-type">int</span> y = l2;<br>stack&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>|| y &gt; <span class="hljs-number">0</span>)&#123;<br>ans.<span class="hljs-built_in">push</span>(op[x][y]);<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; back = pre[x][y];<br>x = back.first;<br>y = back.second;<br>&#125;<br><span class="hljs-keyword">while</span>(!ans.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;ans.<span class="hljs-built_in">top</span>();<br>ans.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="进制转换">进制转换</h2><h3 id="k进制转化为10进制">1.k进制转化为10进制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">k_to_ten</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> k)</span></span>&#123; <span class="hljs-comment">//读入一个存储为k进制的数组a，返回一个10进制x</span><br>ll x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i &lt; len ; i ++)&#123;<br>x = x*k + a[i]; <span class="hljs-comment">//x = a[0]*k^n + a[1]*k*(n-1)...+a[len]</span><br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进制转化为k进制">2.10进制转化为k进制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ten_to_k</span><span class="hljs-params">(ll x,<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> k)</span></span>&#123; <span class="hljs-comment">//读入一个10进制x，转化为k进制数组a，返回a的长度</span><br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>a[len++] = x % k;<br>x /= k;<br>&#125;<br><span class="hljs-built_in">reverse</span>(a,a+len);<br><span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题_进制转换">3.例题_进制转换</h3><p><a href="https://www.lanqiao.cn/problems/1230/learning/">进制转换 -蓝桥云课 (lanqiao.cn)</a></p><ul><li>把这个k1进制的数转化为k2进制的数，需要10进制来过渡</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">ll <span class="hljs-title">k_to_ten</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> k)</span></span>&#123;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>ans = ans*k + a[i];<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ten_to_k</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> k,ll x)</span></span>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>a[len++] = x%k;<br>x /= k;<br>&#125;<br><span class="hljs-built_in">reverse</span>(a,a+len);<br><span class="hljs-keyword">return</span> len;<br>&#125;<br><br><span class="hljs-type">int</span> t,k1,k2;<br>string s;<br><span class="hljs-type">int</span> num[<span class="hljs-number">1000</span>],ans[<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;t;<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cin&gt;&gt;k1&gt;&gt;k2;<br>cin&gt;&gt;s;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) num[i] = <span class="hljs-built_in">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;F&#x27;</span>) num[i] = <span class="hljs-built_in">int</span>(s[i] - <span class="hljs-string">&#x27;A&#x27;</span> ) + <span class="hljs-number">10</span>;<br>&#125;<br>ll temp = <span class="hljs-built_in">k_to_ten</span>(num,len,k1);<br><span class="hljs-type">int</span> ans_len = <span class="hljs-built_in">ten_to_k</span>(ans,k2,temp);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; ans_len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(ans[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; ans[i] &lt;= <span class="hljs-number">9</span>) cout&lt;&lt;ans[i];<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">char</span>( <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;A&#x27;</span>) + ans[i] - <span class="hljs-number">10</span>);<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.例题_Alice和Bob的爱恨情仇</p><ul><li>博弈论+进制转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function">ll <span class="hljs-title">k_to_ten</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> k)</span></span>&#123;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>ans = ans*k + a[i];<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ten_to_k</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> k,ll x)</span></span>&#123;<br><span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>a[len++] = x%k;<br>x /= k;<br>&#125;<br><span class="hljs-built_in">reverse</span>(a,a+len);<br><span class="hljs-keyword">return</span> len;<br>&#125;<br><br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> GET[<span class="hljs-number">100000</span>];<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">while</span>(n--)&#123;<br><span class="hljs-type">int</span> temp;cin&gt;&gt;temp;<br>ans += temp;<br><span class="hljs-keyword">if</span>(ans % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>ll num;<br>cin&gt;&gt;num;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">ten_to_k</span>(GET,k,num);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>ans += GET[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ans % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;Bob&quot;</span>;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Alice&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/algorithm/%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/algorithm/%E5%88%86%E6%B2%BB/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>二分思想可以理解成是对枚举的一种优化，假设一个问题的解分布在01区间里，而这种解与某种递增变量有联系。那么，我们可以通过枚举这个变量来得到正解。暴力枚举的方法效率较低，而二分查找优化了这一枚举过程。</p><ul><li>二分题目的关键词：最xx的最xx，比如：最大的最近距离是多少?</li></ul><h1 id="整数二分模板">整数二分模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//关于模板的一些说明：</span><br><span class="hljs-comment">//对于数组 arr[10] = &#123;1,4,5,6,6,6,7,8,9,10&#125;;</span><br><span class="hljs-comment">//若要找到同样满足check的情况下，下标较大者，应该以l为答案</span><br><span class="hljs-comment">//此时查找区间为[l,r-1]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(arr[mid] &lt;= x) l = mid;<br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br>cout&lt;&lt;l; <span class="hljs-comment">//5</span><br>&#125;<br><span class="hljs-comment">//若要找到同样满足check的情况下，下标较小者，应该以r为答案</span><br><span class="hljs-comment">//此时查找区间为[l+1,r]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-number">9</span>;<br><span class="hljs-type">int</span> x = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(arr[mid] &gt;= x) r = mid;<br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;r; <span class="hljs-comment">//3</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="浮点二分模板">浮点二分模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>; <span class="hljs-comment">//设置精度</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> &amp;x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x*x + <span class="hljs-number">2</span>*x <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-comment">// f = x^2 + 2x -1;</span><br><span class="hljs-comment">// 求f(x) = m 的 x 的值</span><br><span class="hljs-type">double</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> r = <span class="hljs-number">1e10</span>;<br><span class="hljs-type">double</span> m;cin&gt;&gt;m;<br><span class="hljs-keyword">while</span>(r-l &gt;= eps)&#123;<br><span class="hljs-type">double</span> mid = (r+l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(mid) &gt; m)&#123;<br>r = mid;<br>&#125;<br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;r; <span class="hljs-comment">//输出l或者r可以，没有太大区别</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题1跳石头">例题1：跳石头</h1><p><a href="https://www.lanqiao.cn/problems/364/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=跳石头">1.跳石头- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br>ll len,n,m;<br>ll rock_pos[MAX];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; x)</span></span>&#123;<br>ll last_pos = <span class="hljs-number">0</span>;<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(rock_pos[i] - last_pos &lt; x)&#123;<br>ans++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>last_pos = rock_pos[i];<br>&#125;<br><span class="hljs-keyword">if</span>(len - last_pos &lt; x) ans++;<br><span class="hljs-keyword">return</span> ans &gt;= m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;len&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;rock_pos[i];<br>&#125;<br>ll l = <span class="hljs-number">0</span>;<br>ll r = <span class="hljs-number">1e9</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br>ll mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>r = mid;<br>&#125;<br><span class="hljs-keyword">else</span> l = mid;<br>&#125;<br>cout&lt;&lt;r;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题2肖恩的苹果林">例题2：肖恩的苹果林</h1><p><a href="https://www.lanqiao.cn/problems/3683/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=肖恩的苹果林">1.肖恩的苹果林- 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br>ll n,m;<br>ll tree_pos[MAX];<br><br><span class="hljs-function">ll <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; x)</span></span>&#123;<br>ll ans = <span class="hljs-number">1</span>;<br>ll last = tree_pos[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(tree_pos[i] - last &gt;= x)&#123;<br>ans++;<br>last = tree_pos[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i++)&#123;<br>cin&gt;&gt;tree_pos[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(tree_pos<span class="hljs-number">+1</span>,tree_pos<span class="hljs-number">+1</span>+n);<br>ll l = <span class="hljs-number">0</span>;<br>ll r = <span class="hljs-number">1e9</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br>ll mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid) &gt;= m)&#123;<br>l = mid;<br>&#125;<br><span class="hljs-keyword">else</span> r = mid;<br>&#125;<br>cout&lt;&lt;l;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>分治</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/algorithm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/algorithm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="prim算法">prim算法</h2><figure><img src="/algorithm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/v2-a5bb266f04bb7368d08fbe7c950b3924_720w.webp" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p><a href="https://www.luogu.com.cn/problem/P3366">P3366【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-type">bool</span> vis[MAX];<br><span class="hljs-type">int</span> head[MAX],idx,n,m,dist[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> next;<br><span class="hljs-type">int</span> to;<br><span class="hljs-type">int</span> w;<br>&#125;edge[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; from,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; to,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; val)</span></span>&#123;<br>edge[idx].next = head[from];<br>edge[idx].to = to;<br>edge[idx].w = val;<br>head[from] = idx;<br>idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>idx = <span class="hljs-number">0</span>;ans = <span class="hljs-number">0</span>;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">addEdge</span>(x,y,w);<br><span class="hljs-built_in">addEdge</span>(y,x,w);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> dis = pq.<span class="hljs-built_in">top</span>().first;<br><span class="hljs-type">int</span> pos = pq.<span class="hljs-built_in">top</span>().second;<br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(vis[pos]) <span class="hljs-keyword">continue</span>;<br>vis[pos] = <span class="hljs-literal">true</span>;<br>ans += dis;<br>cnt ++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = head[pos] ; j != <span class="hljs-number">-1</span> ; j = edge[j].next)&#123;<br><span class="hljs-type">int</span> t = edge[j].to;<br><span class="hljs-keyword">if</span>(dist[t] &gt; edge[j].w)&#123;<br>dist[t] = edge[j].w;<br>pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist[t],t));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">prim</span>()) cout&lt;&lt;ans;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;orz&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="kruskal算法">Kruskal算法</h2><h1 id="img"><img src="/algorithm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/v2-584bc7761471fd9835cde91b303935ac_720w.webp" alt="img"></h1><p><a href="https://www.luogu.com.cn/problem/P3366">P3366【模板】最小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&quot;\n&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-type">int</span> n,m,f[MAX],ans;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> x, y, w;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> w &lt; rhs.w;<br>    &#125;<br>&#125;edge[MAX];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(f[x] == x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> f[x] = <span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">sort</span>(edge<span class="hljs-number">+1</span>,edge<span class="hljs-number">+1</span>+m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>f[i] = i;<br>&#125;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br><span class="hljs-type">int</span> scc1 = <span class="hljs-built_in">find</span>(edge[i].x);<br><span class="hljs-type">int</span> scc2 = <span class="hljs-built_in">find</span>(edge[i].y);<br><span class="hljs-keyword">if</span>(scc1 == scc2) <span class="hljs-keyword">continue</span>;<br>ans += edge[i].w;<br>cnt ++;<br>f[scc2] = scc1;<br><span class="hljs-keyword">if</span>(cnt == n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cnt == n<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++)&#123;<br>cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].w;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">Kruskal</span>()) cout&lt;&lt;ans;<br><span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;orz&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路问题</title>
    <link href="/algorithm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/"/>
    <url>/algorithm/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><ul><li>单源最短路径问题</li><li>无法处理负权图</li><li>时间复杂度O（n^2）</li></ul><h3 id="（1）邻接矩阵-无堆优化"><a href="#（1）邻接矩阵-无堆优化" class="headerlink" title="（1）邻接矩阵 + 无堆优化"></a>（1）邻接矩阵 + 无堆优化</h3><p>（点的数量较少,  &lt; 1e5 ）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">100</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-type">int</span> edge[MAX][MAX];<br><span class="hljs-type">int</span> dist[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">int</span> path[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; <span class="hljs-comment">//初始化</span><br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<span class="hljs-comment">//可改</span><br><span class="hljs-built_in">memset</span>(edge,INF,<span class="hljs-built_in">sizeof</span>(edge));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">while</span>(m--)&#123; <span class="hljs-comment">//可改</span><br><span class="hljs-type">int</span> x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br>edge[x][y] = <span class="hljs-built_in">min</span>(edge[x][y],w);<span class="hljs-comment">//去重</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<span class="hljs-comment">//主干算法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>dist[i] = edge[s][i];<br>path[i] = s;<br>&#125;<br>visited[s] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-type">int</span> f;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125; <br>&#125;<br>visited[f] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[f] + edge[f][j] &lt; dist[j])&#123;<br>dist[j] = dist[f] + edge[f][j];<br>path[j] = f;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;dist[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）邻接表-无堆优化"><a href="#（2）邻接表-无堆优化" class="headerlink" title="（2）邻接表 + 无堆优化"></a>（2）邻接表 + 无堆优化</h3><p><a href="https://www.luogu.com.cn/problem/P3371">P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> nex,to,w;<br>&#125;e[maxn];<br><br><span class="hljs-type">int</span> head[maxn],dist[maxn];<br><span class="hljs-type">bool</span> visited[maxn];<br><span class="hljs-type">int</span> n,m,s,idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w)</span></span>&#123;<br>e[idx].to = t;<br>e[idx].w = w;<br>e[idx].nex = head[f];<br>head[f] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist,inf,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">addEdge</span>(x,y,w);<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = head[s] ; j != <span class="hljs-number">-1</span> ; j = e[j].nex)&#123;<br><span class="hljs-type">int</span> t = e[j].to;<br>dist[t] = <span class="hljs-built_in">min</span>(dist[t], e[j].w);<br>&#125;<br>dist[s] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> min_ = inf;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = head[f] ; j != <span class="hljs-number">-1</span> ; j = e[j].nex)&#123;<br><span class="hljs-type">int</span> to = e[j].to;<br><span class="hljs-keyword">if</span>(!visited[to] &amp;&amp; dist[to] &gt; dist[f] + e[j].w)&#123;<br>dist[to] = dist[f] + e[j].w;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">Dijkstra</span>();<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> def = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>)<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;(dist[i] == inf ? def:dist[i]);<br><span class="hljs-keyword">if</span>(i != n) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（3）邻接表-堆优化"><a href="#（3）邻接表-堆优化" class="headerlink" title="（3）邻接表 + 堆优化"></a>（3）邻接表 + 堆优化</h3><p><a href="https://www.luogu.com.cn/problem/P4779">P4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> nex,to,w;<br>&#125;e[maxn];<br><br><span class="hljs-type">int</span> head[maxn],dist[maxn];<br><span class="hljs-type">bool</span> visited[maxn];<br><span class="hljs-type">int</span> n,m,s,idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w)</span></span>&#123;<br>e[idx].to = t;<br>e[idx].w = w;<br>e[idx].nex = head[f];<br>head[f] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist,inf,<span class="hljs-built_in">sizeof</span>(dist));<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">addEdge</span>(x,y,w);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; &gt; q;<br>dist[s] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;dist[s],s&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-keyword">auto</span> top = q.<span class="hljs-built_in">top</span>();<br><span class="hljs-type">int</span> f = top.second;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(visited[f]) <span class="hljs-keyword">continue</span>;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[f] ; i != <span class="hljs-number">-1</span> ; i = e[i].nex)&#123;<br><span class="hljs-type">int</span> to = e[i].to;<br><span class="hljs-keyword">if</span>(!visited[to] &amp;&amp; dist[to] &gt; dist[f] + e[i].w)&#123;<br>dist[to] = dist[f] + e[i].w;<br>q.<span class="hljs-built_in">push</span>(&#123;dist[to],to&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">Dijkstra</span>();<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> def = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>)<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cout&lt;&lt;(dist[i] == inf ? def:dist[i]);<br><span class="hljs-keyword">if</span>(i != n) cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h1><ul><li>可以理解成图上的一种有条件的BFS算法</li><li>处理带负权的单源最短路径问题</li></ul><p>&#x2F;&#x2F;邻接表</p><p><a href="https://www.luogu.com.cn/problem/P3371">P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_EDGE = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NODE = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-type">int</span> idx;<br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">int</span> head[MAX_NODE],dist[MAX_NODE];<span class="hljs-comment">//头结点、距离数组</span><br><span class="hljs-type">bool</span> inqueue[MAX_NODE];<span class="hljs-comment">//用于判断是否在队列中</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> next;<br><span class="hljs-type">int</span> to;<br><span class="hljs-type">int</span> w;<br>&#125;edge[MAX_EDGE];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to,<span class="hljs-type">int</span> val)</span></span>&#123;<br>edge[idx].next = head[from];<br>edge[idx].to = to;<br>edge[idx].w = val;<br>head[from] = idx;<br>idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(inqueue,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(inqueue));<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-built_in">memset</span>(dist,INF,<span class="hljs-built_in">sizeof</span>(dist));<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">add_edge</span>(x,y,w);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span> &gt; q;<br>q.<span class="hljs-built_in">push</span>(s);<br>inqueue[s] = <span class="hljs-literal">true</span>;<br>dist[s] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>inqueue[f] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[f]; i != <span class="hljs-number">-1</span> ; i = edge[i].next)&#123;<br><span class="hljs-type">int</span> t = edge[i].to;<br><span class="hljs-keyword">if</span>(dist[f] + edge[i].w &lt; dist[t])&#123;<br>dist[t] = dist[f] + edge[i].w;<br><span class="hljs-keyword">if</span>(!inqueue[t]) &#123;<br>q.<span class="hljs-built_in">push</span>(t);<br>inqueue[t] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">spfa</span>();<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> NOfound = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">31</span>) - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(dist[i] == INF)&#123;<br>cout&lt;&lt;NOfound&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> cout&lt;&lt;dist[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h1><ul><li><p>多源最短路径问题</p></li><li><p>可以处理负权边，但不能处理负权回路</p></li><li><p>时间复杂度O(n^3)</p></li></ul><p>板子题：</p><p><a href="https://www.luogu.com.cn/problem/P1629">P1629 邮递员送信 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_NODE = <span class="hljs-number">1e3</span> + <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_EDGE = <span class="hljs-number">1e5</span>;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-type">int</span> edge[MAX_NODE][MAX_NODE];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(edge,INF,<span class="hljs-built_in">sizeof</span>(edge));<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> x,y,w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br>edge[x][y] = <span class="hljs-built_in">min</span>(edge[x][y],w);<span class="hljs-comment">//多重边判重！！！</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; k &lt;= n ; k ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(edge[i][k] == INF) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//优化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>edge[i][j] = <span class="hljs-built_in">min</span>(edge[i][j], edge[i][k] + edge[k][j]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">Floyd</span>();<br>ll ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>ans += edge[<span class="hljs-number">1</span>][i] + edge[i][<span class="hljs-number">1</span>];<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Dijkstra拓展-1-杂项"><a href="#Dijkstra拓展-1-杂项" class="headerlink" title="Dijkstra拓展-1-杂项"></a>Dijkstra拓展-1-杂项</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805379664297984">1087 All Roads Lead to Rome - PAT (Advanced Level) Practice</a></p><p>涉及知识点：统计路径数量，路径回溯，多权值（路径短&gt;&gt;价值高&gt;&gt;节点少）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-comment">//Dijkstra集大成者</span><br><span class="hljs-comment">//统计路径数量，路径回溯，多权值（路径短&gt;&gt;价值高&gt;&gt;节点少）</span><br><span class="hljs-comment">//本题没涉及的知识点：多权值（节点价值最大值）</span><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> w[MAX];<br><span class="hljs-type">int</span> edge[MAX][MAX];<br><span class="hljs-type">int</span> cnt[MAX],path[MAX],dist[MAX],val[MAX],num[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br>string st;<br>string name[MAX];<br>unordered_map&lt;string,<span class="hljs-type">int</span>&gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>dist[i] = edge[<span class="hljs-number">0</span>][i];<br><span class="hljs-keyword">if</span>(dist[i] != INF)&#123;<br>path[i] = <span class="hljs-number">0</span>;<br>val[i] = w[i];<br>cnt[i] = <span class="hljs-number">1</span>;<br>num[i] = <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>path[i] = i;<br>val[i] = <span class="hljs-number">-1</span>;<br>cnt[i] = <span class="hljs-number">0</span>;<br>num[i] = INF;<br>&#125;<br>&#125;<br>visited[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &gt; dist[f] + edge[f][j])&#123;<br>dist[j] = dist[f] + edge[f][j];<br>val[j] = val[f] + w[j];<br>path[j] = f;<br>cnt[j] = cnt[f];<br>num[j] = num[f] + <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] == dist[f] + edge[f][j])&#123;<br><br><span class="hljs-keyword">if</span>(val[j] &lt; val[f] + w[j])&#123;<br>val[j] = val[f] + w[j];<br>num[j] = num[f] + <span class="hljs-number">1</span>;<br>path[j] = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val[j] == val[f] + w[j] &amp;&amp; num[j] &gt; num[f] + <span class="hljs-number">1</span>)&#123;<br>num[j] = num[f] + <span class="hljs-number">1</span>;<br>path[j] = f;<br>&#125;<br><br>cnt[j] += cnt[f];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(name[x] == st)&#123;<br>cout&lt;&lt;st;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printPath</span>(path[x]);<br>cout&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;name[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k&gt;&gt;st;<br>name[<span class="hljs-number">0</span>] = st;<br>mp[st] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>string s;<span class="hljs-type">int</span> w_;cin&gt;&gt;s&gt;&gt;w_;<br>name[i] = s;<br>mp[s] = i;<br>w[i] = w_;<br>&#125;<br><span class="hljs-built_in">memset</span>(edge,INF,<span class="hljs-built_in">sizeof</span>(edge));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br>string sa,sb;<span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;sa&gt;&gt;sb&gt;&gt;c;<br>a = mp[sa];b = mp[sb];<br>edge[a][b] = edge[b][a] = c;<br>&#125;<br><span class="hljs-built_in">Dijkstra</span>();<br>cout&lt;&lt;cnt[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;dist[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;val[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;val[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]/num[mp[<span class="hljs-string">&quot;ROM&quot;</span>]]&lt;&lt;endl;<br><span class="hljs-built_in">printPath</span>(mp[<span class="hljs-string">&quot;ROM&quot;</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>STL写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">300</span>;<br><br>unordered_map&lt;string, vector&lt;pair&lt;string, <span class="hljs-type">int</span>&gt; &gt; &gt; mp;<span class="hljs-comment">// 边</span><br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; dist, num, hp, sum_hp, len;<br><span class="hljs-comment">// 最短距离，路径数，价值，价值和，路径长度</span><br>unordered_map&lt;string, string&gt; path;<span class="hljs-comment">// 路径记录</span><br>unordered_map&lt;string, <span class="hljs-type">bool</span>&gt; visited;<br><span class="hljs-type">int</span> n, k;<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(string f, string t, <span class="hljs-type">int</span> w)</span></span>&#123;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(f))&#123;<br>mp[f].<span class="hljs-built_in">push_back</span>(&#123;t, w&#125;);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>vector&lt;pair&lt;string, <span class="hljs-type">int</span>&gt; &gt; v;<br>v.<span class="hljs-built_in">push_back</span>(&#123;t, w&#125;);<br>mp[f] = v;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, string&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>, string&gt; &gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, string&gt; &gt; &gt; pq;<br>dist[s] = <span class="hljs-number">0</span>;<br>num[s] = <span class="hljs-number">1</span>;<br>sum_hp[s] = <span class="hljs-number">0</span>;<br>len[s] = <span class="hljs-number">0</span>;<br>path[s] = <span class="hljs-string">&quot;null&quot;</span>;<br>pq.<span class="hljs-built_in">push</span>(&#123;dist[s], s&#125;);<br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>string f = pq.<span class="hljs-built_in">top</span>().second;<br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(visited[f]) <span class="hljs-keyword">continue</span>;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : mp[f])&#123;<br>string t = it.first;<br><span class="hljs-type">int</span> w = it.second;<br><span class="hljs-keyword">if</span>(!visited[t] &amp;&amp; dist[t] &gt; dist[f] + w)&#123;<br>dist[t] = dist[f] + w;<br>num[t] = num[f];<br>len[t] = len[f] + <span class="hljs-number">1</span>;<br>sum_hp[t] = sum_hp[f] + hp[t];<br>path[t] = f;<br>pq.<span class="hljs-built_in">push</span>(&#123;dist[t], t&#125;);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[t] &amp;&amp; dist[t] == dist[f] + w)&#123;<br>num[t] += num[f];<br><span class="hljs-keyword">if</span>(sum_hp[t] &lt; sum_hp[f] + hp[t])&#123;<br>path[t] = f;<br>len[t] = len[f] + <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum_hp[t] == sum_hp[f] + hp[t])&#123;<br><span class="hljs-keyword">if</span>(len[t] &gt; len[f] + <span class="hljs-number">1</span>)&#123;<br>path[t] = f;<br>len[t] = len[f] + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_path</span><span class="hljs-params">(string x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(path[x] != <span class="hljs-string">&quot;null&quot;</span>)&#123;<br><span class="hljs-built_in">print_path</span>(path[x]);<br>cout&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>&#125;<br>cout&lt;&lt;x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br>string t; <span class="hljs-type">int</span> w; cin&gt;&gt;t&gt;&gt;w;<br>dist[t] = inf;<br>hp[t] = w;<br>sum_hp[t] = w;<br>visited[t] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br>string x, y; <span class="hljs-type">int</span> w;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;<br><span class="hljs-built_in">add_edge</span>(x, y, w);<br><span class="hljs-built_in">add_edge</span>(y, x, w);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>();<br>cout&lt;&lt;num[<span class="hljs-string">&quot;ROM&quot;</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;dist[<span class="hljs-string">&quot;ROM&quot;</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;sum_hp[<span class="hljs-string">&quot;ROM&quot;</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;sum_hp[<span class="hljs-string">&quot;ROM&quot;</span>]/len[<span class="hljs-string">&quot;ROM&quot;</span>]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">print_path</span>(<span class="hljs-string">&quot;ROM&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Dijkstra拓展-2-超点"><a href="#Dijkstra拓展-2-超点" class="headerlink" title="Dijkstra拓展-2-超点"></a>Dijkstra拓展-2-超点</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=1697151678120173571&page=1">1175 Professional Ability Test - PAT (Advanced Level) Practice</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1e3</span> + <span class="hljs-number">50</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> e[MAX][MAX],w[MAX][MAX],val[MAX],dist[MAX],path[MAX];<br><span class="hljs-type">int</span> sup = <span class="hljs-number">1002</span>;<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> ind[MAX],indTep[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasLoop</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span> &gt; q;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(indTep[i] == <span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>cnt++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(e[f][i] != INF)&#123;<br>indTep[i]--;<br><span class="hljs-keyword">if</span>(indTep[i] == <span class="hljs-number">0</span>)&#123;<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cnt != n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(ind[i] == <span class="hljs-number">0</span>)&#123;<br>dist[i] = e[sup][i] = <span class="hljs-number">0</span>;<br>val[i] = w[sup][i] = <span class="hljs-number">0</span>;<br>path[i] = sup;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dist[i] = e[sup][i] = INF;<br>val[i] = w[sup][i] = <span class="hljs-number">-1</span>;<br>path[i] = i;<br>&#125;<br>&#125;<br>visited[sup] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; min_)&#123;<br>min_ = dist[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[f] + e[f][j] &lt; dist[j])&#123;<br>dist[j] = dist[f] + e[f][j];<br>val[j] = val[f] + w[f][j];<br>path[j] = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist[f] + e[f][j] == dist[j] &amp;&amp;<br>val[f] + w[f][j] &gt; val[j])&#123;<br>dist[j] = dist[f] + e[f][j];<br>val[j] = val[f] + w[f][j];<br>path[j] = f;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(e,INF,<span class="hljs-built_in">sizeof</span>(e));<br><span class="hljs-built_in">memset</span>(w,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(w));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b,s,d;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;e[a][b]&gt;&gt;w[a][b];<br>ind[b]++;<br>indTep[b]++;<br>&#125;<br><span class="hljs-type">bool</span> f = <span class="hljs-built_in">hasLoop</span>();<br><span class="hljs-keyword">if</span>(!f)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Okay.\n&quot;</span>;<br><span class="hljs-built_in">Dijkstra</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Impossible.\n&quot;</span>;<br>&#125;<br>cin&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br><span class="hljs-type">int</span> q;cin&gt;&gt;q;<br><span class="hljs-keyword">if</span>(f)&#123;<br><span class="hljs-keyword">if</span>(ind[q] == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;You may take test &quot;</span>&lt;&lt;q&lt;&lt;<span class="hljs-string">&quot; directly.\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Error.\n&quot;</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(ind[q] == <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;You may take test &quot;</span>&lt;&lt;q&lt;&lt;<span class="hljs-string">&quot; directly.\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> t = q;<br>stack&lt;<span class="hljs-type">int</span> &gt; st;<br><span class="hljs-keyword">while</span>(t != sup)&#123;<br>st.<span class="hljs-built_in">push</span>(t);<br>t = path[t];<br>&#125;<br>cout&lt;&lt;st.<span class="hljs-built_in">top</span>();st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;st.<span class="hljs-built_in">top</span>();st.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Dijkstra拓展-3-两次最短路"><a href="#Dijkstra拓展-3-两次最短路" class="headerlink" title="Dijkstra拓展-3-两次最短路"></a>Dijkstra拓展-3-两次最短路</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805358663417856&page=1">1111 Online Map - PAT (Advanced Level) Practice</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1000</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n,m,s,t;<br><span class="hljs-type">int</span> len[MAX][MAX],tim[MAX][MAX];<br><span class="hljs-type">int</span> dist1[MAX],cost1[MAX],path1[MAX];<br><span class="hljs-type">int</span> sum2[MAX],cost2[MAX],path2[MAX];<br><span class="hljs-type">bool</span> visited[MAX];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra1</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>dist1[i] = len[s][i];<br>cost1[i] = tim[s][i];<br><span class="hljs-keyword">if</span>(len[s][i] != INF) path1[i] = s;<br><span class="hljs-keyword">else</span> path1[i] = i;<br>&#125;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist1[j] &lt; min_)&#123;<br>min_ = dist1[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist1[j] &gt; dist1[f] + len[f][j])&#123;<br>dist1[j] = dist1[f] + len[f][j];<br>cost1[j] = cost1[f] + tim[f][j];<br>path1[j] = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; dist1[j] == dist1[f] + len[f][j]<br>&amp;&amp; cost1[j] &gt; cost1[f] + tim[f][j])&#123;<br>dist1[j] = dist1[f] + len[f][j];<br>cost1[j] = cost1[f] + tim[f][j];<br>path1[j] = f;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra2</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cost2[i] = tim[s][i];<br><span class="hljs-keyword">if</span>(len[s][i] != INF)&#123;<br>path2[i] = s;<br>sum2[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> path2[i] = i;<br>&#125;<br>visited[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> min_ = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; cost2[j] &lt; min_)&#123;<br>min_ = cost2[j];<br>f = j;<br>&#125;<br>&#125;<br>visited[f] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; cost2[j] &gt; cost2[f] + tim[f][j])&#123;<br>cost2[j] = cost2[f] + tim[f][j];<br>sum2[j] = sum2[f] + <span class="hljs-number">1</span>;<br>path2[j] = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; cost2[j] == cost2[f] + tim[f][j]<br>&amp;&amp; sum2[j] &gt; sum2[f] + <span class="hljs-number">1</span>)&#123;<br>cost2[j] = cost2[f] + tim[f][j];<br>sum2[j] = sum2[f] + <span class="hljs-number">1</span>;<br>path2[j] = f;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> ty)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == s)&#123;<br>cout&lt;&lt;s;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(ty == <span class="hljs-number">1</span>) <span class="hljs-built_in">PrintPath</span>(path1[x], ty);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">PrintPath</span>(path2[x], ty);<br>cout&lt;&lt;<span class="hljs-string">&quot; -&gt; &quot;</span>;<br>cout&lt;&lt;x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">memset</span>(len,INF,<span class="hljs-built_in">sizeof</span>(len));<br><span class="hljs-built_in">memset</span>(tim,INF,<span class="hljs-built_in">sizeof</span>(tim));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br><span class="hljs-type">int</span> a,b,f,d,ti;cin&gt;&gt;a&gt;&gt;b&gt;&gt;f&gt;&gt;d&gt;&gt;ti;<br><span class="hljs-keyword">if</span>(f)&#123;<br>len[a][b] = d;<br>tim[a][b] = ti;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>len[a][b] = len[b][a] = d;<br>tim[a][b] = tim[b][a] = ti;<br>&#125;<br>&#125;<br>cin&gt;&gt;s&gt;&gt;t;<br><span class="hljs-built_in">Dijkstra1</span>();<br><span class="hljs-built_in">Dijkstra2</span>();<br><span class="hljs-type">bool</span> same = <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> a = t;<span class="hljs-type">int</span> b = t;<br><span class="hljs-keyword">while</span>(a != s &amp;&amp; b != s)&#123;<br><span class="hljs-keyword">if</span>(a != b)&#123;<br>same = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>a = path1[a];<br>b = path2[b];<br>&#125;<br><span class="hljs-keyword">if</span>(same)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Distance = &quot;</span>&lt;&lt;dist1[t]&lt;&lt;<span class="hljs-string">&quot;; &quot;</span>&lt;&lt;<span class="hljs-string">&quot;Time = &quot;</span>&lt;&lt;cost2[t]&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>;<br><span class="hljs-built_in">PrintPath</span>(t,<span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Distance = &quot;</span>&lt;&lt;dist1[t]&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>;<br><span class="hljs-built_in">PrintPath</span>(t,<span class="hljs-number">1</span>);cout&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;Time = &quot;</span>&lt;&lt;cost2[t]&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>;<br><span class="hljs-built_in">PrintPath</span>(t,<span class="hljs-number">2</span>);cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论杂项</title>
    <link href="/algorithm/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA%E6%9D%82%E9%A1%B9/"/>
    <url>/algorithm/%E5%9B%BE%E8%AE%BA/%E5%9B%BE%E8%AE%BA%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="哈密顿图">哈密顿图</h1><h2 id="定义">定义</h2><ul><li>哈密顿路（通路）：无向图G中，通过图中每个结点一次而且仅一次的路径。</li><li>哈密顿回路：无向图G中，通过图中每个结点一次而且仅一次的回路。</li><li>哈密顿图：具有哈密顿回路的图。</li><li>半哈密顿图：有哈密顿路径而没有哈密顿回路的图。</li></ul><h2 id="推论">推论</h2><blockquote><p>简单图 :在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图</p></blockquote><ul><li>图G具有n个结点的无向简单连通图，G中任意两个不相邻的结点度数之和 ≥n-1，则G是半哈密顿图</li><li>图G具有n个结点的无向简单连通图，如果图G中任意一对不相邻结点的度数之和≥ n，则G是哈密顿图</li></ul><h2 id="判断哈密顿回路">判断哈密顿回路</h2><p>例题：<a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805351814119424&amp;page=1">1122Hamiltonian Cycle - PAT (Advanced Level) Practice (pintia.cn)</a></p><p>根据哈密顿回路的定义证明即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(!edge[v[i<span class="hljs-number">-1</span>]][v[i]] || vis[v[i]]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>vis[v[i]] = <span class="hljs-literal">true</span>;<br>cnt++;<br>&#125;<br><span class="hljs-keyword">return</span> v[len<span class="hljs-number">-1</span>] == v[<span class="hljs-number">0</span>] &amp;&amp; cnt == n;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个可用于判断的必要条件：回路长度为n+1。</p><p>此外，还需要注意：编号是否在范围内；边是否存在 等</p><h1 id="欧拉图">欧拉图</h1><h2 id="定义-1">定义</h2><ul><li>欧拉（通路）路径：无向图G中，通过图中每个边一次而且仅一次的路径。</li><li>欧拉回路：无向图G中，通过图中每个边一次而且仅一次的回路。</li><li>欧拉图：具有欧拉回路的图。</li><li>半欧拉图：有欧拉路径而没有欧拉回路的图。</li></ul><h2 id="推论-1">推论</h2><ul><li>图G是无向简单连通图，G中每个节点的度都为偶数，则G是欧拉图。</li><li>图G是无向简单连通图，G中恰好有两个节点的度数为奇数，其他节点的度数都是偶数（这两个奇数度的节点恰是所有欧拉回路的起点S和终点T）。</li></ul><h2 id="判断欧拉图">判断欧拉图</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805349851185152&amp;page=1">1126Eulerian Path - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//1-非欧拉图 2-半欧拉图 3-欧拉图</span><br>    <br>    <span class="hljs-comment">//并查集判断是否连通</span><br><span class="hljs-type">int</span> scc = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-built_in">find</span>(i)) scc++;<br>&#125;<br><span class="hljs-keyword">if</span>(scc != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//求奇数度的点的个数</span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(d[i] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>cnt++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完全子图团">完全子图（团）</h1><h2 id="定义-2">定义</h2><ul><li><p>图G的团（完全子图）就是一个两两之间有边的顶点集合</p></li><li><p>极大团：增加任一顶点都不再符合团定义的团</p></li><li><p>最大团：顶点最多的极大团，称之为图G的</p></li></ul><h2 id="判断团">判断团</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805343979159552&amp;page=1">1142Maximal Clique - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(visited,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visited));<br>cin&gt;&gt;k;<br>v.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br><span class="hljs-type">int</span> t;cin&gt;&gt;t;<br>v.<span class="hljs-built_in">push_back</span>(t);<br>visited[t] = <span class="hljs-literal">true</span>;<br>&#125;<br>    <span class="hljs-comment">//是否为完全子图</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; k ; j ++)&#123;<br><span class="hljs-keyword">if</span>(j == i) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(!edge[v[i]][v[j]])&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Not a Clique&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//是否为极大完全子图</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(visited[i]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-type">bool</span> f = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; k ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!edge[v[j]][i])&#123;<br>f = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(f)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Not Maximal&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="旅行商环路tsp">旅行商环路（TSP）</h1><h2 id="定义-3">定义</h2><p>给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路</p><blockquote><p>给一张带权边的无向图G，求访问每个节点（可重复走边和点）的最短回路。</p></blockquote><h2 id="判断tsp">判断TSP</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=1038430013544464384&amp;page=1">1150Travelling Salesman Problem - PAT (Advanced Level) Practice(pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//检查是否能走通，并求路径长度</span><br><span class="hljs-type">int</span> dis = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; k ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(dist[v[i<span class="hljs-number">-1</span>]][v[i]] == INF)&#123;<br>        dis = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        dis += dist[v[i<span class="hljs-number">-1</span>]][v[i]];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dis == <span class="hljs-number">-1</span>)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Path &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;: NA&quot;</span>&lt;&lt;<span class="hljs-string">&quot; (Not a TS cycle)&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//检查是否为经过每个点的环</span><br><span class="hljs-built_in">memset</span>(visNode,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visNode));<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(!visNode[v[i]])&#123;<br>        visNode[v[i]] = <span class="hljs-literal">true</span>;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>] != v[k<span class="hljs-number">-1</span>] || cnt != n)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Path &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dis&lt;&lt;<span class="hljs-string">&quot; (Not a TS cycle)&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//检查是否存在重边</span><br><span class="hljs-built_in">memset</span>(visEdge,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visEdge));<br><span class="hljs-type">bool</span> isSimple = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; k ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(visEdge[v[i]][v[i<span class="hljs-number">-1</span>]] || v[i] == v[i<span class="hljs-number">-1</span>])&#123;<br>        isSimple = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    visEdge[v[i]][v[i<span class="hljs-number">-1</span>]] = visEdge[v[i<span class="hljs-number">-1</span>]][v[i]] = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(isSimple)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Path &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dis&lt;&lt;<span class="hljs-string">&quot; (TS simple cycle)&quot;</span>&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Path &quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dis&lt;&lt;<span class="hljs-string">&quot; (TS cycle)&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>段错误的可能原因</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%AE%B5%E9%94%99%E8%AF%AF%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%AE%B5%E9%94%99%E8%AF%AF%E7%9A%84%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="导致段错误的可能原因">导致段错误的可能原因</h1><h2 id="数组越界">1.数组越界</h2><p>1）n = INT_MAX?</p><p>有时题目说的范围是int的取值范围，而不是1-n，</p><p>此时，如果使用bool vis[N]来申请会出错，需要使用unordered_map&lt;int,bool&gt; mp;</p><p>2）<code>unsigned int cnt = v.size() - 1</code></p><p>这种写法看似没有问题，但是当v为空时，cnt会赋值为-1，而unsigned int无法表示负数，</p><p>会变为一个很大的正整数，在后续遍历时导致段错误。</p><h2 id="函数错误">2.函数错误</h2><p>Stoi和Stod使用前需保证传入的字符串是合法的数字/小数。</p><p>STL中的front、back和top函数需要配合empty函数使用，为空时访问会报错。</p><h2 id="栈溢出">3.栈溢出</h2><p>有时使用DFS会导致栈空间溢出，此时应该改用BFS+queue的形式。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其他算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串处理</title>
    <link href="/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <url>/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="c-string字符串">C++ : string字符串</h1><h2 id="运算符特性">运算符特性</h2><p>----支持比较运算符<code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>。支持<code>string</code>与<code>C-string</code>的比较（如<code>str &lt; "hello"</code>）。</p><p>在使用<code>&gt;,&gt;=,&lt;,&lt;=</code>这些操作符的时候是根据“当前字符特性”将字符按<code>字典顺序</code> 进行逐一得 比较。</p><p>字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p><p>----支持<code>+</code><strong>运算</strong>符，代表拼接字符串：string字符串可以拼接，通过”+”运算符进行拼接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;123&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;456&quot;</span>;<br>string s = s1 + s2;<br>cout &lt;&lt; s;   <span class="hljs-comment">//123456</span><br><br>效率上： s1 += s2 相当于 <span class="hljs-built_in">append</span>()/<span class="hljs-built_in">push_back</span>() 快于 s1 + s2<br></code></pre></td></tr></table></figure><h2 id="插入">插入</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.push_back()</code></td><td style="text-align: left;">在末尾插入</td></tr><tr><td style="text-align: left;"><code>s.insert(pos,element)</code></td><td style="text-align: left;">在pos位置插入element</td></tr><tr><td style="text-align: left;"><code>s.append(str)</code></td><td style="text-align: left;">在s字符串结尾添加str字符串</td></tr></tbody></table><h2 id="删除">删除</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>erase(it p)</code></td><td style="text-align: left;">删除迭代器p所指的字符</td></tr><tr><td style="text-align: left;"><code>erase(it1 it2)</code></td><td style="text-align: left;">删除迭代器区间<code>[first,last)</code></td></tr><tr><td style="text-align: left;"><code>erase(pos, n)</code></td><td style="text-align: left;">删除从pos开始n个字符</td></tr></tbody></table><h2 id="替换">替换</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.replace(pos,n,str)</code></td><td style="text-align: left;">把当前字符串从索引pos开始的n个字符替换为str</td></tr><tr><td style="text-align: left;"><code>s.replace(pos,n,n1,c)</code></td><td style="text-align: left;">把当前字符串从索引pos开始的n个字符替换为n1个字符c</td></tr><tr><td style="text-align: left;"><code>s.replace(it1,it2,str)</code></td><td style="text-align: left;">把当前字符串<code>[it1,it2)</code>区间替换为str</td></tr></tbody></table><h2 id="子串">子串</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.substr(pos,n)</code></td><td style="text-align: left;">从pos索引开始的n个字符</td></tr><tr><td style="text-align: left;"><code>s.substr(pos)</code></td><td style="text-align: left;">从pos开始到末尾</td></tr></tbody></table><blockquote><p>用 s = substr(n) 来删除前n个字符</p></blockquote><h2 id="查找">查找</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.find (str, pos)</code></td><td style="text-align: left;">从pos开始（默认0），查找子串str，返回找到的字符串的首字符位置</td></tr><tr><td style="text-align: left;"><code>s.find (c, pos)</code></td><td style="text-align: left;">从pos开始（默认0），查找字符c，返回找到字符位置</td></tr><tr><td style="text-align: left;"><code>s.rfind (str, pos)</code></td><td style="text-align: left;">从pos开始，反向找子串s</td></tr><tr><td style="text-align: left;"><code>s.rfind (c, pos)</code></td><td style="text-align: left;">从pos开始，反向找字符c</td></tr></tbody></table><blockquote><p>若找不到，返回值为string::npos，不是-1</p></blockquote><h1 id="char字符">Char字符</h1><h2 id="判断字母数字大小写">判断字母/数字/大小写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">isalpha</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是字母，如果是返回true(非0值)，反之返回false；</span><br><span class="hljs-built_in">isdigit</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是数字，如果是返回true(非0值)，反之返回false；</span><br><span class="hljs-built_in">isalnum</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是字母或数字，如果是返回true(非0值)，反之返回false；</span><br><span class="hljs-built_in">islower</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是小写字母，如果是返回true(非0值)，反之返回false；</span><br><span class="hljs-built_in">isupper</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//判断字符c是否是大写字母，如果是返回true(非0值)，反之返回false；</span><br></code></pre></td></tr></table></figure><h2 id="大小写转换">大小写转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">tolower</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//将字符c转换的小写字母，如果字符c无法转换为小写字母，返回字符c；</span><br><span class="hljs-built_in">toupper</span>( <span class="hljs-type">char</span> c ) <span class="hljs-comment">//将字符c转换的大写字母，如果字符c无法转换为大写字母，返回字符c；</span><br></code></pre></td></tr></table></figure><h1 id="c11-to_string">C++11: to_string</h1><p><code>to_string</code> 是 C++11 中引入的一个标准库函数。</p><p>用于将数值类型转换为字符串。它的作用是将整数、浮点数等数值类型转换成对应的字符串表示形式。</p><blockquote><p>to_string可以将int/long long/double等常用类型，转换为string类型</p><p>对于浮点数，to_string 默认会转换为保留小数点后六位的字符串表示。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-type">int</span> neg = <span class="hljs-number">-66</span>;<br><span class="hljs-type">double</span> f = <span class="hljs-number">3.14</span>;<br>string s = <span class="hljs-built_in">to_string</span>(num) + <span class="hljs-string">&quot; : &quot;</span> + <span class="hljs-built_in">to_string</span>(neg) + <span class="hljs-string">&quot; : &quot;</span> + <span class="hljs-built_in">to_string</span>(f);<br><span class="hljs-comment">//123 : -66 : 3.140000</span><br></code></pre></td></tr></table></figure><h1 id="c11-stoistollstod">C++11: stoi/stoll/stod</h1><p><code>stoi</code> 和 <code>stod</code> 是 C++ 11标准库中的两个函数，用于将字符串转换为整数或浮点数。</p><blockquote><p>stoi/stoll/stod/报错的可能原因：</p><p>输入字符串<strong>包含非法字符</strong>，不是合法的整数/浮点数类型。</p><p>输入<strong>字符串为空</strong>。</p><p>输入字符串超出了对应类型的表示范围，导致<strong>溢出</strong>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;2.33&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;-1000&quot;</span>;<br>cout&lt;&lt;<span class="hljs-built_in">stod</span>(s1) + <span class="hljs-built_in">stoi</span>(s2);<br><span class="hljs-comment">//-997.67</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算基础">位运算基础</h1><h2 id="补码">补码</h2><p>计算机中所有数都是以补码形式存储的，引进补码的作用是为了让计算机更方便做减法。</p><p>而正数的补码是它本身，负数的补码则是符号位不变，其余按位取反，最后再+ 1得到的。</p><p>例如：15 原码:00001111；补码:00001111 ；−15原码:10001111；补码:11110001。</p><h2 id="位运算符">位运算符</h2><table><thead><tr><th>符号</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr><td>|</td><td>或</td><td>两个位都为0时，结果才为0</td></tr><tr><td>^</td><td>异或</td><td>两个位相同为0，相异为1</td></tr><tr><td>~</td><td>取反</td><td>0变1，1变0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>各二进位全部左移若干位，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>各二进位全部右移若干位，对无符号数，高位补0（有符号数，右移补1）</td></tr></tbody></table><h2 id="基本用法">基本用法</h2><table><thead><tr><th>功能</th><th>符号表示</th></tr></thead><tbody><tr><td>/ 2</td><td>x &gt;&gt; 1</td></tr><tr><td>* 2</td><td>x &lt;&lt; 1</td></tr><tr><td>判断是否为奇数（true：奇数）</td><td>x&amp;1</td></tr><tr><td>判断是否为-1（true：非-1）</td><td>~x</td></tr><tr><td>将右数第k位置为1</td><td>x = x | (1 &lt;&lt; (k-1))</td></tr><tr><td>将右数第k位置为0</td><td>x = x &amp; (~(1 &lt;&lt; (k-1)))</td></tr><tr><td>将右数第k位取反</td><td>x = x ^(1 &lt;&lt;(k-1))</td></tr><tr><td>取右数k位，其他置为0</td><td>x = x &amp; ( (1 &lt;&lt; k) - 1)</td></tr><tr><td>将右数k位都置为1</td><td>x = x | ( (1 &lt;&lt; k) - 1 )</td></tr><tr><td>将右数k位都置为0</td><td>x = x &amp; ( ~( (1 &lt;&lt; k) - 1) )</td></tr><tr><td>把右边连续的1变为0</td><td>x = x &amp; (x + 1)</td></tr><tr><td>把右边连续的0变为1</td><td>x = x | (x - 1)</td></tr><tr><td>只取最靠右的1 (x != MIN)</td><td>x = x&amp;(-x) 或 x = x&amp;(~x + 1)</td></tr></tbody></table><p><strong>对比 &gt;&gt; 1 和 / 2</strong></p><p>效率差异：在编译器不优化的情况下，&gt;&gt;1的效率高，优先使用位运算</p><p>结果差异：只有在负奇数情况下，二者有差异，其他情况下相同</p><p><strong>原因</strong>是奇数除二会发生<strong>截断</strong>现象。而<code>&gt;&gt; 1</code>和<code>/ 2</code>在<code>n</code>为负奇数时截断的反向不一样。</p><ul><li><code>-5 / 2 = -(int)2.5 = -2</code>，这里是把绝对值变小了，加个负号，结果就变大了。</li><li><code>-5 &gt;&gt; 1 = (1011) &gt;&gt; 1 = (1101) = -3</code>，假设用<code>4-bit</code>表示一个整数，补码表示。发现结果变小了。</li></ul><h1 id="其他">其他</h1><h2 id="例题1swapa-b">例题1：Swap(A, B)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不使用中间变量，交换整数A和B</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题2位运算统计二进制中的1">例题2：位运算统计二进制中的1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ones</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)&#123;<br>x = x &amp; (x - <span class="hljs-number">1</span>);<br>res++;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="例题3o1时间检测2的幂次">例题3：O(1)时间检测2的幂次</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 2的幂次必须是正整数</span><br><span class="hljs-comment">// 2的幂次的二进制中必然只包含一个1，因此x &amp; (x - 1)为0</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> &amp;&amp; (x &amp; (x - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题4粘贴子串">例题4：粘贴子串</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给长度为j-i+1的二进制数m</span><br><span class="hljs-comment">// 将m覆盖到n的【i，j】位置上</span><br><span class="hljs-comment">// i，j从第0位开始</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = i ; t &lt;= j ; t ++)&#123;<br>n = n &amp; (~(<span class="hljs-number">1</span> &lt;&lt; t));<br>&#125;<br><span class="hljs-keyword">return</span> n |(m &lt;&lt; i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="debug二进制形式输出">Debug：二进制形式输出</h2><p>C++:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; hex &lt;&lt; i &lt;&lt;endl; <span class="hljs-comment">// 十六进制</span><br>cout &lt;&lt; oct &lt;&lt; i &lt;&lt;endl; <span class="hljs-comment">// 八进制</span><br>cout &lt;&lt; (bitset&lt;<span class="hljs-built_in">sizeof</span>(i)*<span class="hljs-number">8</span>&gt;)i &lt;&lt;endl; <span class="hljs-comment">// 二进制</span><br><span class="hljs-comment">// bitset&lt;x&gt;里的x是多少，就输出多少位</span><br></code></pre></td></tr></table></figure><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>, i); <span class="hljs-comment">// 十六进制</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%o\n&quot;</span>, i); <span class="hljs-comment">// 八进制</span><br><span class="hljs-type">char</span> str[<span class="hljs-number">50</span>];<br>itoa(i, str, <span class="hljs-number">2</span>); <span class="hljs-comment">// (原数, C字符串, 基数)</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str); <span class="hljs-comment">// 二进制</span><br></code></pre></td></tr></table></figure><h2 id="拓展brian-kernighan-算法">拓展：Brian Kernighan 算法</h2><ul><li>一个二进制数n，与运算n-1的结果是n的二进制最右端的1变为0的结果</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">n &amp; (n<span class="hljs-number">-1</span>) <span class="hljs-comment">//n的二进制最右端的1变为0</span><br><span class="hljs-number">12</span> = <span class="hljs-number">1100</span><br><span class="hljs-number">12</span> - <span class="hljs-number">1</span> = <span class="hljs-number">1011</span><br><span class="hljs-number">12</span>&amp;(<span class="hljs-number">12</span><span class="hljs-number">-1</span>) = <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><ul><li>n &amp; (~n + 1) 提取出整数n最后一位为1的数</li></ul><p>一个二进制数，其与 补码+1 （也就是反码）进行一次与运算的结果能够提取出其最后一位 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">n = <span class="hljs-number">01101</span><br><span class="hljs-comment">//~n 是将n按位取反就是10010</span><br>~n + <span class="hljs-number">1</span> = <span class="hljs-number">10011</span><br><span class="hljs-comment">//最后</span><br>n &amp; (~n + <span class="hljs-number">1</span>) = <span class="hljs-number">00001</span><br><span class="hljs-comment">//也相当于n&amp;（-n）</span><br></code></pre></td></tr></table></figure><h2 id="拓展格雷码">拓展：格雷码</h2><p>格雷码是一种数的二进制表示法，每一个数都与前一个数只相差一个bit位</p><ul><li>格雷码一种求解策略：</li></ul><p>------奇数 == （奇数-1） 的 最后一位取反</p><p>------偶数 == （偶数-1）的 最后一位1的前一位取反</p><p>使用Brian Kernighan算法可以快速实现格雷码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> bits;<br><br><span class="hljs-comment">//将int型转化为二进制</span><br><span class="hljs-function">string <span class="hljs-title">getBitStr</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>string ans = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> msk = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= bits ; i ++)&#123;<br>ans = (num&amp;msk ? <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>) + ans;<br>msk = msk &lt;&lt; <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GrayCode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;bits)</span></span>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,bits)<span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>cout&lt;&lt;<span class="hljs-built_in">getBitStr</span>(num)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= x ; i++)&#123;<br><span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>num = num^<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>num = num^( ((num&amp;( (~num) + <span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-number">1</span>) );<br>            <span class="hljs-comment">//Brian Kernighan 算法</span><br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">getBitStr</span>(num)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;bits;<br><span class="hljs-built_in">GrayCode</span>(bits);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其他算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C输入输出处理</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="scanf">Scanf</h1><p>常见%格式说明符</p><table><thead><tr><th>格式说明符</th><th>作用</th></tr></thead><tbody><tr><td><strong>c</strong></td><td>读入<strong>单个字符</strong>（后面不会加上空字节）</td></tr><tr><td><strong>s</strong></td><td>读入一个的<strong>字符序列</strong>，后面会加上空字节，遇到空白字符(空格等)完成读取。</td></tr><tr><td><strong>d</strong></td><td>读入可选<strong>有符号十进制整数</strong></td></tr></tbody></table><ul><li>%lld -- long long类型</li></ul><p>使用scanf来处理特殊的输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//例如：02:13:00 - 12:00:57</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d:%d:%d - %d:%d:%d&quot;</span>,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2);<br></code></pre></td></tr></table></figure><h1 id="printf">printf</h1><p>printf的格式控制字符串组成如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">%<span class="hljs-selector-attr">[flags]</span><span class="hljs-selector-attr">[width]</span><span class="hljs-selector-attr">[.prec]</span><span class="hljs-selector-attr">[length]</span><span class="hljs-selector-tag">type</span><br></code></pre></td></tr></table></figure><p>也就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">%[标志][最小宽度][.精度][类型长度]类型<br></code></pre></td></tr></table></figure><h2 id="标志--flag">1）标志--flag</h2><p>flags规定输出样式，取值和含义如下：</p><table><thead><tr><th style="text-align: left;">字符</th><th style="text-align: center;">名称</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr><td style="text-align: left;">-</td><td style="text-align: center;">减号</td><td style="text-align: center;">结果左对齐，右边填空格。默认是右对齐，左边填空格。</td></tr><tr><td style="text-align: left;">+</td><td style="text-align: center;">加号</td><td style="text-align: center;">输出符号(正号或负号)</td></tr><tr><td style="text-align: left;">space</td><td style="text-align: center;">空格</td><td style="text-align: center;">输出值为正时加上空格，为负时加上负号</td></tr><tr><td style="text-align: left;">#</td><td style="text-align: center;">井号</td><td style="text-align: center;">type是o、x、X时，增加前缀0、0x、0X。type是a、A、e、E、f、g、G时，一定使用小数点。默认的，如果使用.0控制不输出小数部分，则不输出小数点。type是g、G时，尾部的0保留。</td></tr><tr><td style="text-align: left;">0</td><td style="text-align: center;">数字零</td><td style="text-align: center;">将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用“-”）</td></tr></tbody></table><h2 id="width--最小宽度">2）width--最小宽度</h2><p>用十进制整数来表示输出的最少位数。若实际位数多于指定的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。width的可能取值如下：</p><p>xxxxxxxxxx #include&lt;bits/stdc++.h&gt;using namespace std;​intbits;​//将int型转化为二进制string getBitStr(int num){ string ans = "";int msk = 1; for(int i = 1 ; i &lt;= bits ; i ++){ ans = (num&amp;msk ?'1':'0') + ans; msk = msk &lt;&lt; 1; } return ans;}​void GrayCode(constint &amp;bits){ int x = pow(2,bits)-1; int num = 0;cout&lt;&lt;getBitStr(num)&lt;&lt;""; for(int i = 1 ; i &lt;= x ; i++){if(i % 2 != 0){ num = num^1; } else{ num = num^( ((num&amp;( (~num) +1)) &lt;&lt; 1) );            //Brian Kernighan 算法 }cout&lt;&lt;getBitStr(num)&lt;&lt;""; }}​int main(void){ cin&gt;&gt;bits;GrayCode(bits); return 0;}c++</p><p>输出：<code>001000</code></p><h2 id="precision--精度字符串长度">3）precision--精度/字符串长度</h2><p>主要用于浮点数和字符串，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8d\n&quot;</span>,<span class="hljs-number">1000</span>);          <span class="hljs-comment">//不足指定宽度补前导0，效果等同于%06d</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8f\n&quot;</span>,<span class="hljs-number">1000.123456789</span>);<span class="hljs-comment">//超过精度，截断</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8f\n&quot;</span>,<span class="hljs-number">1000.123456</span>);   <span class="hljs-comment">//不足精度，补后置0</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8g\n&quot;</span>,<span class="hljs-number">1000.123456</span>);   <span class="hljs-comment">//最大有效数字为8位</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.8s\n&quot;</span>,“abcdefghij”);  <span class="hljs-comment">//超过指定长度截断</span><br><span class="hljs-comment">//00001000</span><br><span class="hljs-comment">//1000.12345679</span><br><span class="hljs-comment">//1000.12345600</span><br><span class="hljs-comment">//1000.1235</span><br><span class="hljs-comment">//abcdefgh</span><br></code></pre></td></tr></table></figure><h1 id="sprintf">sprintf</h1><p>sprinf用于将其他类型转化成cstr字符串类型</p><p>用法和printf类似</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> cstring[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">sprintf</span>(cstring,<span class="hljs-string">&quot;%02d:%02d:%02d&quot;</span>,h,m,s);<br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(cstring)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="sscanf">sscanf</h1><p>sscanf用于将已有字符串转化为其他类型，用法和scanf类似</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> cstring[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">strcpy</span>(cstring,<span class="hljs-string">&quot;Saturday March 25 1989&quot;</span>);<br><span class="hljs-built_in">sscanf</span>(cstring, <span class="hljs-string">&quot;%s %s %d %d&quot;</span>, weekday, month, &amp;day, &amp;year );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其他算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP输入输出处理</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/CPP%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/CPP%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>C++默认输出的总位数最大是6位，包括整数和小数，即setprecision(6)</p><p>常用函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>)  <span class="hljs-comment">// 设置总位数为3</span><br>cout&lt;&lt;<span class="hljs-built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 设置小数部分保留3位，不够补0</span><br>cout&lt;&lt;<span class="hljs-built_in">setiosflags</span>(ios::scientific); <span class="hljs-comment">// 浮点表示法，很少用</span><br><br>cout&lt;&lt;<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;$&#x27;</span>); <span class="hljs-comment">// 设置填充符号为&#x27;$&#x27;,默认为空格</span><br>cout&lt;&lt;<span class="hljs-built_in">setw</span>(<span class="hljs-number">5</span>)&lt;&lt;endl;<span class="hljs-comment">// 设置输出宽度为5，右对齐</span><br>cout&lt;&lt;<span class="hljs-built_in">setiosflags</span>(ios::left)<span class="hljs-comment">// 改为左对齐</span><br>    <br><span class="hljs-type">double</span> f = <span class="hljs-number">2.2</span>;<br>cout&lt;&lt;<span class="hljs-built_in">round</span>(f)&lt;&lt;<span class="hljs-built_in">floor</span>(f)&lt;&lt;<span class="hljs-built_in">ceil</span>(f) <span class="hljs-comment">// 分别是按四舍五入/向下/向上 取整到整数</span><br><span class="hljs-comment">//若要保留4位小数，且向下取整，可以这么写：</span><br>cout&lt;&lt;<span class="hljs-built_in">setiosflags</span>(ios::fixed)&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>)&lt;&lt;<span class="hljs-built_in">floor</span>(f*<span class="hljs-number">10000</span>)/<span class="hljs-number">10000</span>;<br></code></pre></td></tr></table></figure><blockquote><p>setw和setfill，每次cout都要设置</p><p>setiosflags和setprecision只需要设置一次</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其他算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序汇总</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序">冒泡排序</h1><blockquote><p>稳定排序，时间复杂度O(n2)</p></blockquote><p><a href="https://www.cnblogs.com/wupeixuan/p/8654026.html">排序算法-冒泡排序- 武培轩 - 博客园 (cnblogs.com)</a></p><figure><img src="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/o_冒泡.jpg" alt="冒泡"><figcaption aria-hidden="true">冒泡</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Bubble_sort(冒泡排序)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; e - s ; i++) &#123; <span class="hljs-comment">//一共总次数-1 =（e-s+1)-1 = e-s次</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = s ; j &lt; e - i ; j ++) &#123;<br><span class="hljs-keyword">if</span> (ori[j] &gt; ori[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(ori[j],ori[j<span class="hljs-number">+1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v)</span></span>&#123;<br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[j] &gt; v[j<span class="hljs-number">+1</span>])&#123;<br><span class="hljs-built_in">swap</span>(v[j], v[j<span class="hljs-number">+1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序">选择排序</h1><blockquote><p>稳定排序，时间复杂度O(n2)</p></blockquote><p><a href="https://www.cnblogs.com/wupeixuan/p/8654459.html">排序算法-选择排序- 武培轩 - 博客园 (cnblogs.com)</a></p><figure><img src="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/o_1609bbf94a844522.jpg" alt="选择"><figcaption aria-hidden="true">选择</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Selection_sort(选择排序)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Selection_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s ; i &lt; e ; i ++) &#123;<br><span class="hljs-type">int</span> min_ = ori[i]; <span class="hljs-comment">//每次都找到[i,e]内的最小值ori[f]</span><br><span class="hljs-type">int</span> f = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= e ; j ++) &#123;<br><span class="hljs-keyword">if</span> (ori[j] &lt; min_) &#123;<br>min_ = ori[j];<br>f = j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(ori[f],ori[i]);<span class="hljs-comment">//交换ori[f]和ori[i]</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v)</span></span>&#123;<br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> f = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">if</span>(v[j] &lt; v[f])&#123;<br>f = j;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(v[f], v[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入排序">插入排序</h1><blockquote><p>不稳定排序，最佳n(已经排好序)，最差n2（完全相反）</p></blockquote><p><a href="https://www.cnblogs.com/wupeixuan/p/8654938.html">排序算法-插入排序- 武培轩 - 博客园 (cnblogs.com)</a></p><figure><img src="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/o_1609bbf94aad18b0.jpg" alt="插入"><figcaption aria-hidden="true">插入</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Insert_sort插入排序（扑克牌排序）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s + <span class="hljs-number">1</span> ; i &lt;= e; i ++) &#123;<br><span class="hljs-type">int</span> val = ori[i];<br><span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(j &gt;= s &amp;&amp; ori[j] &gt;= val) &#123;<br>ori[j + <span class="hljs-number">1</span>] = ori[j]; <span class="hljs-comment">//数组往后退</span><br>            j--;<br>&#125;<br>ori[j + <span class="hljs-number">1</span>] = val; <span class="hljs-comment">//插入</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v)</span></span>&#123;<br><span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> t = v[i];<br><span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; v[j] &gt; t)&#123;<br>v[j<span class="hljs-number">+1</span>] = v[j];<br>j--;<br>&#125;<br>v[j<span class="hljs-number">+1</span>] = t;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序">归并排序</h1><blockquote><p>较为稳定，复杂度与原始数据无关；时间复杂度：O(n*log n)</p><p>缺点是要申请一个等大的数组tmp；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> tmp[])</span> </span>&#123;<br><span class="hljs-type">int</span> m = s + (e - s) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> pt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> p1 = s, p2 = m + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= e) &#123; <span class="hljs-comment">//把已经排好序的数组，合并</span><br><span class="hljs-keyword">if</span> (ori[p1] &lt; ori[p2]) tmp[pt++] = ori[p1++];<br><span class="hljs-keyword">else</span> tmp[pt++] = ori[p2++];<br>&#125;<br><span class="hljs-keyword">while</span> (p1 &lt;= m) tmp[pt++] = ori[p1++];<br><span class="hljs-keyword">while</span> (p2 &lt;= e) tmp[pt++] = ori[p2++];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; pt ; i ++)<br>ori[s + i] = tmp[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> tmp[])</span> </span>&#123;<br><span class="hljs-type">int</span> m = s + (e - s) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (e &gt; s) &#123; <span class="hljs-comment">//终止条件</span><br><span class="hljs-built_in">merge_sort</span>(ori, s, m, tmp); <span class="hljs-comment">//切成两半，分别排序；</span><br><span class="hljs-built_in">merge_sort</span>(ori, m + <span class="hljs-number">1</span>, e, tmp);<br><span class="hljs-built_in">merge</span>(ori, s, e, tmp); <span class="hljs-comment">//合并排序好的两半</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v, vector&lt;<span class="hljs-type">int</span> &gt; &amp; tep, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s &gt;= e) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid = (s+e)/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> i = s;<br><span class="hljs-type">int</span> j = mid<span class="hljs-number">+1</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= e)&#123;<br><span class="hljs-keyword">if</span>(v[i] &lt; v[j]) tep[k++] = v[i++];<br><span class="hljs-keyword">else</span> tep[k++] = v[j++];<br>&#125;<br><span class="hljs-keyword">while</span>(i &lt;= mid) tep[k++] = v[i++];<br><span class="hljs-keyword">while</span>(j &lt;= e) tep[k++] = v[j++];<br><br><span class="hljs-type">int</span> p = s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; k ; i ++)&#123;<br>v[p++] = tep[i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v, vector&lt;<span class="hljs-type">int</span> &gt; &amp; tep,<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s &gt;= e) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid = (s+e)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">mergeSort</span>(v, tep, s, mid);<br><span class="hljs-built_in">mergeSort</span>(v, tep, mid<span class="hljs-number">+1</span>, e);<br><span class="hljs-built_in">merge</span>(v, tep, s, e);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序">快速排序</h1><blockquote><p>时间复杂度取决于原数组的有序程度，完全有序时恶化到<span class="math inline">\(n^2\)</span></p><p>最好是<span class="math inline">\(O(nlogn)\)</span>，最差是<span class="math inline">\(O(n^2)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> ori[],<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(s &gt;= e) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> k = ori[s];<br><span class="hljs-type">int</span> i = s;<br><span class="hljs-type">int</span> j = e;<br><span class="hljs-keyword">while</span>(i != j)<br>&#123;<br><span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; ori[j] &gt;= k) j--;<br><span class="hljs-built_in">swap</span>(ori[i],ori[j]);<br><span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; ori[i] &lt;= k) i++;<br>        <span class="hljs-built_in">swap</span>(ori[i],ori[j]);<br>&#125;<br><span class="hljs-built_in">quick_sort</span>(ori,s,i<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">quick_sort</span>(ori,i<span class="hljs-number">+1</span>,e);<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span> &gt; &amp; v, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s &gt;= e) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> k = v[s];<br><span class="hljs-type">int</span> i = s;<br><span class="hljs-type">int</span> j = e;<br><span class="hljs-keyword">while</span>(i != j)&#123;<br><span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; v[j] &gt;= k) j--;<br><span class="hljs-built_in">swap</span>(v[j], v[i]);<br><span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; v[i] &lt;= k) i++;<br><span class="hljs-built_in">swap</span>(v[i], v[j]);<br>&#125;<br><span class="hljs-built_in">quickSort</span>(v, s, i<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">quickSort</span>(v, i<span class="hljs-number">+1</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序">堆排序</h1><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序- dreamcatcher-cx - 博客园 (cnblogs.com)</a></p><p>模板题：<a href="https://www.luogu.com.cn/problem/P3378">P3378【模板】堆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><blockquote><p>堆的定义：一棵完全二叉树，每个节点的值总是 &gt;= 或 &lt;=其父节点的值</p><p>堆排序的时间复杂度：<span class="math inline">\(O(nlogn)\)</span></p></blockquote><figure><img src="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/1024555-20161217182750011-675658660.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E6%8E%92%E5%BA%8F%E6%B1%87%E6%80%BB/1024555-20161217182857323-2092264199.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>大顶堆：<span class="math inline">\(arr[i] &gt;= arr[2i+1]\)</span>&amp;&amp; <span class="math inline">\(arr[i] &gt;=arr[2i+2]\)</span></p><p>小顶堆：<span class="math inline">\(arr[i] &lt;= arr[2i+1]\)</span>&amp;&amp; <span class="math inline">\(arr[i] &lt;=arr[2i+2]\)</span></p></blockquote><p>堆排序的基本思路：</p><p>1.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p><p>2.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</p><p>3.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p><h2 id="手写堆">手写堆</h2><p>以小根堆为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//从某点（坐标）向下调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">justDown</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-type">int</span> now = p;<br><span class="hljs-keyword">while</span>(now &lt;= siz)&#123;<br><span class="hljs-type">int</span> t = now;<br><span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*now &lt;= siz &amp;&amp; heap[<span class="hljs-number">2</span>*now] &lt; heap[t]) t = <span class="hljs-number">2</span>*now;<br><span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*now<span class="hljs-number">+1</span> &lt;= siz &amp;&amp; heap[<span class="hljs-number">2</span>*now<span class="hljs-number">+1</span>] &lt; heap[t]) t = <span class="hljs-number">2</span>*now<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">if</span>(t != now)&#123;<br><span class="hljs-built_in">swap</span>(heap[t], heap[now]);<br>now = t;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//从某点（坐标）向上调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">justUp</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-type">int</span> now = p;<br><span class="hljs-keyword">while</span>(now &gt;= <span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">int</span> f = now/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(f &gt;= <span class="hljs-number">1</span> &amp;&amp; heap[f] &gt;= heap[now])&#123;<br><span class="hljs-built_in">swap</span>(heap[now], heap[f]);<br>now = f;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//直接建堆</span><br><span class="hljs-comment">//读入无序数组</span><br><span class="hljs-comment">//从n/2(最后一个非根节点)开始，逐个向上调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>siz = n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;heap[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n/<span class="hljs-number">2</span> ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br><span class="hljs-built_in">justDown</span>(i);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//插入操作</span><br><span class="hljs-comment">//插入一个元素到堆末，从新位置向上调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>heap[++siz] = x;<br><span class="hljs-built_in">justUp</span>(siz);<br>&#125;<br><br><span class="hljs-comment">//得到最小值，即heap[1]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(siz &gt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> heap[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//删除最小值</span><br><span class="hljs-comment">//删除后需要将heap[1]置换为堆末元素，并向下调整</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(siz)&#123;<br>heap[<span class="hljs-number">1</span>] = heap[siz--];<br><span class="hljs-built_in">justDown</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stlpriority_queue">STL：priority_queue</h2><blockquote><p>一般情况下用STL的pq就可以实现堆</p><p>缺点：只能删除堆顶元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq; <span class="hljs-comment">//默认大根堆</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt; pq; <span class="hljs-comment">//大根堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; pq; <span class="hljs-comment">//小根堆;</span><br><br>q.<span class="hljs-built_in">top</span>()<span class="hljs-comment">//取得堆顶元素，并不会弹出</span><br>q.<span class="hljs-built_in">pop</span>()<span class="hljs-comment">//弹出堆顶元素</span><br>q.<span class="hljs-built_in">push</span>()<span class="hljs-comment">//往堆里面插入一个元素</span><br>q.<span class="hljs-built_in">empty</span>()<span class="hljs-comment">//查询堆是否为空，为空则返回1否则返回0</span><br>q.<span class="hljs-built_in">size</span>()<span class="hljs-comment">//查询堆内元素数量</span><br><br><span class="hljs-comment">//存储结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span>&#123;    <br>    <span class="hljs-type">int</span> x,y;    <br>    <span class="hljs-type">int</span> times;    <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (point a, point b)&#123;    <br>        <span class="hljs-keyword">return</span> a.times &gt; b.times;    <span class="hljs-comment">//重载小于号使得小的先出队列    </span><br>    &#125;<br>&#125;priority_queue&lt;point&gt; q;<br></code></pre></td></tr></table></figure><h2 id="判断堆">判断堆</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805342821531648&amp;page=1">1147Heaps - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">judge</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 1 - 大根堆，2 - 小根堆，3 - 非堆</span><br><span class="hljs-type">bool</span> ma,mi;<br>ma = mi = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> l = i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> r = i*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>((l &lt; n &amp;&amp; layer[l] &gt; layer[i]) || (r &lt; n &amp;&amp; layer[r] &gt; layer[i]))&#123;<br>ma = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ma) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-type">int</span> l = i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> r = i*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>((l &lt; n &amp;&amp; layer[l] &lt; layer[i]) || (r &lt; n &amp;&amp; layer[r] &lt; layer[i]))&#123;<br>mi = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(mi) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂、矩阵快速幂</title>
    <link href="/algorithm/%E5%88%86%E6%B2%BB/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/algorithm/%E5%88%86%E6%B2%BB/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h1 id="快速幂">快速幂</h1><p>时间复杂度：O (logN)</p><p>模板题：<a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149594&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 快速幂 - 蓝桥云课 (lanqiao.cn)</a></p><p>二进制解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll n)</span></span>&#123;<br>ll ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n)&#123;<br><span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) ans = (ans*a)%MOD;<br>a = (a*a)%MOD;<br>n &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">const</span> ll &amp; a,<span class="hljs-type">const</span> ll &amp; n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">return</span> (<span class="hljs-built_in">qpow</span>(a,n<span class="hljs-number">-1</span>)*a) % MOD;<br><span class="hljs-keyword">else</span>&#123;<br>ll temp = <span class="hljs-built_in">qpow</span>(a,n/<span class="hljs-number">2</span>) % MOD;<br><span class="hljs-keyword">return</span> (temp*temp) % MOD;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="矩阵快速幂">矩阵快速幂</h1><h2 id="基础">基础</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3390">P3390【模板】矩阵快速幂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p><strong>矩阵</strong></p><p>要求矩阵的幂，我们首先要有一个 NxN的矩阵结构体，并重定义矩阵的乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll n;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">matrix</span>&#123;<br>ll a[maxn][maxn];<br><span class="hljs-built_in">matrix</span>(ll e = <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br>a[i][j] = e*(i == j);<br>&#125;<br>&#125;<br>&#125;<br>matrix <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> matrix &amp; rhs)&#123;<br><span class="hljs-function">matrix <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; k &lt; n ; k ++)&#123;<br>res.a[i][j] = (res.a[i][j] + a[i][k]*rhs.a[k][j]) % mod;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>快速幂</strong></p><p>自定义矩阵乘法后，和整数快速幂类似地，我们可以得到如下的快速幂函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">matrix <span class="hljs-title">qpow</span><span class="hljs-params">(matrix m, ll t)</span></span>&#123;<br><span class="hljs-function">matrix <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">while</span>(t)&#123;<br><span class="hljs-keyword">if</span>(t &amp; <span class="hljs-number">1</span>) res = res*m;<br>m = m*m;<br>t &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>主函数</strong></p><p>求给定矩阵的k次幂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-function">matrix <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; n ; j ++)&#123;<br>        cin&gt;&gt;temp.a[i][j];<br>    &#125;<br>&#125;<br>matrix ans = <span class="hljs-built_in">qpow</span>(temp,k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    cout&lt;&lt;ans.a[i][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt; n ; j ++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans.a[i][j];<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求斐波那契数列">求斐波那契数列</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149720&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 斐波那契数列 - 蓝桥云课 (lanqiao.cn)</a></p><p>矩阵快速幂可以以 指数级 加速求和操作，例如：求斐波那契数列。</p><p>由</p><figure><img src="/algorithm/%E5%88%86%E6%B2%BB/%E5%BF%AB%E9%80%9F%E5%B9%82/formula.png" alt="fib"><figcaption aria-hidden="true">fib</figcaption></figure><p>我们可以得到公式： <span class="math display">\[\begin{bmatrix}F(n)\\F(n-1)\end{bmatrix} =\begin{bmatrix}  1 &amp; 1\\  1 &amp; 0\end{bmatrix}^{n-1} *\begin{bmatrix}  f(1) \\  f(0)  \end{bmatrix}\]</span></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">fib</span><span class="hljs-params">(ll x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span> || x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-function">matrix <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = res.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = res.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>res = <span class="hljs-built_in">qpow</span>(res,x<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> (res.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + res.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) % mod;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>分治</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度-加减乘</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/Z1tai/article/details/127681983?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-127681983-blog-99888441.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-127681983-blog-99888441.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=2">【算法模板】高精度模板（带图详解）SuhyOvO的博客-CSDN博客</a></p><h2 id="正整数加法">1.正整数加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">add</span><span class="hljs-params">(string x, string y)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br>    <br><span class="hljs-type">int</span> la = x.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lb = y.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> lc = <span class="hljs-built_in">max</span>(la, lb); <span class="hljs-comment">//加起来的数的长度不会超过原先两个数的长度最大值</span><br>    <br><span class="hljs-comment">//逆置字符串，从低位到高位</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++)<br>a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lb; i++)<br>b[i] = y[lb - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lc; i++) &#123; <span class="hljs-comment">//其实就是竖式计算</span><br>c[i] += a[i] + b[i]; <span class="hljs-comment">//两数相加，再加上前面计算的进位</span><br>c[i + <span class="hljs-number">1</span>] += c[i]/<span class="hljs-number">10</span>; <span class="hljs-comment">//把进位存到i+1位上</span><br>c[i] %= <span class="hljs-number">10</span>;<br>&#125;<br><br>lc++;<span class="hljs-comment">//如果有进位就多显示一位</span><br><span class="hljs-keyword">while</span> (lc &gt; <span class="hljs-number">1</span> &amp;&amp; c[lc<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>) lc--;<span class="hljs-comment">//去除前面的前导零,防止后面逆置输出多余的零</span><br><br><span class="hljs-comment">//重新逆置,从高位到低位</span><br>string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lc- <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">char</span>(c[i] + <span class="hljs-string">&#x27;0&#x27;</span>));<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="正整数减法">2.正整数减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">sub</span><span class="hljs-params">(string sa, string sb)</span></span>&#123;<br>    <br>   <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c));<br>la = sa.<span class="hljs-built_in">length</span>();<br>lb = ab.<span class="hljs-built_in">length</span>();<br>    lc = <span class="hljs-built_in">max</span>(la, lb);<span class="hljs-comment">//相减的数的长度不会超过原先两个数的长度最大值</span><br>    <br>    string sub = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span>(la &lt; lb || (la == lb &amp;&amp; (x[la<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span> &lt; y[lb<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>)))&#123;<br><span class="hljs-built_in">swap</span>(la, lb);<br><span class="hljs-built_in">swap</span>(sa, sb);<br>sub = <span class="hljs-string">&quot;-&quot;</span>;<br>&#125;<br>    <br><span class="hljs-comment">//逆置字符串，从低位到高位</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++)<br>a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lb; i++)<br>b[i] = y[lb - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lc; i++) &#123;<br><span class="hljs-keyword">if</span> (a[i] &lt; b[i]) &#123;<br>a[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<span class="hljs-comment">//向高一位借位</span><br>a[i] += <span class="hljs-number">10</span>;<span class="hljs-comment">//给当前位加10</span><br>&#125;<br>c[i] = a[i] - b[i];<span class="hljs-comment">//再两数相减</span><br>&#125;<br><br><span class="hljs-keyword">while</span> ((c[lc - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (lc &gt; <span class="hljs-number">1</span>)) lc--;<span class="hljs-comment">//去除前面的前导零,防止后面逆置输出多余的零</span><br><br><span class="hljs-comment">//重新逆置,从高位到低位</span><br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lc<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>res.<span class="hljs-built_in">push_back</span>(c[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> sub + res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精乘低精">3.高精乘低精</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">mul</span><span class="hljs-params">(string x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>la = x.<span class="hljs-built_in">length</span>();<br>string ans = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//对负号的处理</span><br>x = x.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, la);<br>la--;<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y &lt; <span class="hljs-number">0</span>) &#123;<br>y = <span class="hljs-built_in">abs</span>(y);<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y &lt; <span class="hljs-number">0</span>) &#123;<br>x = x.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, la);<br>la--;<br>y = <span class="hljs-built_in">abs</span>(y);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++) &#123;<br>a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++) &#123;<br>a[i] = a[i] * y + tmp; <span class="hljs-comment">//运算</span><br>tmp = a[i] / <span class="hljs-number">10</span>;<span class="hljs-comment">//进位</span><br>a[i] %= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-comment">//进位不为0</span><br><span class="hljs-keyword">if</span> (tmp != <span class="hljs-number">0</span>) &#123;<br>a[la++] = tmp;<br><span class="hljs-keyword">while</span> (a[la - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//刚存进去的进位，判断是否大于10需要进位</span><br>a[la] = a[la - <span class="hljs-number">1</span>] / <span class="hljs-number">10</span>;<br>a[la - <span class="hljs-number">1</span>] %= <span class="hljs-number">10</span>;<br>la++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> ((a[la - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (la &gt; <span class="hljs-number">1</span>)) la--;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = la - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>ans.<span class="hljs-built_in">push_back</span>(a[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精乘高精">4.高精乘高精</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">High_Mul</span><span class="hljs-params">(string x, string  y)</span> </span>&#123;<br>string ans = <span class="hljs-string">&quot;&quot;</span>;<br>la = x.<span class="hljs-built_in">length</span>();<br>lb = y.<span class="hljs-built_in">length</span>();<br><br><span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span>) &#123; <span class="hljs-comment">//对负号的处理</span><br>x = x.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,la--);<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>y = y.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,lb--);<br>ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; y[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>x = x.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,la--);<br>y = y.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,lb--);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++)<br>a[i] = x[la - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lb; i++)<br>b[i] = y[lb - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><br><span class="hljs-comment">//长度最大变成两个数的长度之和</span><br>lc = la + lb ;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; la; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; lb; j++) &#123;<br>c[i + j] += a[i] * b[j];<span class="hljs-comment">//两数相乘，存到对应位置</span><br>c[i + j + <span class="hljs-number">1</span>] += c[i + j] / <span class="hljs-number">10</span>;<span class="hljs-comment">//把进位加到前面一位上</span><br>c[i + j] %= <span class="hljs-number">10</span>;<span class="hljs-comment">//取模存0-9的数</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> ((c[lc - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (lc &gt; <span class="hljs-number">1</span>)) lc--;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lc- <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>ans.<span class="hljs-built_in">push_back</span>(c[i] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精除以低精">5.高精除以低精</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">未完待续。。。≡(▔﹏▔)≡<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>其他算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串匹配算法BF和KMP</title>
    <link href="/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <url>/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="bf朴素匹配">BF朴素匹配</h1><p>时间复杂度 <span class="math inline">\(O(n*m)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BF_Search</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;txt,<span class="hljs-type">const</span> string &amp;pat)</span></span>&#123; <span class="hljs-comment">//匹配成功，返回下标，否则返回-1</span><br><span class="hljs-type">int</span> lt = txt.<span class="hljs-built_in">length</span>(); <br><span class="hljs-type">int</span> lp = pat.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; lt &amp;&amp; j &lt; lp)&#123;<br><span class="hljs-keyword">if</span>(txt[i] == pat[j]) &#123;i++ ; j++;&#125;<br><span class="hljs-keyword">else</span> &#123;i -= j<span class="hljs-number">-1</span> ; j = <span class="hljs-number">0</span>;&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(j == lp) <span class="hljs-keyword">return</span> i-lp;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="kmp算法">KMP算法</h1><p>时间复杂度 $ O(n+m)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 1000</span><br><span class="hljs-type">int</span> Next[MAXLEN];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;pat,<span class="hljs-type">int</span> Prefix[])</span></span>&#123;<br><span class="hljs-type">int</span> len = pat.<span class="hljs-built_in">length</span>();<br>    Prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 这里的Prefix[i]是以i为末位的最长公共前后缀</span><br>    <span class="hljs-comment">// 因为前后缀不允许重叠，所以Prefix[0]必然为0，作为终止条件</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i ++)&#123;<br><span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; pat[i] != pat[j])&#123;j = Prefix[j<span class="hljs-number">-1</span>];&#125;<span class="hljs-comment">//当pat[i] != pat[j]时，需要将j回退到Prefix[j-1]（这是公共前后缀更短的唯一的可能性，避免了重复计算）。若此处的j已经回退到0,则没有更短的可能，循环终止。</span><br><span class="hljs-keyword">if</span>(pat[i] == pat[j])&#123;j++;&#125; <span class="hljs-comment">//若相等，继续遍历</span><br>Prefix[i] = j; <span class="hljs-comment">//记录Prefix[i]</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMP_Search</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;txt,<span class="hljs-type">const</span> string &amp;pat)</span></span>&#123;<br><span class="hljs-type">int</span> lt = txt.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lp = pat.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">//i是后缀末尾</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">//j是前缀末尾</span><br><span class="hljs-keyword">while</span>(i &lt; lt &amp;&amp; j &lt; lp)&#123; <span class="hljs-comment">//如果i == lt,说明找不到pat；如果j == lp，说明找到了</span><br><span class="hljs-keyword">if</span>(txt[i] == pat[j])&#123;i++;j++;&#125;<span class="hljs-comment">//如果相等，继续匹配下一位</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) i++; <br><span class="hljs-keyword">else</span> &#123;j = Next[j<span class="hljs-number">-1</span>];&#125;<span class="hljs-comment">//否则，j回退到Next[j-1];</span><br>&#125;<br><span class="hljs-keyword">if</span>(j == lp) <span class="hljs-keyword">return</span> i-lp; <span class="hljs-comment">//如果找到，返回i-lp，即pat在txt中的首下标</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//如果没找到，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>KMP统计子串个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMPSearchCount</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp; txt,<span class="hljs-type">const</span> string &amp; pat)</span></span>&#123;<br><span class="hljs-type">int</span> lt = txt.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> lp = pat.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; lt &amp;&amp; j &lt; lp)&#123;<br><span class="hljs-keyword">if</span>(txt[i] == pat[j])&#123;i++;j++;&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> )&#123;i++;&#125;<br><span class="hljs-keyword">else</span> &#123;j = Prefix[j<span class="hljs-number">-1</span>];&#125;<br><span class="hljs-keyword">if</span>(j == lp)&#123;i -= (lp<span class="hljs-number">-1</span>);j=<span class="hljs-number">0</span>;cnt++;&#125;<span class="hljs-comment">//主要是这里改动了一句</span><br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模板题">模板题</h1><p><a href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP -洛谷 | 计算机科学教育新生态</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e6</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> Next[maxn],lp,lt;<br><span class="hljs-type">bool</span> f[maxn];<br>string pat,txt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span>&#123;<br>Next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span> ; i &lt; lp ; i ++)&#123;<br><span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; pat[j] != pat[i])&#123;j = Next[j<span class="hljs-number">-1</span>];&#125;;<br><span class="hljs-keyword">if</span>(pat[j] == pat[i])&#123;j++;&#125;<br>Next[i] = j;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">kmp</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; lt &amp;&amp; j &lt; lp)&#123;<br><span class="hljs-keyword">if</span>(txt[i] == pat[j])&#123;i++;j++;&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span>) &#123;j = Next[j<span class="hljs-number">-1</span>];&#125;<br><span class="hljs-keyword">else</span> &#123;i++;&#125;<br><span class="hljs-keyword">if</span>(j == lp)&#123;f[i-lp] = <span class="hljs-literal">true</span>; i -= (lp<span class="hljs-number">-1</span>); j = <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-comment">// 注意这里i不能++,而是 -= lp-1, 前者会遗漏重叠部分</span><br>&#125;<br><span class="hljs-keyword">return</span> j == lp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;txt&gt;&gt;pat;<br>lt = txt.<span class="hljs-built_in">length</span>();<br>lp = pat.<span class="hljs-built_in">length</span>();<br><span class="hljs-built_in">getNext</span>(); <span class="hljs-built_in">kmp</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; lt ; i ++)&#123;<br><span class="hljs-keyword">if</span>(f[i]) cout&lt;&lt;i<span class="hljs-number">+1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; lp ; i ++)&#123;<br>cout&lt;&lt;Next[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算几何基础</title>
    <link href="/algorithm/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/"/>
    <url>/algorithm/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="判断两点是否在同一对角线上">判断两点是否在同一对角线上</h1><p>给定两个点 A(x1,y1) 和 B(x2,y2) B(x2,y2)</p><p>若<code>abs(x1 - x2) == abs(y1 - y2)</code>，两点同一条对角线（/）上。</p><p>若<code>x1 - y1 == x2 - y2</code>，两点在主对角线  上。</p><p>若<code>x1 + y1 == x2 + y2</code>，两点在次对角线 / 上。</p><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805348915855360&amp;page=1">1128N Queens Puzzle - PAT (Advanced Level) Practice (pintia.cn)</a></p><p>以N皇后问题为例：</p><p>O(n2)写法，较为简便，但效率低</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">//这里i表示行，col[i]表示列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(col[i] == col[j] || <span class="hljs-built_in">abs</span>(i - j) == <span class="hljs-built_in">abs</span>(col[i] - col[j]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>O(n)写法，哈希优化，较为繁琐，但效率高</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//这里i表示行，col[i]表示列</span><br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">//列</span><br>        <span class="hljs-keyword">if</span>(vis[col[i]]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vis[col[i]] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">//主对角线</span><br>        <span class="hljs-type">int</span> tep = i - col[i] + <span class="hljs-number">1500</span>;<br>        <span class="hljs-keyword">if</span>(vis[tep]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vis[tep] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123; <span class="hljs-comment">//次对角线</span><br>        <span class="hljs-type">int</span> tep = i + col[i];<br>        <span class="hljs-keyword">if</span>(vis[tep]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vis[tep] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>计算几何</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平面最近点对</title>
    <link href="/algorithm/%E5%88%86%E6%B2%BB/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/"/>
    <url>/algorithm/%E5%88%86%E6%B2%BB/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<p>模板题</p><p><a href="https://www.luogu.com.cn/problem/P1429">P1429平面最近点对（加强版） - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><p><a href="https://www.luogu.com.cn/problem/P7883">P7883平面最近点对（加强加强版） - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><h1 id="题解">题解</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">400010</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span>&#123;<br><span class="hljs-type">double</span> x,y;<br>&#125;p[MAX];<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">double</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - b) &lt;= <span class="hljs-number">1e-6</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpx</span><span class="hljs-params">(point &amp;a, point &amp;b)</span></span>&#123; <span class="hljs-comment">//按x排序</span><br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">equal</span>(a.x, b.x)) <span class="hljs-keyword">return</span> a.x &lt; b.x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.y &lt; b.y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpy</span><span class="hljs-params">(point &amp;a, point &amp;b)</span></span>&#123; <span class="hljs-comment">//按y排序</span><br><span class="hljs-keyword">return</span> a.y &lt; b.y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dist</span><span class="hljs-params">(point &amp;a, point &amp;b)</span></span>&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-type">double</span> res = <span class="hljs-number">1e300</span>;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br><span class="hljs-keyword">return</span> res;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-type">double</span> midx = p[mid].x;<br>res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">solve</span>(l, mid)); <span class="hljs-comment">//左侧最小距离</span><br>res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">solve</span>(mid<span class="hljs-number">+1</span>, r)); <span class="hljs-comment">//右侧最小距离</span><br>        <span class="hljs-comment">//两点分别位于左右两侧的最小距离</span><br>vector&lt;point&gt; v;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l ; i &lt;= r ; i ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(p[i].x - midx) &lt;= res)&#123;<br>v.<span class="hljs-built_in">push_back</span>(p[i]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmpy);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; v.<span class="hljs-built_in">size</span>() ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt; v.<span class="hljs-built_in">size</span>() &amp;&amp; v[j].y - v[i].y &lt; res; j ++)&#123;<br>res = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">dist</span>(v[i], v[j]), res);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf&quot;</span>, &amp;p[i].x , &amp;p[i].y);<br>&#125;<br><span class="hljs-built_in">sort</span>(p,p+n, cmpx);<br>ans = <span class="hljs-built_in">solve</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.lf&quot;</span>, ans*ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>分治</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状压DP</title>
    <link href="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"/>
    <url>/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/</url>
    
    <content type="html"><![CDATA[<h2 id="糖果">糖果</h2><p>原题 ：<a href="https://www.lanqiao.cn/problems/186/learning/?page=3&amp;first_category_id=1&amp;sort=students_count&amp;name=糖果">4.糖果- 蓝桥云课 (lanqiao.cn)</a></p><p>给n包糖果，共有m种糖果，每包糖果包含k种不同的糖果。现在给出每包糖果的组合，求最少买多少包糖果得到所有类别的糖果。</p><p>设dp[i]为 01状态 i（1表示有，0表示无）下，所需购买的最少糖果包数量。</p><p>状态转移方程为： <span class="math display">\[dp[i\space|\space a[i]] = min(dp[i \space|\space a[i]], dp[i] + 1)\]</span> 和01背包很像，就是从 拿 和 不拿 两种状态转移过来。</p><p>这里的a[i]表示某一包糖果中包含糖果的种类，也用01串表示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= k ; j ++)&#123;<br>        <span class="hljs-type">int</span> t;cin&gt;&gt;t;<br>        a[i] = a[i]|(<span class="hljs-number">1</span>&lt;&lt;(t<span class="hljs-number">-1</span>));<br>    &#125;<br>&#125;<br><span class="hljs-built_in">memset</span>(dp, inf, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= (<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span> ; j ++)&#123;<br>        dp[j|a[i]] = <span class="hljs-built_in">min</span>(dp[j|a[i]], dp[j]<span class="hljs-number">+1</span>);<br>    &#125;<br>&#125;<br>cout&lt;&lt;(dp[(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>] == inf ? <span class="hljs-number">-1</span>:dp[(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>]);<br></code></pre></td></tr></table></figure><h2 id="互不侵犯">互不侵犯</h2><p><a href="https://www.luogu.com.cn/problem/P1896">SCOI2005 互不侵犯 -洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给 NxN个格子，放置K个国王，每个国王可以攻击到自己周围的8个格子，求国王之间互相无法攻击的总方案数。</p><p>dp{i, j, s} 表示 到第 i 行，第i行的状态为sit[j],包括第i行在内共放了s个皇帝。</p><p>状态转移方程： <span class="math display">\[dp[i][j][s] = \sum \sum dp[i-1][k][s-tol[j]]\]</span> 枚举当前状态i，上一行状态k 和总数量s，判断合法后，转移过来。</p><p>dfs初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// sit -&gt; 第i个行状态</span><br><span class="hljs-comment">// tol -&gt; 第i个行状态下的数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &gt; n)&#123;<br>sit[++cnt] = s;<br>tol[cnt] = sum;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">dfs</span>(s,sum,x<span class="hljs-number">+1</span>);<br><span class="hljs-built_in">dfs</span>(s|(<span class="hljs-number">1</span>&lt;&lt;(x<span class="hljs-number">-1</span>)),sum<span class="hljs-number">+1</span>,x<span class="hljs-number">+2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(sit[a] &amp; sit[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>((sit[a]&lt;&lt;<span class="hljs-number">1</span>) &amp; sit[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>((sit[b]&lt;&lt;<span class="hljs-number">1</span>) &amp; sit[a]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= cnt ; i ++)&#123;<br>    dp[<span class="hljs-number">1</span>][i][tol[i]] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= cnt ; j ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r &lt;= cnt ; r ++)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(j, r)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = k ; s &gt;= tol[j] ; s--)&#123;<br>                dp[i][j][s] += dp[i<span class="hljs-number">-1</span>][r][s-tol[j]];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= cnt ; i ++)&#123;<br>    ans += dp[n][i][k];<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="最短哈密顿回路tsp">最短哈密顿回路（TSP）</h2><p><a href="https://www.luogu.com.cn/problem/P1171">P1171 售货员的难题 -洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>位运算基础</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//集合 s 代表当前集合</span><br><span class="hljs-comment">//右数 k 位二进制数 0/1 代表 第 k 号元素 不在集合 / 在集合 里 </span><br><br><span class="hljs-comment">//必备操作1： </span><br><span class="hljs-comment">//将第k个元素加入集合</span><br>s | (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//必备操作2：</span><br><span class="hljs-comment">//将第k个元素从集合中删除</span><br>s &amp; (~ (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>)) );<br><br><span class="hljs-comment">//必备操作3：</span><br><span class="hljs-comment">//1)如果第k个元素在 集合s里， 删除它</span><br><span class="hljs-comment">//2)如果不在，把它加入集合s</span><br><span class="hljs-comment">//可以想象成一盏灯的开关:</span><br><span class="hljs-comment">//按下开关， 明 -&gt; 暗， 暗 -&gt; 明 </span><br>s ^ (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//必备操作4:</span><br><span class="hljs-comment">//判断元素k 是否在集合s里</span><br><span class="hljs-comment">//在：返回1，不在：返回0 </span><br>(s &gt;&gt; (k - <span class="hljs-number">1</span>)) &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>dp{S, V}中S表示经过的点，V表示当前S中的最后一个点。</p><p>首先，枚举每个状态S，取S中未到达的点V，和S中已经到达的点U，更新dp{S，V}</p><p>最后，再利用DP[（1&lt;&lt;n） - 1] [V] ,判断最后回到起点的最短距离</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> dp[MAX][<span class="hljs-number">21</span>],e[<span class="hljs-number">21</span>][<span class="hljs-number">21</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= n ; j ++)&#123;<br>cin&gt;&gt;e[i][j];<br>&#125;<br>&#125;<br><span class="hljs-built_in">memset</span>(dp,INF,<span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//状态 （s，v）；</span><br><span class="hljs-comment">//下一步的点 u</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span> ; s &lt;= (<span class="hljs-number">1</span>&lt;&lt;n) - <span class="hljs-number">1</span> ; s ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">1</span> ; u &lt;= n ; u ++)&#123;<br><span class="hljs-keyword">if</span>( !( s &amp; (<span class="hljs-number">1</span> &lt;&lt; u<span class="hljs-number">-1</span>) ))&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">1</span> ; v &lt;= n ; v ++)&#123;<br><span class="hljs-keyword">if</span>( s &amp; (<span class="hljs-number">1</span> &lt;&lt; v<span class="hljs-number">-1</span>) )&#123;<br>dp[s| (<span class="hljs-number">1</span> &lt;&lt; u<span class="hljs-number">-1</span>) ][u] = <span class="hljs-built_in">min</span>(dp[s | (<span class="hljs-number">1</span> &lt;&lt; u<span class="hljs-number">-1</span>)][u], <br>                                                    dp[s][v] + e[v][u]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>ans = INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>ans = <span class="hljs-built_in">min</span>(dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i] + e[i][<span class="hljs-number">1</span>], ans);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形DP</title>
    <link href="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/"/>
    <url>/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2DP/</url>
    
    <content type="html"><![CDATA[<p>树形DP题单：<a href="https://www.luogu.com.cn/training/13994#information">0x2 树形dp -题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><h1 id="最大点权独立集">最大点权独立集</h1><p>模板题：<a href="https://www.luogu.com.cn/problem/P1352">P1352没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149664&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 蓝桥舞会 - 蓝桥云课 (lanqiao.cn)</a></p><p>给一棵n个节点的树，每个节点都有一个权值，要找到一个结点集，使得<strong>树的每条边的两端，不能同时都一个在集合</strong>里，同时<strong>集合权值和最大</strong>。</p><p>说明：这种适用于一张图（选了一个节点，就不能选它相连的邻居）</p><p>解法：创建一个dp[n][2]数组，dp{j，0} 就表示以 j 为根的子树不选 j的最大价值；dp{j，1}表示选 j 的最大价值。</p><p>若选择一个节点的权值，其子节点就无法被选取；若不选择，其子节点可以选，也可以不选。</p><p>由此，我们可以得到如下的转移方程： <span class="math display">\[dp[j, 0] = \sum_{i}^{son} \max(dp[i, 0], dp[i,1]) \newlinedp[j, 1] = \sum_{i}^{son} dp[i, 0]\]</span> DFS遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it == f) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(it, x);<br>        <span class="hljs-comment">// 此时，子节点已经处理好</span><br>dp[x][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[it][<span class="hljs-number">1</span>], dp[it][<span class="hljs-number">0</span>]);<br>dp[x][<span class="hljs-number">1</span>] += dp[it][<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-comment">// 输入权值，初始化DP</span><br>    cin&gt;&gt;dp[i][<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br>    <span class="hljs-type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;<br>    e[y].<span class="hljs-built_in">push_back</span>(x);<br>    e[x].<span class="hljs-built_in">push_back</span>(y);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h1 id="最小点权覆盖集">最小点权覆盖集</h1><p>模板题：<a href="https://www.luogu.com.cn/problem/P2016">P2016战略游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给一棵n个节点的树，每个节点的都有权值，要找到一个结点集，使得<strong>树的每条边的两端，至少有一个在集合里</strong>，同时使得<strong>集合权值和最小</strong>。（这题的节点权值为1）</p><p>和最大点权独立集类似：一个节点若选择，其邻居可以选，也可以不选；一个节点若不选，其邻居一定选。</p><p>状态转移方程如下： <span class="math display">\[dp[j,1] = \sum_{i}^{son} min(dp[i,0],dp[i,1]) \newlinedp[j,0] = \sum_{i}^{son} dp[i,1]\]</span> DFS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it == f) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(it, x);<br>dp[x][<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(dp[it][<span class="hljs-number">1</span>], dp[it][<span class="hljs-number">0</span>]);<br>dp[x][<span class="hljs-number">0</span>] += dp[it][<span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-type">int</span> x,m;cin&gt;&gt;x&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; m ; j ++)&#123;<br>        <span class="hljs-type">int</span> y;cin&gt;&gt;y;<br>        e[x].<span class="hljs-built_in">push_back</span>(y);<br>        e[y].<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// DP初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//DP</span><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>cout&lt;&lt;<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h1 id="树上背包">树上背包</h1><p>模板题：<a href="https://www.luogu.com.cn/problem/P2014">CTSC1997选课 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>树上背包，也叫 有依赖关系的背包问题。</p><p><strong>题意：</strong>给一个n节点的森林，标号从1-n，每个节点存在一个权值。对这个森林内的每棵有向树，都要求出一条从根出发的路径，所有路径的节点数量和不超过m，同时节点权值和最大。</p><p>首先，设置一个超点0，连接0和每一棵树的根。这样就把n条路径的问题，转化为求0出发的一条路径。</p><p>然后，我们设置一个状态DP数组，dp{u, k} 表示以u节点为根，容量为k的最大权值和。有如下的状态转移方程： <span class="math display">\[dp[x, j] = max(dp[x,j], dp[x, j-k] + dp[it][k])\]</span> 此处，x表示父节点，it表示子节点，j 和 k 分别表示到两个节点剩下的容量。</p><p>最后，dfs更新dp数组，我们可以得到ans == dp[0][m]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">305</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> dp[maxn][maxn];<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-built_in">dfs</span>(it);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br><span class="hljs-comment">// j不可以 == k</span><br><span class="hljs-comment">// 因为至少要学习父节点，才能学子节点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span> ; k &lt; j ; k ++)&#123;<br>dp[x][j] = <span class="hljs-built_in">max</span>(dp[x][j], dp[x][j-k] + dp[it][k]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br>m++;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-type">int</span> x,v;cin&gt;&gt;x&gt;&gt;v;<br>e[x].<span class="hljs-built_in">push_back</span>(i);<br>        dp[i][<span class="hljs-number">1</span>] = v;<br>        <span class="hljs-comment">// 如果不是必须要刚好修m门课，应该这么写：</span><br><span class="hljs-comment">// for(int j = 1 ; j &lt;= m ; j ++)&#123;</span><br><span class="hljs-comment">//dp[i][j] = v;</span><br><span class="hljs-comment">// &#125;</span><br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>cout&lt;&lt;dp[<span class="hljs-number">0</span>][m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="换根dp">换根DP</h1><p>模板题： <a href="https://www.luogu.com.cn/problem/P3478">POI2008STA-Station - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给定一个 n个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。</p><p>（一个结点的深度之定义为该节点到根的简单路径上边的数量）</p><p>分析：</p><p>对于一个父节点x，和它的子节点y，</p><p>扭转了x和y的位置以后，y以下（含y）的全部节点（siz[y]）深度都要 -1，其他节点（n-siz[y]）的深度都要 + 1</p><p>假设我们已经知道了以x为根的深度和dp[x]，和分别以x，y为根的子树节点数siz[x], siz[y]。</p><p>那么，我们可以通过如下的状态转移方程，得到dp[y]： <span class="math display">\[dp[y] = dp[x] + (n - siz[y]) - siz[y]\]</span> dfs函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 首先，我们dfs求出：以节点1为根时，每棵子树总节点数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll x, ll f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it == f) <span class="hljs-keyword">continue</span>;<br>depth[it] = depth[x] + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(it, x);<br>siz[x] += siz[it];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>reDfs函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 然后，再次dfs求出 以每个节点为根的深度和</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reDfs</span><span class="hljs-params">(ll x, ll f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it == f) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//dp[it] = dp[x] + (n - siz[it]) - siz[it]</span><br>dp[it] = dp[x] + n - <span class="hljs-number">2</span>*siz[it];<br><span class="hljs-built_in">reDfs</span>(it, x);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 建图</span><br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br>    ll u,v;cin&gt;&gt;u&gt;&gt;v;<br>    e[u].<span class="hljs-built_in">push_back</span>(v);<br>    e[v].<span class="hljs-built_in">push_back</span>(u);<br>&#125;<br><span class="hljs-comment">// dp求最值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) siz[i] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) dp[<span class="hljs-number">1</span>] += depth[i];<br><span class="hljs-built_in">reDfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(dp[i] &gt; max_)&#123;<br>        max_ = dp[i];<br>        ans = i;<br>    &#125;<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP</title>
    <link href="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/"/>
    <url>/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h1 id="区间dp">区间DP</h1><h2 id="石子合并">石子合并</h2><p>原题：<a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149673&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 石子合并 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n个石块，需要将所有石块合并为1块，每次合并的花销是两个石块的总重量，每次只能合并相邻的石块。</p><p>求合并的最小花销。设 dp{i, j} 为 合并 从 i 到 j个石块的最小花销，可以得到如下的状态转移方程。 <span class="math display">\[dp[i, j] = \min(dp[i][k] + dp[k+1][j] + sum(i, j) | i &lt;= k &lt; j)\]</span> 其中，k为将 [i, j]这一列石块合并的中间点。为了得到最优解，我们需要遍历每一个k。</p><p>注意：必须要以 [i, j]的区间长度 从小到大遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f3f3f3f</span> , <span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;prefix[i]<br>    prefix[i] += prefix[i<span class="hljs-number">-1</span>];<br>    dp[i][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span> ; l+i<span class="hljs-number">-1</span> &lt;= n ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>            dp[l][r] = <span class="hljs-built_in">min</span>(dp[l][r], dp[l][k] + dp[k<span class="hljs-number">+1</span>][r] + prefix[r] - prefix[l<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">1</span>][n];<br></code></pre></td></tr></table></figure><h2 id="涂色">涂色</h2><p>原题：<a href="https://www.lanqiao.cn/problems/926/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=926">1.涂色- 蓝桥云课 (lanqiao.cn)</a></p><p>​ <a href="https://www.luogu.com.cn/problem/P4170">CQOI2007 涂色 -洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给一个长度为n的字符串，每个字符代表一种颜色，比如：G代表绿，R代表红。每次涂色可以涂任意长度的区间，这一次的涂色会覆盖上一次的涂色。求最少的涂色次数。</p><p>设 dp{i, j} 为 正确涂色 从 i 到 j个石块的最少次数，得到状态转移方程： <span class="math display">\[\begin{cases}dp[i][j] = min(dp[i-1][j], dp[i][j-1]) &amp;s[i] == s[j] \\ \\dp[i][j] = min(dp[i][k] + dp[k+1][j]  \space|\space i&lt;=k&lt;j )&amp;s[i] != s[j]\end{cases}\]</span> 对于左右端点相同的情况，当前区间的最少次数等同于删去左端点/右端点 后仍需的涂色次数；</p><p>对于不相同的情况，则需要遍历每一种分解的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;s;<br>n = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f3f3f3f</span>,<span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++) dp[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">0</span> ; l+i<span class="hljs-number">-1</span> &lt; n ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(s[l] == s[r])&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">// 注意这里的特判</span><br>                dp[l][r] = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[l][r] = <span class="hljs-built_in">min</span>(dp[l<span class="hljs-number">+1</span>][r], dp[l][r<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>                dp[l][r] = <span class="hljs-built_in">min</span>(dp[l][r], dp[l][k] + dp[k<span class="hljs-number">+1</span>][r]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><h2 id="制作回文串">制作回文串</h2><p>原题：<a href="https://www.lanqiao.cn/problems/1547/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=1547">1.制作回文串- 蓝桥云课 (lanqiao.cn)</a></p><p>给一个长度为n的字符串，字符串有m种不同的字母构成，并给出每种字符插入和删除的花销。</p><p>求将这个字符串构造成回文串的最小花销。</p><p>设 dp{i, j} 为 构造 从 i 到 j区间的回文串所需的花销，得到状态转移方程： <span class="math display">\[\begin{cases}dp[i, j] = dp[i+1][j-1] &amp; s[i] == s[j]\\ \\dp[i, j] = min(dp[i+1][j] + cost[i], dp[i][j-1]+cost[j]) &amp; s[i] !=s[j]\end{cases}\]</span> 左右端点相同时，我们跳过两端；</p><p>不同时，我们选择删除一个花销较小的；</p><p>注意：由于对最终生成的字符串没有要求，插入和删除操作都是相同的，我们选择其中一个较小的即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;m&gt;&gt;n;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br>    <span class="hljs-type">char</span> c;cin&gt;&gt;c;<br>    <span class="hljs-type">int</span> w1,w2;cin&gt;&gt;w1&gt;&gt;w2;<br>    cost[<span class="hljs-built_in">int</span>(c)] = <span class="hljs-built_in">min</span>(w1,w2);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">0</span> ; l &lt; n ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(s[l] == s[r])&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">// 注意特判</span><br>                dp[l][r] = <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[l][r] = dp[l<span class="hljs-number">+1</span>][r<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[l][r] = <span class="hljs-built_in">min</span>(dp[l][r<span class="hljs-number">-1</span>] + cost[<span class="hljs-built_in">int</span>(s[r])], dp[l<span class="hljs-number">+1</span>][r] + cost[<span class="hljs-built_in">int</span>(s[l])]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><h2 id="石子合并2.0">石子合并2.0</h2><p>原题：<a href="https://www.luogu.com.cn/problem/P1880">NOI1995]石子合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>这题是一道经典的环形区间DP，与1.0的区别是，末尾的石子也可以和队首的石子合并，相当于把链 变成了 环 。</p><p>另外，这道题还要求同时求出 最大值 和 最小值。</p><p>对于 4，5，9，4 这个数组，最后的计算结果可能来自 (4,5,9),4,也可能来自 (4,5) (9,4)。但对于环状的情况，还可能是 (4,4)(5,9)等，类似的情况无法被考虑。</p><p>解决环状区间的办法是 退化为 两个连接的链状区间 来解决。</p><p>首先，我们将两个原数组相连，构造出：4 5 9 4, 4 5 9（末尾的4可以不要）</p><p>按原长度划分，可以得到如下四种情况：</p><p>dp(1,4) ==&gt;4 5 9 4</p><p>dp(2,5) ==&gt;5 9 4 4</p><p>dp(3,6) ==&gt;9 4 4 5</p><p>dp(4,7) ==&gt;4 4 5 9</p><p>我们要做的就是求出所有情况的最值，</p><p>但是无需对每一段都做单独的dp，只需要做一次n*2规模的dp，然后取值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 前缀和</span><br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;prefix[i];<br>    prefix[i+n] = prefix[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n*<span class="hljs-number">2</span> ; i ++)&#123;<br>    prefix[i] += prefix[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-comment">// 最小值</span><br><span class="hljs-built_in">memset</span>(dpMin, inf, <span class="hljs-built_in">sizeof</span>(dpMin));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n*<span class="hljs-number">2</span> ; i ++) dpMin[i][i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span> ; l+i<span class="hljs-number">-1</span> &lt; n*<span class="hljs-number">2</span> ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>            dpMin[l][r] = <span class="hljs-built_in">min</span>(dpMin[l][r], dpMin[l][k] + dpMin[k<span class="hljs-number">+1</span>][r] + prefix[r] - prefix[l<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br>min_ = inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>    min_ = <span class="hljs-built_in">min</span>(min_, dpMin[i][i+n<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-comment">//最大值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span> ; l+i<span class="hljs-number">-1</span> &lt; n*<span class="hljs-number">2</span> ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>            dpMax[l][r] = <span class="hljs-built_in">max</span>(dpMax[l][r], dpMax[l][k] + dpMax[k<span class="hljs-number">+1</span>][r] + prefix[r] - prefix[l<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>    max_ = <span class="hljs-built_in">max</span>(max_, dpMax[i][i+n<span class="hljs-number">-1</span>]);<br>&#125;<br>cout&lt;&lt;min_&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;max_;<br></code></pre></td></tr></table></figure><h2 id="能量项链">能量项链</h2><p>原题：<a href="https://www.lanqiao.cn/problems/557/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=557">1.能量项链- 蓝桥云课 (lanqiao.cn)</a></p><blockquote><p>题目很复杂，不解释了</p></blockquote><p>这题和石子合并类似，区别累加的数字是一个乘积。</p><p>状态转移方程如下： <span class="math display">\[dp[i, j] = max(dp[i][k] + dp[k+1][j] + v[i]*v[k+1]*v[j+1])\]</span> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;v[i];<br>    v[i+n] = v[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span> ; l+i<span class="hljs-number">-1</span> &lt; n*<span class="hljs-number">2</span> ; l ++)&#123;<br>        <span class="hljs-type">int</span> r = l+i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l ; k &lt; r ; k ++)&#123;<br>            dp[l][r] = <span class="hljs-built_in">max</span>(dp[l][r], dp[l][k] + dp[k<span class="hljs-number">+1</span>][r] + v[l]*v[k<span class="hljs-number">+1</span>]*v[r<span class="hljs-number">+1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>    ans = <span class="hljs-built_in">max</span>(ans, dp[i][i+n<span class="hljs-number">-1</span>]);<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="最短编辑距离">最短编辑距离</h2><blockquote><p>求最短编辑距离，也叫“近似串匹配”问题</p></blockquote><p>模板题：<a href="https://www.luogu.com.cn/problem/P2758">P2758编辑距离 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;s1&gt;&gt;s2;<br>l1 = s<span class="hljs-number">1.l</span>ength(); s1 = <span class="hljs-string">&quot; &quot;</span> + s1;<br>l2 = s<span class="hljs-number">2.l</span>ength(); s2 = <span class="hljs-string">&quot; &quot;</span> + s2;<br><span class="hljs-comment">//初始化边界</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= l1; i ++) dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= l2; i ++) dp[<span class="hljs-number">0</span>][i] = i;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l1; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= l2; j ++)&#123;<br>        <span class="hljs-keyword">if</span>(s1[i] == s2[j])&#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//跳过</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>, dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//插入，删除</span><br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//修改</span><br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p><strong>模板+路径回溯</strong></p><p>CAIP 2022 RC-u4 变牛的最快方法</p><p>这里问的是把任意一种动物的图像变成牛的方法……比如把一只鼠的图像变换成牛的图像。方法如下：</p><ul><li>首先把屏幕上的像素点进行编号；</li><li>然后把两只动物的外轮廓像素点编号按顺时针记录下来；</li><li>用最少的变换次数将鼠的轮廓变成牛的 —— 这里仅允许对鼠的轮廓进行 3钟操作：</li></ul><ol type="1"><li>插入一个像素编号</li><li>删除一个像素编号</li><li>更改一个像素编号</li></ol><p><strong>输入格式</strong></p><p>输入分别在两行中给出两种动物的轮廓像素点编号，编号为 (0,106]区间内的整数，允许重复。轮廓以编号 −1结尾，这个编号不算在轮廓内。题目保证每种动物的轮廓包含不超过 1000个像素点。</p><p><strong>输出格式</strong></p><p>在第一行中输出从第一只动物变换成第二只动物需要的最少变换次数。</p><p>在第二行中顺次描述对第一只动物轮廓的每个像素所作的操作：</p><ul><li>如果这个像素被删除，则在对应位置输出 0</li><li>如果这个像素被改变，则在对应位置输出 1</li><li>如果这个像素不变，则在对应位置输出 2</li><li>如果这个像素前面或者后面插入了一个像素，则在插入的位置输出 3</li></ul><p>答案可能不唯一，输出任何一种可能的解都可以。行首尾和数字间均无空格。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">13 5 6 20 2 20 1 13 9 20 3 28 3 34 6 25 233 -1<br>3 5 6 20 6 20 3 5 9 3 9 20 3 6 6 25 233 -1<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs out">8<br>122212112023121222<br></code></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(cin&gt;&gt;a1[++l1])&#123;<br>    <span class="hljs-keyword">if</span>(a1[l1] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l1--;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;a2[++l2])&#123;<br>    <span class="hljs-keyword">if</span>(a2[l2] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>&#125;l2--;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l1 ; i ++)&#123;<br>    pre[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    dp[i][<span class="hljs-number">0</span>] = i;<br>    op[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= l2 ; i ++)&#123;<br>    pre[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,i<span class="hljs-number">-1</span>);<br>    dp[<span class="hljs-number">0</span>][i] = i;<br>    op[<span class="hljs-number">0</span>][i] = <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-comment">//删除 0 改变 1 不变 2 插入 3</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= l1 ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= l2 ; j ++)&#123;<br>        <span class="hljs-type">int</span> add = dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 3</span><br>        <span class="hljs-type">int</span> del = dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 0</span><br>        <span class="hljs-type">int</span> rpl = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + (a1[i] != a2[j]); <span class="hljs-comment">//1 ; 2</span><br>        <span class="hljs-type">int</span> min_ = <span class="hljs-built_in">min</span>(add,<span class="hljs-built_in">min</span>(del,rpl));<br>        <span class="hljs-keyword">if</span>(min_ == add)&#123;<br>            dp[i][j] = add;<br>            pre[i][j] = <span class="hljs-built_in">make_pair</span>(i,j<span class="hljs-number">-1</span>);<br>            op[i][j] = <span class="hljs-number">3</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(min_ == del)&#123;<br>            dp[i][j] = del;<br>            pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j);<br>            op[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j] = rpl;<br>            pre[i][j] = <span class="hljs-built_in">make_pair</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">-1</span>);<br>            op[i][j] = a1[i] == a2[j] ? <span class="hljs-number">2</span>:<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[l1][l2]&lt;&lt;endl;<br><span class="hljs-type">int</span> x = l1, y = l2;<br>stack&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>|| y &gt; <span class="hljs-number">0</span>)&#123;<br>    ans.<span class="hljs-built_in">push</span>(op[x][y]);<br>    pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; back = pre[x][y];<br>    x = back.first, y = back.second;<br>&#125;<br><span class="hljs-keyword">while</span>(!ans.<span class="hljs-built_in">empty</span>())&#123;<br>    cout&lt;&lt;ans.<span class="hljs-built_in">top</span>();ans.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>期望DP</title>
    <link href="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/"/>
    <url>/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%9F%E6%9C%9BDP/</url>
    
    <content type="html"><![CDATA[<h1 id="期望dp概念">期望DP概念</h1><p>要求一个事件期望，有两种方法：</p><p>一种是根据概率公式，直接求： <span class="math display">\[E(x) = \sum_{i}^{n} x_i*P(x_i)\]</span> 但是这样写程序一般会超时。</p><p>另一种更常见的做法是根据期望的递归公式， <span class="math display">\[E(x) = F(E(x-1))\]</span> 来逐步推出所要求的期望值。</p><h1 id="买卡片1">买卡片1</h1><p>卡片一共有k种，现在要买n张卡片，买到每种卡片的概率相同，求买到卡片种类数 的期望。</p><p>首先，假设只买1张卡片，期望肯定为1，因为无论买哪张都是新的种类。</p><p>然后，假设我们已经知道 买i-1张卡片，得到的种类数期望,那么再买到一张的新卡片的期望为 (k - E(i-1)) /k（因为x为1，期望和概率相同）。</p><p>设 买i张卡片，得到的种类数 为 DP{i} , 有 <span class="math display">\[dp[i] = dp[i-1] + \frac{k - dp[i-1]}{k}\]</span> 即：买 i 张得到种类数的期望 = 买i-1张...的期望 +再获得一张新卡片的期望</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= k ; i ++)&#123;<br>    dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1.0</span>*k/(k - i<span class="hljs-number">+1</span>);<br>&#125;<br>cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>)&lt;&lt;dp[k];<br></code></pre></td></tr></table></figure><h1 id="买卡片2">买卡片2</h1><p>卡片一共有k种，买到每种卡片的概率相同，现在需要不断地购买，求买到k种所需要次数 的期望。</p><p>首先，假设只买1张卡片，期望为1，因为无论买哪张都是新的种类。</p><p>然后，假设目前到手 i-1 种，那么接下来，每次购买，买到第 i 种的概率P== (k - i + 1)/k，那么所需要次数的期望，就是 1/P == k/(k - i +1)。</p><p>由此，我们得到递推式： <span class="math display">\[dp[i] = dp[i-1] + \frac{k}{k-i+1}\]</span> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= k ; i ++)&#123;<br>    dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1.0</span>*k/(k - i<span class="hljs-number">+1</span>);<br>&#125;<br>cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>)&lt;&lt;dp[k];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP基础</title>
    <link href="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E5%9F%BA%E7%A1%80/"/>
    <url>/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="求方案数">求方案数</h1><p>这类问题大的明显特定是，给几个参数，然后要求方案数的个数</p><h2 id="e1-走楼梯">E1-走楼梯</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149631&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 破损的楼梯 - 蓝桥云课 (lanqiao.cn)</a></p><p>经典走楼梯问题的变形，每次走1步，或者2步，但破损的楼梯不能走，求总方案数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br>    <span class="hljs-type">int</span> p;cin&gt;&gt;p;<br>    broken[p] = <span class="hljs-literal">true</span>;<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(!broken[<span class="hljs-number">1</span>]) dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(!broken[i]) dp[i] = (dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>])%MOD;<br>&#125;<br>cout&lt;&lt;dp[n];<br></code></pre></td></tr></table></figure><h2 id="e2-求方案数">E2-求方案数</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149630&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 建造房屋 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n条街道，每个街道上可以建m个房屋，一共要建k个房屋（在每条街道上，至少建一个房屋），求总方案数</p><p>注意，根据样例，可以知道这题不区分一条街道上房屋的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;k&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= k ; i ++)&#123;<br>    dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// dp i j 表示 对前i条街道, 房屋数量为j的方案数量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-comment">//总预算j</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i ; j &lt;= k ; j ++)&#123;<br>        <span class="hljs-comment">// 设第i条街道可能建了r个房屋</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r &lt;= m &amp;&amp; j-r &gt;= i<span class="hljs-number">-1</span> ; r ++)&#123;<br>            dp[i][j] = (dp[i][j] + dp[i<span class="hljs-number">-1</span>][j-r]) % MOD;<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n][k];<br></code></pre></td></tr></table></figure><h2 id="e4-求方案数">E4-求方案数</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149633&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 可构造的序列总数 - 蓝桥云课 (lanqiao.cn)</a></p><p>求满足如下关系的序列总方案个数：</p><ul><li>序列的长度为 n</li><li>1≤<em>a</em>1≤<em>a</em>2≤<em>a</em>3≤......≤an≤<em>k</em></li><li>ai 是 ai−1的倍数（ i≥2<em>i</em>≥2 ）</li></ul><p>总长度为n，元素至少大于等于1，从左到右依次是上一个元素的倍数。</p><p>dp{i，k}就表示长度为n时，小于k的方案数量。</p><p>从小到大遍历，遍历当前元素的倍数的每个，叠加方案数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;k&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br>    dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= k ; j ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r*r &lt;= j; r ++)&#123;<br>            <span class="hljs-keyword">if</span>(r*r == j)&#123; <span class="hljs-comment">//两个因子相同，去重</span><br>                dp[i][j] = (dp[i][j]+dp[i<span class="hljs-number">-1</span>][r])%MOD;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j % r == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = (dp[i][j]+dp[i<span class="hljs-number">-1</span>][r]+dp[i<span class="hljs-number">-1</span>][j/r])%MOD;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= k ; i ++)&#123;<br>    ans = (ans + dp[n][i]) % MOD;<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="e5-求方案数">E5-求方案数</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149635&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 安全序列 - 蓝桥云课 (lanqiao.cn)</a></p><p>有n个空位，放任意数量个酒桶，每2个酒桶需要间隔k个位置，求总方案数</p><p>从小到大遍历空位数量i，空位数量为i的方案数 == i不放酒桶的方案数 +i放酒桶的方案数</p><p>== i-1个位置的方案数 + i-k-1个位置的方案数( i-k-1 &gt;= 0 ,否则为1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;k;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(i-k<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">1</span>)&#123;<br>        dp[i] = (dp[i<span class="hljs-number">-1</span>] + dp[i-k<span class="hljs-number">-1</span>]) % MOD;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        dp[i] = (dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>) % MOD;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n];<br></code></pre></td></tr></table></figure><h2 id="e6-求方案数">E6-求方案数</h2><p><a href="https://www.lanqiao.cn/problems/389/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=389">1.摆花- 蓝桥云课 (lanqiao.cn)</a></p><p>有n种花，需要摆放m盆，每种花最多摆放a[i]盆，求总方案数。</p><p>设dp{i, k} 为前i种花，摆放k盆的总方案数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>            <span class="hljs-comment">//注意若使用1维数组，这里的r需要从1开始，避免重复累加DP[j]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">1</span> ; r &lt;= a[i] ; r ++)&#123;<br><span class="hljs-keyword">if</span>(j - r &gt;= <span class="hljs-number">0</span>) dp[j] = (dp[j] + dp[j - r])%MOD;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e6-异或运算">E6-异或运算</h2><p>给n个数和一个数x，求子序列中异或和为x的个数。</p><p>设DP{i，j} 表示前i个数，异或和为j的方案总数。</p><p>DP{i，j} 包含两种解，一种不包含a[i], 一种包含a[i], 因此，有 DP{i，j}= DP{i-1, j} + DP{i-1, j ^ a[i]}。</p><p>（假设j中已经包含了a[i]，又有j ^ a[i] ^ a[i] ==j，所以相当于从j这个和中消去了a[i]）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//异或预算的特点：</span><br><br><span class="hljs-comment">//任何数异或0，都等于自身；</span><br><span class="hljs-comment">//任何数异或1，都等于自身取反；</span><br><span class="hljs-comment">//任何数异或自身，都等于0；（注意是a ^ a，与上文的^a不同）；</span><br><span class="hljs-comment">//任何数对同一个数异或两次后，都等于自身</span><br><br>cin&gt;&gt;n&gt;&gt;x;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>&#125;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>now = <span class="hljs-number">1</span>; <span class="hljs-comment">//滚动数组优化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; <span class="hljs-number">64</span> ; j ++)&#123;<br>        dp[now][j] = (dp[now^<span class="hljs-number">1</span>][j] + dp[now^<span class="hljs-number">1</span>][j^a[i]]) % MOD;<br>    &#125;<br>    now ^= <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;dp[now^<span class="hljs-number">1</span>][x];<br></code></pre></td></tr></table></figure><h1 id="求最优解">求最优解</h1><h2 id="e1-数字三角形">E1-数字三角形</h2><p><a href="https://www.lanqiao.cn/problems/505/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=505">1.数字三角形- 蓝桥云课 (lanqiao.cn)</a></p><p>给一个n列的数字三角形，要从上走到下，<strong>并且左右步数之差不超过1</strong>，要求总和最大的路径。</p><p>这题是基本的数字三角形的变形，由于左右步数之差不超过1，路径结尾一定落在最后一行的中位数列上，所以我们只需要考虑中位数列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= i ; j ++)&#123;<br>        cin&gt;&gt;a[i][j];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i ; j &gt;= <span class="hljs-number">1</span> ; j --)&#123;<br>        <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">1</span>) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j<span class="hljs-number">-1</span>]) + a[i][j];<br>        <span class="hljs-keyword">else</span> dp[j] = dp[j] + a[i][j];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>)&#123;<br>    cout&lt;&lt;dp[n/<span class="hljs-number">2</span><span class="hljs-number">+1</span>];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[n/<span class="hljs-number">2</span>], dp[n/<span class="hljs-number">2</span><span class="hljs-number">+1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e2-lis变形">E2-LIS变形</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149632&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 拍照 - 蓝桥云课 (lanqiao.cn)</a></p><p>给一个长度为n的序列，求一个位置P，从P往左走，删除元素，使得其上升；从P往右边走，删除元素，使其下降。位置P需要删除的元素是最少的。</p><p>这题是最长上升子序列问题的变形。从左到右，从右到左，分别求一次最长不下降子序列。然后遍历求最值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>    dpL[i] = dpR[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span> ; j &gt;= <span class="hljs-number">1</span> ; j--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] &gt;= a[j])&#123;<br>            dpL[i] = <span class="hljs-built_in">max</span>(dpL[i], dpL[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span> ; j &lt;= n ; j ++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] &gt;= a[j])&#123;<br>            dpR[i] = <span class="hljs-built_in">max</span>(dpR[i], dpR[j] + <span class="hljs-number">1</span>); <br>        &#125;<br>    &#125;<br>&#125;<br>ans = INT_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    ans = <span class="hljs-built_in">min</span>(ans, n - (dpL[i] + dpR[i] - <span class="hljs-number">1</span>) );<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="e3-最大区间和">E3-最大区间和</h2><p>给一个长度为n的数列， 求最大区间和（结果必须大于等于0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br>v.<span class="hljs-built_in">resize</span>(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    cin&gt;&gt;v[i];<br>&#125;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> max_ = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//每个区间都可以看作是 最后一个数 + 前n个数</span><br><span class="hljs-comment">//此处使用sum记录，往前加多少个数是最优的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(sum + v[i] &lt; <span class="hljs-number">0</span>)&#123;<br>        sum = <span class="hljs-number">0</span>;<br>        l = i<span class="hljs-number">+1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        sum += v[i];<br>        r = i<span class="hljs-number">+1</span>;<br>        <span class="hljs-keyword">if</span>(sum &gt; max_)&#123;<br>            max_ = sum;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(max_ == <span class="hljs-number">-1</span>) max_ = <span class="hljs-number">0</span>;<br>cout&lt;&lt;max_;<br></code></pre></td></tr></table></figure><h1 id="多维dp">多维DP</h1><h2 id="e1-图上dp">E1-图上DP</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149637&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 地图 - 蓝桥云课 (lanqiao.cn)</a></p><p>给一张长为n，宽为m的矩阵图，可以从上到下，或者从左到右走，但是最多旋转k次，</p><p>求从（1，1）走到（n，m）的路径个数</p><p>dp{i,j,t,p} 表示 走到i，j为止，旋转了k次，此时方向为p的方案个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>        cin&gt;&gt;road[i][j];<br>    &#125;<br>&#125;<br><span class="hljs-comment">//初始化边界</span><br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(road[i][<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>        dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= m ; i ++)&#123;<br>    <span class="hljs-keyword">if</span>(road[<span class="hljs-number">1</span>][i] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>        dp[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> ; j &lt;= m ; j ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">1</span> ; t &lt;= k ; t ++)&#123;<br>            <span class="hljs-comment">//每个位置的DP都可以由四个状态转移而来</span><br>            <span class="hljs-keyword">if</span>(road[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                dp[i][j][t][<span class="hljs-number">0</span>] = dp[i][j<span class="hljs-number">-1</span>][t<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] + dp[i][j<span class="hljs-number">-1</span>][t][<span class="hljs-number">0</span>];<br>                dp[i][j][t][<span class="hljs-number">1</span>] = dp[i<span class="hljs-number">-1</span>][j][t][<span class="hljs-number">1</span>] + dp[i<span class="hljs-number">-1</span>][j][t<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= k ; i ++)&#123;<br>    ans += dp[n][m][i][<span class="hljs-number">0</span>] + dp[n][m][i][<span class="hljs-number">1</span>];<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h1 id="背包">01背包</h1><h2 id="e1-01背包变形">E1-01背包变形</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149634&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 最快洗车时间 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n辆车，每辆车要洗<span class="math inline">\(t_i\)</span>时间，有两个洗车机器，可以同时运行，求全部洗好需要的时间。</p><p>这题是背包问题，设背包的容量为sum/2，求背包的最大价值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>    sum += a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum/<span class="hljs-number">2</span> ; j &gt;= a[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - a[i]] + a[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;sum - dp[sum/<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>另一种写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>    sum += a[i];<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//求其中一个机器可能的时间方案</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum ; j &gt;= a[i] ; j --)&#123;<br>        dp[j] = (dp[j] | dp[j - a[i]]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出答案</span><br>ans = INT_MAX;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= sum/<span class="hljs-number">2</span> ; i++)&#123;<br>    <span class="hljs-keyword">if</span>(dp[i]) ans = <span class="hljs-built_in">min</span>(sum - i,ans);<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="e2-01背包变形">E2-01背包变形</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149638&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 电影放映计划 - 蓝桥云课 (lanqiao.cn)</a></p><p>给N部电影，总共播放时间是M分钟，每部电影间至少间隔k分钟，给每部电影的分钟数t_i和利润p_i，</p><p>每部电影可以重复播放，要求最大利润。</p><p>每部电影至少间隔k分钟，只需要给每个<span class="math inline">\(t_i\)</span>和m都加上k，然后转化为普通完全背包问题即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;m&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;t[i]&gt;&gt;p[i];<br>&#125;<br>cin&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    t[i] += k;<br>&#125;<br>m += k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t[i] ; j &lt;= m ; j ++)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-t[i]] + p[i]);<br>        ans = <span class="hljs-built_in">max</span>(ans, dp[j]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h2 id="e3-多维01背包">E3-多维01背包</h2><p><a href="https://www.lanqiao.cn/problems/2223/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;problem_id=2223">1.背包与魔法- 蓝桥云课 (lanqiao.cn)</a></p><p>与普通背包问题不同的是，可以进行对物品1次变形：增加重量k，价值翻倍。</p><p>需要增加一个维度，dp[j][r]表示重量j下进行r次变形的最大重量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i] ; j --)&#123;<br>        dp[j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[j][<span class="hljs-number">0</span>], dp[j - w[i]][<span class="hljs-number">0</span>] + v[i]);<br>        dp[j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[j][<span class="hljs-number">1</span>], dp[j - w[i]][<span class="hljs-number">1</span>] + v[i]);<br>        <span class="hljs-keyword">if</span>(j &gt;= w[i] + k) dp[j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[j][<span class="hljs-number">1</span>], dp[j - w[i] - k][<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>*v[i]);<br>    &#125; <br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[m][<span class="hljs-number">1</span>], dp[m][<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h2 id="e4-01背包变形">E4-01背包变形</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149646&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 倒水 - 蓝桥云课 (lanqiao.cn)</a></p><p>有m升水，n个客人，</p><p>对于第i个客人，不倒水，得到ei满意度；倒ai升的水，得到bi满意度；倒ci升的水，得到di满意度；</p><p>求最高的满意度。</p><p>这题相当于在01背包的基础上增加了更多选择，本质一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        ll x1,x2,x3;<br>        x1 = dp[j] + e[i];<br>        x2 = x3 = LONG_LONG_MIN;<br>        <span class="hljs-keyword">if</span>(j &gt;= a[i]) x2 = dp[j - a[i]] + b[i];<br>        <span class="hljs-keyword">if</span>(j &gt;= c[i]) x3 = dp[j - c[i]] + d[i];<br>        dp[j] = <span class="hljs-built_in">max</span>(x1,<span class="hljs-built_in">max</span>(x2,x3));<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h2 id="e5-01背包排序">E5-01背包+排序</h2><p><a href="https://www.lanqiao.cn/problems/2945/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=课程抢购">1.蓝桥课程抢购- 蓝桥云课</a></p><p>给n个课程，每个课程有持续时间t和价值p，每个课程有截止时间d，必须在d之前做完。</p><p>相比普通的01背包，增加了截止时间d。</p><p>更新区间从[t, m]，变为[t,d]，注意需要对d进行排序，保证先考虑d小的课程。</p><p>sort</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span>&#123;<br>ll t,d,p;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> task &amp; rhs)&#123;<br><span class="hljs-keyword">return</span> d &lt; rhs.d;<br>&#125;<br>&#125;a[N];<br></code></pre></td></tr></table></figure><p>main</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a<span class="hljs-number">+1</span>+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = a[i].d ; j &gt;= a[i].t ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - a[i].t] + a[i].p);<br>        ans = <span class="hljs-built_in">max</span>(dp[j], ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e6-01最小背包">E6-01最小背包</h2><p><a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149649&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 购物策略 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n个物品，每个物品需要花t个时间来购买，在每个物品的购买期间，每过1个单位时间，就可以免费获得另外的1个商品，求最小花销。</p><p>这题的限制不是体积，而是数量，我们可以把背包的容量当成是某个数量，买每个物品消耗的数量为t[i]+ 1,</p><p>然后就可以转化为求： 背包体积至少为n的最小花销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    cin&gt;&gt;t[i]&gt;&gt;c[i];<br>    t[i]++;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    dp[i] = INF;<br>&#125;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(ll j = n; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, j - t[i])] + c[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子串问题</title>
    <link href="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <url>/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://writings.sh/post/algorithm-longest-palindromic-substring#一维动态规划方法">最长回文子串问题（五种方法）| 春水煎茶 (writings.sh)</a></p><h1 id="判断回文字符串">判断回文字符串</h1><p>暴力O(N2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">palin</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> r = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br><span class="hljs-keyword">if</span>(s[l++] != s[r--]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="求最长回文子子串">求最长回文子子串</h1><h2 id="暴力枚举on4">暴力枚举O(N4)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxPalin</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len ; i &gt;= <span class="hljs-number">2</span> ; i --)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j+i<span class="hljs-number">-1</span> &lt; len ; j ++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">palin</span>(s.<span class="hljs-built_in">substr</span>(j,i))) <span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维动态规划on2">二维动态规划O(N2)</h2><p>dp[i][j] 表示 [ i, j ]区间内的子串是否为回文串</p><p>状态转移方程 <span class="math inline">\(dp[l][r] = (s[l] == s[r]\&amp;\&amp; dp[l+1][r-1])\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>    dp[i][i] = <span class="hljs-literal">true</span>;<br>    max_ = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; s[i<span class="hljs-number">-1</span>] == s[i])&#123;<br>        dp[i<span class="hljs-number">-1</span>][i] = <span class="hljs-literal">true</span>;<br>        max_ = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span> ; i &lt;= len ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j+i<span class="hljs-number">-1</span> &lt; len ; j ++)&#123;<br>        <span class="hljs-type">int</span> l = j;<br>        <span class="hljs-type">int</span> r = j + i - <span class="hljs-number">1</span>;<br>        dp[l][r] = (s[l] == s[r] &amp;&amp; dp[l<span class="hljs-number">+1</span>][r<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">if</span>(dp[l][r]) max_ = <span class="hljs-built_in">max</span>(max_, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一维动态规划on2">一维动态规划O(N2)</h2><p>dp[i] 表示以i结尾的最长回文子串的起始位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxPalin</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i ++)&#123;<br><span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] == s[dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>])&#123;<br>dp[i] = dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> l = dp[i<span class="hljs-number">-1</span>];<br><span class="hljs-type">int</span> r = i;<br><span class="hljs-type">int</span> st = l;<br><span class="hljs-keyword">while</span>(l &lt; r)&#123;<br><span class="hljs-keyword">if</span>(s[l] == s[r])&#123;<br>l++;r--;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>l++;r=i;<br>st = l;<br>&#125;<br>&#125;<br>dp[i] = st;<br>&#125;<br>res = <span class="hljs-built_in">max</span>(i - dp[i] + <span class="hljs-number">1</span>, res);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题汇总</title>
    <link href="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="背包-最优解">01背包 最优解</h1><p>参考：<a href="https://www.acwing.com/blog/content/458/">背包问题中体积至多是 j ，恰好是 j ，至少是 j 的初始化问题的研究 - AcWing</a></p><p>模板题：<a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149645&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 小明的背包1 - 蓝桥云课 (lanqiao.cn)</a></p><p>说明1：如果需要限制取走物品的个数，而不是重量，只需要设每个物品的体积为1，再调整背包体积即可</p><p>说明2：如果需要使用LONGLONG，INF可以修改为0x3f3f3f3f3f3f3f3f，但初始化不能用memset，需要遍历DP数组。</p><p>1：给n个物品，并给出每个物品的体积w和价值v，背包体积<strong>不超过m</strong>，求能获得的<strong>最大价值</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 无需进行初始化，DP数组全部为0即可</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= v[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>2：给n个物品，并给出每个物品的体积w和价值v，背包体积<strong>恰好是m</strong>，求能获得的<strong>最大价值/最小价值</strong>。</p><p>1）最大价值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 保证只有递归回到dp[0]的状态会被考虑</span><br><span class="hljs-comment">// dp[0] = 0, 其余为-INF</span><br><span class="hljs-built_in">memset</span>(dp, -INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= v[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>2）最小价值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dp[0] = 0, 其余为INF</span><br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= v[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - w[i]] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>3：给n个物品，并给出每个物品的体积w和价值v，背包体积<strong>至少是m</strong>，求能获得的<strong>最小价值</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dp[0] = 0, 其余为INF</span><br><span class="hljs-built_in">memset</span>(dp, INF, <span class="hljs-built_in">sizeof</span>(dp));<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-comment">// 即使，j - w[i]</span><br>        dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j - w[i])] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h1 id="背包-方案数">01背包 方案数</h1><p>1：给n个物品，每个物品的体积为v，且<strong>只能选一次</strong>，求总体积<strong>不超过m</strong>的方案数</p><p><strong>二维</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对于方案数问题，二维数组的好处是, dp&#123;i, j&#125;能够表示取前i个物品，体积不超过j的方案数。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= m ; i ++)&#123;<br>    dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>            <span class="hljs-comment">// 拿或者不拿</span><br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i<span class="hljs-number">-1</span>][j-w[i]];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n][m];<br></code></pre></td></tr></table></figure><p><strong>一维</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt;= m ; i ++)&#123;<br>    dp[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>            dp[j] = dp[j] + dp[j-w[i]];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[j] = dp[j];<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>2：给n个物品，每个物品的体积为v，且只能选一次，求总体积<strong>恰好是m</strong>的方案数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//与1唯一的区别在初始化</span><br><span class="hljs-comment">//只有递归会到dp[0]这个状态才被计入方案数，所以只有dp[0] = 1</span><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-keyword">if</span>(j &gt;= w[i])&#123;<br>            dp[j] = dp[j] + dp[j-w[i]];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[j] = dp[j];<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><p>3：给n个物品，每个物品的体积为v，且只能选一次，求总体积<strong>至少是m</strong>的方案数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//初始化和2相同</span><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-comment">// 即使 j-w[i] &lt; 0，也继续叠加方案数量。</span><br>        <span class="hljs-comment">// 因为这个操作增多的方案数 == 大于m的方案数</span><br>        dp[j] = dp[j] + dp[<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j-w[i])];<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h1 id="完全背包">完全背包</h1><p>模板题：<a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149652&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 小明的背包2 - 蓝桥云课 (lanqiao.cn)</a></p><p>完全背包和01背包的区别是：完全背包中，每个物品都可以取无限次；而01背包，每个物品只能取1次。</p><p>一维数组的模板的变化很小，只需要修改遍历的方向（状态转移时考虑多次取当前物品）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i] ; j &lt;= m ; j ++)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h1 id="多重背包">多重背包</h1><p>多重背包和01背包的区别是：多重背包中，每个物品可以取s个，这个s是题目给定的；而01背包，每个物品只能取1次。</p><h2 id="朴素onsm">朴素O(N*S*M)</h2><p>模板题：<a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149655&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 小明的背包3 - 蓝桥云课 (lanqiao.cn)</a></p><p>多重背包可以一般退化为01背包来解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-comment">// 区别是每个物品需要跑si次, 就相当于有si个该物品</span><br>    <span class="hljs-keyword">while</span>(s[i]--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i] ; j --)&#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h2 id="二进制优化onlogsm">二进制优化O(N*logS*M)</h2><p>模板题：<a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149657&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 新一的宝藏搜寻加强版 - 蓝桥云课 (lanqiao.cn)</a></p><p>在进行二进制优化之前，我们首先要知道：</p><p>对于任意一个正整数n，都可以用二进制将其分解为：2^0 + 2^1 ... 2^m +余数的形式。</p><p>任何小于n的正整数[1, n]，都可以取一其中的几个进行表示。</p><p>例如，10可以分解为1 + 2 + 4 + 3（这里的3是余数），然后[1,10]的任意一个数都可以用这4个数表示，</p><p>有 3 == 1 + 2；6 == 1 +2 + 3；7 == 1 + 2 + 4</p><p>因此，我们对于s个物品，我们也可以用二进制的方式对它进行分解，以优化时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> infIsTrue</span><br>    <span class="hljs-comment">//若s[i] == 0时表示无限个，需要结合多重背包</span><br>     <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = w[i] ; j &lt;= m ; j ++)&#123;<br>             dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-w[i]] + v[i]);<br>         &#125;<br>         <span class="hljs-keyword">continue</span>;<br>     &#125;    <br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">// 常规</span><br>    <span class="hljs-comment">// k从1开始，逐次加倍</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span> ; s[i] &gt;= k ; s[i] -= k, k += k)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= k*w[i] ; j --)&#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - k*w[i]] + k*v[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 处理余数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= s[i]*w[i] ; j --)&#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - s[i]*w[i]] + s[i]*v[i]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[m];<br></code></pre></td></tr></table></figure><h2 id="单调队列优化onm">单调队列优化O(N*M)</h2><p>模板题：<a href="https://www.acwing.com/problem/content/description/6/">6.多重背包问题 III - AcWing题库</a></p><p>要使用单调队列对状态转移进行优化，我们首先要知道什么是<a href="https://oi-wiki.org/ds/monotonous-queue/">单调队列 - OIWiki</a>。</p><p>此外，还有必要了解一种典型例题：<a href="https://www.acwing.com/problem/content/description/156/">154.滑动窗口 - AcWing题库</a></p><p>下面提供，单调队列求滑动窗口最值的两种模板：</p><p><strong>C++ STL</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-comment">// 求最大值：dq.back() &lt; a[i]</span><br>    <span class="hljs-keyword">while</span>(dq.<span class="hljs-built_in">size</span>() &amp;&amp; dq.<span class="hljs-built_in">back</span>() &gt; a[i])&#123;<br>        dq.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    dq.<span class="hljs-built_in">push_back</span>(a[i]);<br>    <span class="hljs-keyword">if</span>(i-k &gt; <span class="hljs-number">0</span> &amp;&amp; dq.<span class="hljs-built_in">front</span>() == a[i-k]) dq.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-keyword">if</span>(i-k &gt;= <span class="hljs-number">0</span>) cout&lt;&lt;dq.<span class="hljs-built_in">front</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>非STL</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hh = <span class="hljs-number">0</span>; tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">while</span>(tt &gt;= hh &amp;&amp; a[q[tt]] &gt; a[i]) tt--;<br>    q[++tt] = i;<br>    <span class="hljs-keyword">if</span>(i-q[hh]<span class="hljs-number">+1</span> &gt; k) hh++;<br>    <span class="hljs-keyword">if</span>(i &gt;= k) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面给出单调队列求解多重背包代码（<a href="https://www.acwing.com/solution/content/53507/">AcWing 6.多重背包问题 III【单调队列优化+图示】 - AcWing</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1050</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">20050</span>;<br><br><span class="hljs-type">int</span> n,m,tt,hh;<br><span class="hljs-type">int</span> w[maxn],v[maxn],s[maxn],q[maxm]; <span class="hljs-comment">//这里q[maxm],而不是q[maxn]</span><br><span class="hljs-type">int</span> dp[maxn][maxm];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;w[i]&gt;&gt;v[i]&gt;&gt;s[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span> ; r &lt; w[i] ; r ++)&#123;<br>hh = <span class="hljs-number">0</span>;tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = r ; j &lt;= m ; j += w[i])&#123;<br><span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; j - q[hh] &gt; s[i]*w[i]) hh++;<br><span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; dp[i<span class="hljs-number">-1</span>][q[tt]] + (j-q[tt])/w[i]*v[i] &lt; dp[i<span class="hljs-number">-1</span>][j]) tt--;<br>q[++tt] = j;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][q[hh]] + (j-q[hh])/w[i]*v[i];<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[n][m];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维费用背包">二维费用背包</h1><p>模板题：<a href="https://www.lanqiao.cn/courses/21965/learning/?id=1149661&amp;compatibility=false">蓝桥杯省赛无忧班（C&amp;C++组）第 1 期 - 小蓝的神秘行囊 - 蓝桥云课 (lanqiao.cn)</a></p><p>给n个物品，并给出每个物品的体积v，重量w和价值p，背包体积不超过V，重量不超过m，求能获得的最大价值。</p><p>只需要在01背包的基础上增加一个维度即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i] ; j --)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = V ; t &gt;= v[i] ; t --)&#123;<br>            dp[j][t] = <span class="hljs-built_in">max</span>(dp[j][t], dp[j - w[i]][t - v[i]] + p[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分组背包">分组背包</h1><p>给n组物品，每组物品有s个，给出每个物品的重量w和价值p，每组物品只能取其中一个，背包重量不超过m，求能获得的最大价值。</p><p>注意：同一组（i）的内不同物品的状态只能从上一组（i-1）转移过来。</p><p><strong>二维DP写法：</strong></p><p>分组编号i（分组内编号t（背包体积j）） -&gt; 使用编号 i 和 i-1避免了组内转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt;= m ; j ++) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">1</span> ; t &lt;= cnt[i] ; t ++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= w[i][t] ; j --)&#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i<span class="hljs-number">-1</span>][j - w[i][t]] + v[i][t]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n][m];<br></code></pre></td></tr></table></figure><p><strong>一维DP写法：</strong></p><p>分组编号i（背包体积j（分组内编号t）） -&gt;先遍历背包体积j，同样可以避免组内转移，且空间更优</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m ; j &gt;= <span class="hljs-number">0</span> ; j --)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t = <span class="hljs-number">1</span> ; t &lt;= cnt[i] ; t ++)&#123;<br>            <span class="hljs-keyword">if</span>(j &gt;= w[i][t])&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i][t]] + v[i][t]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LIS和LCS</title>
    <link href="/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LIS%E5%92%8CLCS/"/>
    <url>/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LIS%E5%92%8CLCS/</url>
    
    <content type="html"><![CDATA[<h1 id="lis最长上升子序列">LIS：最长上升子序列</h1><p><a href="https://blog.csdn.net/lxt_Lucia/article/details/81206439">参考：最长上升子序列(LIS) 详解+例题模板 (全)-CSDN博客</a></p><p><a href="https://www.luogu.com.cn/problem/B3637">B3637 最长上升子序列- 洛谷 | 计算机科学教育新生态</a></p><h2 id="on2">O(N^2)</h2><p>解法：线性DP（N &lt;= 5000）</p><p>dp[i]： 以 i 结尾的最长上升子序列长度</p><p>每次遍历一个位置<code>i</code>，往之前的位置遍历，找到每一个能连接上的序列，保存<code>dp[i]</code>为找到的最大长度。</p><p>1）若要求最长不下降子序列，可将条件 <code>a[i] &gt; a[j]</code>改为<code>a[i] &gt;= a[j]</code></p><p>2）若要求最长下降子序列，即：将数组逆序排序，再求最长上升子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span> ; j &gt;= <span class="hljs-number">0</span> ;j --)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] &gt; a[j])&#123; <span class="hljs-comment">//不下降：a[i] &gt;= a[j]</span><br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>            res = <span class="hljs-built_in">max</span>(res,dp[i]);<br>        &#125;<br>    &#125;<br>&#125;<br>cout&lt;&lt;res<span class="hljs-number">+1</span>&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h2 id="onlogn">O(NlogN)</h2><p>解法：二分+贪心 (N &lt;= 1e6)</p><p>low[i]：所有长度为i的子序列的中最小的结尾值。</p><p>对于一个上升子序列，显然其结尾元素越小，越有利于在后面接其他的元素，也就越可能变得更长。</p><p>遍历a数组，并不断维护low数组，最后得到的cnt值，就是最长上升子序列的长度。</p><p>如果a[i]能接在当前最长的子序列的末尾上，即 a[i] &gt;low[cnt]，更新low[++cnt]为a[i]；</p><p>否则，往回找到一个第&gt;=a[i]的low[j]，替换为a[i]，维护low[j]为同长度序列的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-comment">//查找区间[l+1,r]</span><br>    <span class="hljs-comment">//找到第一个 &gt;= x 的位置</span><br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(low[mid] &lt; x)&#123;<br>l = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>r = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>low[++cnt] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(a[i] &gt; low[cnt])&#123;<br>low[++cnt] = a[i];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//int j = lower_bound(low+1,low+cnt+1,a[i]) - low;</span><br>            <span class="hljs-comment">//不下降：int j = upper_bound(low+1,low+cnt+1,a[i]) - low;</span><br><span class="hljs-type">int</span> j = <span class="hljs-built_in">binarySearch</span>(<span class="hljs-number">0</span>,cnt,a[i]);<br>low[j] = a[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;cnt&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="lcs最长公共子序列">LCS：最长公共子序列</h1><p><a href="https://www.luogu.com.cn/problem/P1439">P1439【模板】最长公共子序列 - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><h2 id="onm">O(N*M)</h2><p>左右末端若相等，当前值 == 删去当前末端的最大长度 + 1</p><p>左右末端若不相等，必然其中一个是无效的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++) cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; i ++) cin&gt;&gt;b[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= m ; j ++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i] == b[j]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[n][m];<br></code></pre></td></tr></table></figure><h2 id="求lcs序列">求LCS序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span> &gt; lcs;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getLcs</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i = n;<br><span class="hljs-type">int</span> j = m;<br><span class="hljs-keyword">while</span>(i&amp;&amp;j)&#123;<br><span class="hljs-keyword">if</span>(a[i] == a[j])&#123;<br>lcs.<span class="hljs-built_in">push_back</span>(a[i]);<br>i--;j--;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 舍去dp值较小的末端</span><br><span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j] &gt; dp[i][j<span class="hljs-number">-1</span>]) i--;<br><span class="hljs-keyword">else</span> j--;<br>&#125;<br>&#125;<br><span class="hljs-built_in">reverse</span>(lcs.<span class="hljs-built_in">begin</span>(),lcs.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="onlogn-1">O(N*logN)</h2><p><a href="https://www.luogu.com.cn/problem/P1439">P1439【模板】最长公共子序列 - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><p>==前提！！！若A和B数组中的元素是相同的元素的不同排列==，即A中每个元素都能在B中找到相同的元素，</p><p>此时，LCS问题可以转化为LIS问题。</p><p>首先，对于初始数组，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A: <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>B: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>我们不妨给它们重新标个号：把3标成a,把2标成b，把1标成c……于是变成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A: a b c d e<br>B: c b a d e<br></code></pre></td></tr></table></figure><p>这样标号之后，LCS长度显然不会改变。</p><p>由 两个序列的子序列一定是A的子序列，且A是单调递增的，</p><p>可以得到：只要子序列在B中单调递增，它就是A的子序列。</p><p>所以求A和B的LCS，就是求B的LIS，因此完成转化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">while</span>(l<span class="hljs-number">+1</span> != r)&#123;<br><span class="hljs-type">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(low[mid] &lt;= x)&#123;<br>l = mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>r = mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;a[i];<br>Hash[a[i]] = i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>cin&gt;&gt;b[i];<br>b[i] = Hash[b[i]];<br>&#125;<br>low[++cnt] = b[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(b[i] &gt; low[cnt])&#123;<br>low[++cnt] = b[i];<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">binarySearch</span>(<span class="hljs-number">0</span>, cnt, b[i]);<br>low[p] = b[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;cnt;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL汇总</title>
    <link href="/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/STL%E5%AE%B9%E5%99%A8%E6%B1%87%E6%80%BB/"/>
    <url>/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/STL%E5%AE%B9%E5%99%A8%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="stl容器">STL容器</h1><p>参考：<a href="https://wyqz.top/p/870124582.html#toc-heading-66">C++STL总结 | 行码棋 (wyqz.top)</a></p><h2 id="vector动态数组">vector：动态数组</h2><ul><li>顺序结构，允许随机访问</li><li>插入、删除操作效率低，查询效率高</li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>c.front()</code></td><td style="text-align: left;">返回第一个数据O(1)</td></tr><tr><td style="text-align: left;"><code>c.back()</code></td><td style="text-align: left;">返回数组中的最后一个数据 O(1)</td></tr><tr><td style="text-align: left;"><code>c.pop_back()</code></td><td style="text-align: left;">删除最后一个数据O(1）</td></tr><tr><td style="text-align: left;"><code>c.push_back(element)</code></td><td style="text-align: left;">在尾部加一个数据O(1)</td></tr><tr><td style="text-align: left;"><code>c.size()</code></td><td style="text-align: left;">返回实际数据个数（unsigned类型）O(1)</td></tr><tr><td style="text-align: left;"><code>c.clear()</code></td><td style="text-align: left;">清除元素个数O(N)，N为元素个数</td></tr><tr><td style="text-align: left;"><code>c.resize(n, v)</code></td><td style="text-align: left;">改变数组大小为<code>n</code>,<code>n</code>个空间数值赋为<code>v</code>，如果没有默认赋值为<code>0</code></td></tr><tr><td style="text-align: left;"><code>c.insert(it, x)</code></td><td style="text-align: left;">向任意迭代器<code>it</code>插入一个元素<code>x</code>，O(N)</td></tr><tr><td style="text-align: left;">例：<code>c.insert(c.begin() + 2,-1)</code></td><td style="text-align: left;">将<code>-1</code>插入<code>c[2]</code>的位置</td></tr><tr><td style="text-align: left;"><code>c.erase(first,last)</code></td><td style="text-align: left;">删除<code>[first,last)</code>的所有元素，O(N)</td></tr><tr><td style="text-align: left;"><code>c.begin()</code></td><td style="text-align: left;">返回首元素的迭代器（通俗来说就是地址）O(1)</td></tr><tr><td style="text-align: left;"><code>c.end()</code></td><td style="text-align: left;">返回最后一个元素后一个位置的迭代器（地址）O(1)</td></tr><tr><td style="text-align: left;"><code>c.empty()</code></td><td style="text-align: left;">判断是否为空，为空返回真，反之返回假O(1)</td></tr></tbody></table><h3 id="vector初始化">vector初始化</h3><p>vector的初始化常借助resize和assign</p><blockquote><p>resize的不指定value时的初始值如下：</p><p>int -- 0</p><p>string -- ""</p><p>bool -- false</p><p>double -- 0.0</p></blockquote><p>时间复杂度<span class="math inline">\(O(n)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span> &gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-comment">//resize不会改变原有数据，常用于初始化和拓展</span><br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);       <span class="hljs-comment">// 大小调整为5, 元素值默认 -&gt; &#123;1,2,3,0,0&#125;</span><br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">7</span>, <span class="hljs-number">10</span>);   <span class="hljs-comment">// 大小调整为7，每个元素初始化为10 -&gt; &#123;1,2,3,0,0,10,10&#125;</span><br><br><span class="hljs-comment">//assign会直接覆盖原有数据</span><br>v.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 用5个10填充v -&gt; &#123;10,10,10,10,10&#125;</span><br></code></pre></td></tr></table></figure><h3 id="vector复制操作">vector复制操作</h3><blockquote><p>C++中Vector的所有赋值方式都是<strong>深拷贝</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//1：赋值运算符</span><br>v2 = v1;  <span class="hljs-comment">// 拷贝 vec1 到 vec2</span><br><span class="hljs-comment">//2：拷贝构造函数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;<br><span class="hljs-comment">//3：assign</span><br>v<span class="hljs-number">2.</span><span class="hljs-built_in">assign</span>(vec<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), vec<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h2 id="stack栈">stack：栈</h2><ul><li>不允许sort排序</li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.push(ele)</code></td><td style="text-align: left;">元素<code>ele</code>入栈，增加元素O(1)</td></tr><tr><td style="text-align: left;"><code>s.pop()</code></td><td style="text-align: left;">移除栈顶元素 O(1)</td></tr><tr><td style="text-align: left;"><code>s.top()</code></td><td style="text-align: left;">取得栈顶元素（但不删除）O(1)</td></tr><tr><td style="text-align: left;"><code>s.empty()</code></td><td style="text-align: left;">检测栈内是否为空，空为真 O(1)</td></tr><tr><td style="text-align: left;"><code>s.size()</code></td><td style="text-align: left;">返回栈内元素的个数 O(1)</td></tr></tbody></table><ul><li><strong>数组模拟栈</strong></li></ul><p>通过一个<strong>数组</strong>对栈进行模拟，一个存放下标的变量<code>top</code>模拟指向栈顶的指针。</p><blockquote><p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或<code>hh</code> 来进行模拟</p></blockquote><p><strong>特点：</strong>比<code>STL</code>的<code>stack</code>速度更快，遍历元素方便</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sta[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 栈 从左至右为栈底到栈顶</span><br><span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// tt 代表栈顶指针,初始栈内无元素，tt为-1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">5</span>; ++i) &#123;<br>    <span class="hljs-comment">//入栈 </span><br>    sta[++top] = i;<br>&#125;<br><span class="hljs-comment">// 出栈</span><br><span class="hljs-type">int</span> top_element = sta[top--]; <br></code></pre></td></tr></table></figure><h2 id="queue队列">queue：队列</h2><ul><li>不允许sort排序</li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>q.front()</code></td><td style="text-align: left;">返回队首元素 O(1)</td></tr><tr><td style="text-align: left;"><code>q.back()</code></td><td style="text-align: left;">返回队尾元素 O(1)</td></tr><tr><td style="text-align: left;"><code>q.push(element)</code></td><td style="text-align: left;">尾部添加一个元素<code>element</code>进队O(1)</td></tr><tr><td style="text-align: left;"><code>q.pop()</code></td><td style="text-align: left;">删除第一个元素 出队 O(1)</td></tr><tr><td style="text-align: left;"><code>q.size()</code></td><td style="text-align: left;">返回队列中元素个数，返回值类型<code>unsigned int</code>O(1)</td></tr><tr><td style="text-align: left;"><code>q.empty()</code></td><td style="text-align: left;">判断是否为空，队列为空，返回<code>true</code>O(1)</td></tr></tbody></table><ul><li><strong>数组模拟队列</strong></li></ul><p>使用<code>q[]</code>数组模拟队列</p><p><code>rear</code>表示队尾元素的下标，初始值为<code>0</code></p><p><code>front</code>表示队首元素的下标，初始值为<code>0</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>,rear = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//   入队 </span><br>    q[rear++] = <span class="hljs-number">1</span>;<br>    q[rear++] = <span class="hljs-number">2</span>; <br><span class="hljs-comment">//    出队 </span><br>    <span class="hljs-keyword">while</span>(front != rear) &#123;<br>        <span class="hljs-type">int</span> t = q[front++];<br>        cout&lt;&lt;t&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure><h2 id="deque双端队列">deque：双端队列</h2><ul><li>和vectot一样，可以随机访问，也可以sort排序</li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>push_back(x)/push_front(x)</code></td><td style="text-align: left;">把<code>x</code>插入队尾后 / 队首O(1)</td></tr><tr><td style="text-align: left;"><code>back()/front()</code></td><td style="text-align: left;">返回队尾 / 队首元素 O(1)</td></tr><tr><td style="text-align: left;"><code>pop_back() / pop_front()</code></td><td style="text-align: left;">删除队尾 / 队首元素 O(1)</td></tr><tr><td style="text-align: left;"><code>erase(iterator it)</code></td><td style="text-align: left;">删除双端队列中的某一个元素</td></tr><tr><td style="text-align: left;"><code>erase(iterator first,iterator last)</code></td><td style="text-align: left;">删除双端队列中<code>[first,last)</code>中的元素</td></tr><tr><td style="text-align: left;"><code>empty()</code></td><td style="text-align: left;">判断deque是否空 O(1)</td></tr><tr><td style="text-align: left;"><code>size()</code></td><td style="text-align: left;">返回deque的元素数量 O(1)</td></tr><tr><td style="text-align: left;"><code>clear()</code></td><td style="text-align: left;">清空deque</td></tr></tbody></table><h2 id="priority_queue优先队列堆">priority_queue：优先队列（堆）</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>q.top()</code></td><td style="text-align: left;">访问队首元素 O(1)</td></tr><tr><td style="text-align: left;"><code>q.push()</code></td><td style="text-align: left;">入队 O(logN)</td></tr><tr><td style="text-align: left;"><code>q.pop()</code></td><td style="text-align: left;">堆顶（队首）元素出队 O(logN)</td></tr><tr><td style="text-align: left;"><code>q.size()</code></td><td style="text-align: left;">队列元素个数 O(1)</td></tr><tr><td style="text-align: left;"><code>q.empty()</code></td><td style="text-align: left;">是否为空 O(1)</td></tr><tr><td style="text-align: left;"><strong>注意</strong>没有<code>clear()</code>！</td><td style="text-align: left;">不提供该方法</td></tr><tr><td style="text-align: left;">优先队列只能通过<code>top()</code>访问队首元素（优先级最高的元素）</td><td style="text-align: left;"></td></tr></tbody></table><ul><li>大小根堆的设置方法，也可以自定义比较函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-type">int</span>&gt; pq; <span class="hljs-comment">// 默认大根堆, 即每次取出的元素是队列中的最大值 </span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">// 小根堆, 每次取出的元素是队列中的最小值</span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; q <span class="hljs-comment">//大根堆</span><br>    <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp1</span> &#123; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x &gt; y; &#125; &#125;; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp2</span> &#123; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x &lt; y; &#125; &#125;; priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp1&gt; q1; <span class="hljs-comment">//小根堆 </span><br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp2&gt; q2; <span class="hljs-comment">// 大根堆</span><br></code></pre></td></tr></table></figure><h2 id="set集合红黑树">set：集合（红黑树）</h2><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.begin()</code></td><td style="text-align: left;">返回set容器的第一个元素的地址（迭代器）O(1)</td></tr><tr><td style="text-align: left;"><code>s.end()</code></td><td style="text-align: left;">返回set容器的最后一个元素的下一个地址（迭代器）O(1)</td></tr><tr><td style="text-align: left;"><code>s.rbegin()</code></td><td style="text-align: left;">返回逆序迭代器，指向容器元素最后一个位置O(1)</td></tr><tr><td style="text-align: left;"><code>s.rend()</code></td><td style="text-align: left;">返回逆序迭代器，指向容器第一个元素前面的位置O(1)</td></tr><tr><td style="text-align: left;"><code>s.clear()</code></td><td style="text-align: left;">删除set容器中的所有的元素,返回unsignedint类型O(N)</td></tr><tr><td style="text-align: left;"><code>s.empty()</code></td><td style="text-align: left;">判断set容器是否为空O(1)</td></tr><tr><td style="text-align: left;"><code>s.insert()</code></td><td style="text-align: left;">插入一个元素 O（log n）</td></tr><tr><td style="text-align: left;"><code>s.size()</code></td><td style="text-align: left;">返回当前set容器中的元素个数O(1)</td></tr><tr><td style="text-align: left;"><code>erase(iterator)</code></td><td style="text-align: left;">删除定位器iterator指向的值</td></tr><tr><td style="text-align: left;"><code>erase(first,second）</code></td><td style="text-align: left;">删除定位器first和second之间的值</td></tr><tr><td style="text-align: left;"><code>erase(key_value)</code></td><td style="text-align: left;">删除键值key_value的值</td></tr><tr><td style="text-align: left;">查找</td><td style="text-align: left;"></td></tr><tr><td style="text-align: left;"><code>s.find(element)</code></td><td style="text-align: left;">查找set中的某一元素，有则返回该元素对应的迭代器，无则返回s.end()O(logN)</td></tr><tr><td style="text-align: left;"><code>s.count(element)</code></td><td style="text-align: left;">返回set中的元素出现的个数，由于set中无重复元素，只能返回0和 1。此函数相当于查询element是否出现 &gt; O(logN)</td></tr><tr><td style="text-align: left;"><code>s.lower_bound(k)</code></td><td style="text-align: left;">返回大于等于k的第一个元素的迭代器O(logN)</td></tr><tr><td style="text-align: left;"><code>s.upper_bound(k)</code></td><td style="text-align: left;">返回大于k的第一个元素的迭代器O(logN)</td></tr></tbody></table><h2 id="map映射红黑树">map：映射（红黑树）</h2><ul><li><p>优点：</p><ul><li><p>map元素有序（这是map最大的优点，其元素的有序性在很多应用中都会简化很多的操作）；</p></li><li><p>其红黑树的结构使得map的很多操作都可在O(logn)下完成；</p></li><li><p>map的各项性能较为稳定，与元素插入顺序无关；</p></li><li><p>map支持范围查找。</p></li></ul></li><li><p>缺点：</p><ul><li><p>占用的空间大：红黑树的每一个节点需要保存其父节点位置、孩子节点位置及红/黑性质，因此每一个节点占用空间大。</p></li><li><p>查询平均时间不如unordered_map。</p></li></ul></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>mp.find(key)</code></td><td style="text-align: left;">返回键为key的映射的迭代器存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()O(logN)</td></tr><tr><td style="text-align: left;"><code>mp.erase(it)</code></td><td style="text-align: left;">删除迭代器对应的键和值O(1)</td></tr><tr><td style="text-align: left;"><code>mp.erase(key)</code></td><td style="text-align: left;">根据映射的键删除键和值 O(logN)</td></tr><tr><td style="text-align: left;"><code>mp.erase(first,last)</code></td><td style="text-align: left;">删除左闭右开区间迭代器对应的键和值O(last−first)</td></tr><tr><td style="text-align: left;"><code>mp.size()</code></td><td style="text-align: left;">返回映射的对数O(1)</td></tr><tr><td style="text-align: left;"><code>mp.clear()</code></td><td style="text-align: left;">清空map中的所有元素O(N)</td></tr><tr><td style="text-align: left;"><code>mp.insert()</code></td><td style="text-align: left;">插入元素，插入时要构造键值对</td></tr><tr><td style="text-align: left;"><code>mp.empty()</code></td><td style="text-align: left;">如果map为空，返回true，否则返回false</td></tr><tr><td style="text-align: left;"><code>mp.begin()</code></td><td style="text-align: left;">返回指向map第一个元素的迭代器（地址）</td></tr><tr><td style="text-align: left;"><code>mp.end()</code></td><td style="text-align: left;">返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td></tr><tr><td style="text-align: left;"><code>mp.rbegin()</code></td><td style="text-align: left;">返回指向map最后一个元素的迭代器（地址）</td></tr><tr><td style="text-align: left;"><code>mp.rend()</code></td><td style="text-align: left;">返回指向map第一个元素前面(上一个）的逆向迭代器（地址）</td></tr><tr><td style="text-align: left;"><code>mp.count(key)</code></td><td style="text-align: left;">查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td></tr><tr><td style="text-align: left;"><code>mp.lower_bound()</code></td><td style="text-align: left;">返回一个迭代器，指向键值&gt;=key的第一个元素</td></tr><tr><td style="text-align: left;"><code>mp.upper_bound()</code></td><td style="text-align: left;">返回一个迭代器，指向键值&gt;key的第一个元素</td></tr></tbody></table><h2 id="unordered_map哈希表">unordered_map：哈希表</h2><p>unorder_map是链式存储法的哈希表，每个key值对应的链表，叫做一个“桶”</p><ul><li>优点：<ul><li>查询速度快，平均性能接近于常数时间<strong>O(1)</strong>；</li></ul></li><li>缺点：<ul><li>元素无序；</li><li>unordered_map相对于map空间占用更大，且其利用率不高；</li><li>查询性能不太稳定，最坏时间复杂度可达到<strong>O(n)</strong>。</li></ul></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>mp.begin()</code></td><td>返回指向map第一个元素的迭代器（地址）</td></tr><tr><td><code>mp.end()</code></td><td>返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td></tr><tr><td><code>mp.empty()</code></td><td>空则返回true，非空返回false</td></tr><tr><td><code>mp.size()</code></td><td>返回哈希表的大小</td></tr><tr><td><code>mp.at(key)</code></td><td>根据key值，查找value，若不存在，抛出异常</td></tr><tr><td><code>mp.find(key)</code></td><td>存在该key值则返回该位置上的迭代器，否则返回mp.end()</td></tr><tr><td><code>mp.clear()</code></td><td>清空表</td></tr><tr><td><code>mp.find(key)</code></td><td>存在该key值则返回该位置上的迭代器，否则返回mp.end()</td></tr><tr><td><code>mp.count(key)</code></td><td>该key值对应value存在，返回1，否则为0</td></tr><tr><td><code>mp.emplace(key)</code></td><td>向容器中添加新键值对（旧值不会被新值覆盖），效率对比insert()高</td></tr><tr><td><code>mp.insert(pair)</code></td><td>向容器中添加新键值对（旧值被新值覆盖）</td></tr></tbody></table><ul><li>mp[key] = value 和insert（pair）都会覆盖旧value，而emplace不会。</li></ul><h2 id="string字符串">string：字符串</h2><ul><li>运算符特性：</li></ul><p>1.支持比较运算符<code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>。支持<code>string</code>与<code>C-string</code>的比较（如<code>str &lt; "hello"</code>）。</p><p>在使用<code>&gt;,&gt;=,&lt;,&lt;=</code>这些操作符的时候是根据“当前字符特性”将字符按<code>字典顺序</code> 进行逐一得 比较。</p><p>字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p><p>2.支持<code>+</code><strong>运算</strong>符，代表拼接字符串：string字符串可以拼接，通过”+”运算符进行拼接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;123&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;456&quot;</span>;<br>string s = s1 + s2;<br>cout &lt;&lt; s;   <span class="hljs-comment">//123456</span><br></code></pre></td></tr></table></figure><ul><li><strong>获取字符串长度</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.size()</code>和<code>s.length()</code></td><td style="text-align: left;">返回string对象的字符个数，他们执行效果相同</td></tr><tr><td style="text-align: left;"><code>s.max_size()</code></td><td style="text-align: left;">返回string对象最多包含的字符数，超出会抛出length_error异常</td></tr><tr><td style="text-align: left;"><code>s.capacity()</code></td><td style="text-align: left;">重新分配内存之前，string对象能包含的最大字符数</td></tr></tbody></table><ul><li><strong>插入</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.push_back()</code></td><td style="text-align: left;">在末尾插入</td></tr><tr><td style="text-align: left;"><code>s.insert(pos,str)</code></td><td style="text-align: left;">在pos位置后插入str</td></tr><tr><td style="text-align: left;"><code>s.append(str)</code></td><td style="text-align: left;">在s字符串结尾添加str字符串</td></tr></tbody></table><ul><li><strong>删除</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>erase(iterator p)</code></td><td style="text-align: left;">删除字符串中p所指的字符</td></tr><tr><td style="text-align: left;"><code>erase(iterator first, iterator last)</code></td><td style="text-align: left;">删除字符串中迭代器区间<code>[first,last)</code>上所有字符</td></tr><tr><td style="text-align: left;"><code>erase(pos, len)</code></td><td style="text-align: left;">删除字符串中从索引位置pos开始的len个字符</td></tr><tr><td style="text-align: left;"><code>clear()</code></td><td style="text-align: left;">删除字符串中所有字符</td></tr></tbody></table><ul><li><strong>字符替换</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.replace(pos,n,str)</code></td><td style="text-align: left;">把当前字符串从索引pos开始的n个字符替换为str</td></tr><tr><td style="text-align: left;"><code>s.replace(pos,n,n1,c)</code></td><td style="text-align: left;">把当前字符串从索引pos开始的n个字符替换为n1个字符c</td></tr><tr><td style="text-align: left;"><code>s.replace(it1,it2,str)</code></td><td style="text-align: left;">把当前字符串<code>[it1,it2)</code>区间替换为str<strong>it1 ,it2为迭代器哦</strong></td></tr></tbody></table><ul><li><strong>大小写转换</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>tolower(s[i])</code></td><td style="text-align: left;">转换为小写</td></tr><tr><td style="text-align: left;"><code>toupper(s[i])</code></td><td style="text-align: left;">转换为大写</td></tr></tbody></table><ul><li><strong>分割</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.substr(pos,n)</code></td><td style="text-align: left;">截取从pos索引开始的n个字符</td></tr></tbody></table><ul><li><strong>查找</strong></li></ul><table><thead><tr><th style="text-align: left;">代码</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr><td style="text-align: left;"><code>s.find (str, pos)</code></td><td style="text-align: left;">在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td></tr><tr><td style="text-align: left;"><code>s.find (c, pos)</code></td><td style="text-align: left;">在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td style="text-align: left;"><code>s.rfind (str, pos)</code></td><td style="text-align: left;">在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</td></tr><tr><td style="text-align: left;"><code>s.rfind (c, pos)</code></td><td style="text-align: left;">在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td style="text-align: left;"><code>s.find_first_of (str, pos)</code></td><td style="text-align: left;">在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td style="text-align: left;"><code>s.find_first_not_of (str,pos)</code></td><td style="text-align: left;">在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td style="text-align: left;"><code>s.find_last_of(str, pos)</code></td><td style="text-align: left;">在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td style="text-align: left;"><code>s.find_last_not_of ( str, pos)</code></td><td style="text-align: left;">在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</td></tr></tbody></table><h2 id="sort排序">sort：排序</h2><p><strong>O(NlogN)</strong></p><ul><li>对数组正常升序排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(a , a + n);<br>vector&lt;<span class="hljs-type">int</span>&gt; v; <span class="hljs-comment">// vector数组定义</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><ul><li>使用第三个参数，进行降序排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(a, a + n, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-built_in">sort</span>(a, a + n, <span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure><ul><li>自定义排序规则</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.x &gt; b.x;<br>&#125;<br><span class="hljs-built_in">sort</span>(node, node + n, cmp); <br><span class="hljs-comment">// 只接受以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则</span><br></code></pre></td></tr></table></figure><ul><li>stable_sort使用方法和sort一样，但排序时不会改变相等元素的相对位置，是稳定排序</li></ul><h1 id="stl函数">STL函数</h1><h2 id="有序序列的二分查找">有序序列的二分查找</h2><p><a href="https://blog.csdn.net/weixin_28712713/article/details/80922917">45正确区分count、find、binary_search、lower_bound、upper_bound和equal_range_findlowbound-CSDN博客</a></p><figure><img src="/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/STL%E5%AE%B9%E5%99%A8%E6%B1%87%E6%80%BB/70.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p><strong>1.binary_search</strong></p><p>找得到返回1，找不到返回0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>, <span class="hljs-number">98</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-built_in">sort</span>(a, a<span class="hljs-number">+6</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-number">12</span>) &lt;&lt; endl;<span class="hljs-comment">//1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-number">77</span>) &lt;&lt; endl;<span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>如果sort中使用了自定义排序规则，binary_search里一样要引用该参数</p><p>结构体写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rule</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a2)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a1%<span class="hljs-number">10</span> &lt; a2%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>, <span class="hljs-number">98</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-built_in">sort</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-built_in">Rule</span>());<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-number">8</span>, <span class="hljs-built_in">Rule</span>()) &lt;&lt; endl;<br><span class="hljs-comment">// 注意：这里查找的是 x % 10 == 8, 而不是 x == 8；</span><br></code></pre></td></tr></table></figure><p>函数写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a1%<span class="hljs-number">10</span> &lt; a2%<span class="hljs-number">10</span>;<br>&#125;;<br><br><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>, <span class="hljs-number">98</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-built_in">sort</span>(a, a<span class="hljs-number">+6</span>, cmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span> &lt;&lt; <span class="hljs-built_in">binary_search</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-number">8</span>, cmp) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><strong>2.lower_bound、upper_bound</strong></p><p>使用方法和bianry_search一样，lower_bound返回的是一个 &gt;=查找元素的迭代器/指针，upper_bound为 &gt; 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a1, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; a2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a1%<span class="hljs-number">10</span> &lt; a2%<span class="hljs-number">10</span>;<br>&#125;;<br><br><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>, <span class="hljs-number">98</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-built_in">sort</span>(a, a<span class="hljs-number">+6</span>, cmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span> &lt;&lt; *<span class="hljs-built_in">lower_bound</span>(a, a<span class="hljs-number">+6</span>, <span class="hljs-number">8</span>, cmp) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="getline">getline</h2><p><strong>读入字符串，遇空格，回车结束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s; cin &gt;&gt; s;<br></code></pre></td></tr></table></figure><p><strong>读入一行字符串（包括空格），遇回车结束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s; <span class="hljs-built_in">getline</span>(cin, s);<br></code></pre></td></tr></table></figure><p>注意:<code>getline(cin, s)</code>会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code>或<code>cin.get()</code></p><p>错误读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>string s;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">getline</span>(cin, s); <span class="hljs-comment">//此时读取相当于读取了前一个回车字符</span><br></code></pre></td></tr></table></figure><p>正确读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>string s;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">getchar</span>(); <span class="hljs-comment">//cin.get()</span><br><span class="hljs-built_in">getline</span>(cin, s);<span class="hljs-comment">//可正确读入下一行的输入</span><br></code></pre></td></tr></table></figure><h2 id="set_unionintersectiondifference并集交集差集">set_union/intersection/difference：并集/交集/差集</h2><p>set_union, set_intersection,set_difference：</p><p><strong>复杂度：O(N+M)</strong></p><p>注意：两个集合必须为<strong>有序集合</strong>，所以下面演示代码使用了排序。</p><p>vector容器可以替换成set容器，因为set自动会对元素进行排序。</p><p>函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>&#125;, b = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 1 2 4 5 8</span><br><span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 2 3 5 8 9</span><br>vector&lt;<span class="hljs-type">int</span>&gt; c, d, e;<br><span class="hljs-comment">// a并b：1 2 3 4 5 8 9</span><br><span class="hljs-built_in">set_union</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(c, c.<span class="hljs-built_in">begin</span>()));<br><span class="hljs-comment">// a交b：2 5 8</span><br><span class="hljs-built_in">set_intersection</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(d, d.<span class="hljs-built_in">begin</span>()));<br><span class="hljs-comment">// a差b： 1 4</span><br><span class="hljs-built_in">set_difference</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(e, e.<span class="hljs-built_in">begin</span>()));<br></code></pre></td></tr></table></figure><h2 id="reverse翻转序列">reverse：翻转序列</h2><p><strong>复杂度： O(N)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverse</span>(beg,end)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span> &gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-comment">//1,2,3,4,5</span><br><span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//v == 5,4,3,2,1</span><br></code></pre></td></tr></table></figure><h2 id="unique删除重复元素">unique：删除重复元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">unique</span>(beg, end)<br></code></pre></td></tr></table></figure><p><strong>复杂度：</strong> O(N)</p><p>用于去除相邻的重复元素</p><p>unique函数返回一个指向去重后的末尾指针，但是数组size没有改变，需要删除操作</p><p>同样兼容c数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//v == 1，2，3，2，2，2，3，3，3</span><br>v.<span class="hljs-built_in">erase</span>(it,v.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//v == 1，2，3</span><br></code></pre></td></tr></table></figure><h2 id="next_permutation全排列函数">next_permutation：全排列函数</h2><p><strong>复杂度：</strong> O(N)</p><p>next_permutation：如果数组存在下一个全排列，返回 bool =1，并移动到下一位，否则返回0</p><p>perv_permutaion是前者的逆操作</p><p>这两个函数同样兼容c数组，操作与vector相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()))&#123;<br><span class="hljs-type">int</span> len = v.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i ++)&#123;<br>cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="auto">auto</h2><p>auto可以根据等号后面的值来自动适配变量类型，也可以简化遍历书写</p><p>常见用法：</p><p>for(auto x : range) // 拷贝元素 for(auto &amp;&amp;x : range)//修改元素 for(const auto &amp;x : range) // 只读元素（无法修改）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span> &gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : v)&#123;<br>i = <span class="hljs-number">2</span>*i;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br><span class="hljs-comment">//2 4 6 8 10 12 14</span><br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span> &gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>() ; it ++)&#123;<br>cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">//auto：</span><br><span class="hljs-comment">//1 2 3 4 5 6 7</span><br><span class="hljs-comment">//auto &amp;&amp;：</span><br><span class="hljs-comment">//2 4 6 8 10 12 14</span><br><span class="hljs-comment">//const auto &amp;,报错</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA最近公共祖先</title>
    <link href="/algorithm/%E5%88%86%E6%B2%BB/LCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/algorithm/%E5%88%86%E6%B2%BB/LCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h1 id="lca最近公共祖先">LCA最近公共祖先</h1><p>模板题：<a href="https://www.luogu.com.cn/problem/P3379">P3379【模板】最近公共祖先（LCA） - 洛谷 | 计算机科学教育新生态(luogu.com.cn)</a></p><blockquote><p>在“Lowest Common Ancestor”中，“lowest”的含义与常规理解有些不同，</p><p>指的是最深的公共祖先，而不是最接近树根的节点。</p></blockquote><blockquote><p>LCA适用于多叉树（有向无环图），而不仅仅是二叉树。</p></blockquote><figure><img src="/algorithm/%E5%88%86%E6%B2%BB/LCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/3030388996.png" alt="LCA2.png"><figcaption aria-hidden="true">LCA2.png</figcaption></figure><h2 id="倍增">倍增</h2><p>倍增是用的最多的LCA<strong>在线</strong>算法，其复杂度为 <span class="math inline">\(O(nlogn+mlogn)\)</span> [n为点数，m为询问数]</p><p>倍增求解LCA的过程分为2个步骤：</p><p>1）将两点的深度置为相同；</p><p>2）同时向根移动两点，查找公共祖先；</p><p>若使用朴素遍历，时间复杂度为<span class="math inline">\(O(n)\)</span>，必然导致超时。</p><p>但这2个过程可以使用倍增优化：无论是步骤1）还是步骤2），虽然向上移动的距离未知，但我们知道是一个固定的整数。</p><p>因此，可以将距离按二进制进行分解，使用倍增的思想依次移动。</p><p>模板题：<a href="https://www.luogu.com.cn/problem/P3379">P3379【模板】最近公共祖先（LCA） - 洛谷</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, m, s;<br>vector&lt;<span class="hljs-type">int</span> &gt; e[maxn];<br><span class="hljs-type">int</span> lg[maxn],dep[maxn],fa[maxn][<span class="hljs-number">30</span>];<br><br><span class="hljs-comment">// LCA预处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br>dep[x] = dep[f] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化深度</span><br><span class="hljs-comment">// 预处理该点的父亲数组</span><br>fa[x][<span class="hljs-number">0</span>] = f;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; (<span class="hljs-number">1</span>&lt;&lt;i) &lt;= dep[x] ; i ++)&#123;<br>fa[x][i] = fa[fa[x][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(it != f)&#123;<br><span class="hljs-built_in">dfs</span>(it, x);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n<span class="hljs-number">-1</span> ; i ++)&#123;<br><span class="hljs-type">int</span> x, y; cin&gt;&gt;x&gt;&gt;y;<br>e[x].<span class="hljs-built_in">push_back</span>(y);<br>e[y].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br>lg[i] = lg[i/<span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-comment">// 将2点的深度置为相同</span><br><span class="hljs-keyword">if</span>(dep[a] &lt; dep[b]) <span class="hljs-built_in">swap</span>(a, b);<br><span class="hljs-keyword">while</span>(dep[a] != dep[b])&#123;<br>a = fa[a][lg[dep[a] - dep[b]]];<br>&#125;<br><span class="hljs-keyword">if</span>(a == b) <span class="hljs-keyword">return</span> a;<br><span class="hljs-comment">// a或b到公共祖先的长度一定是一个正整数</span><br><span class="hljs-comment">// 可以用二进制分解，并倍增处理</span><br><span class="hljs-comment">// 倍增查询公共父亲</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = lg[dep[a]] ; i &gt;= <span class="hljs-number">0</span> ; i --)&#123;<br><span class="hljs-keyword">if</span>(fa[a][i] != fa[b][i])&#123;<br>a = fa[a][i];<br>b = fa[b][i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> fa[a][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> a, b; cin&gt;&gt;a&gt;&gt;b;<br>cout&lt;&lt;<span class="hljs-built_in">lca</span>(a, b)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tarjan">Tarjan</h2><p>Tarjan是求解LCA唯一的<strong>离线</strong>算法，其时间复杂度达到了<span class="math inline">\(O(n+m)\)</span>。</p><p>参考：<a href="https://www.cnblogs.com/JVxie/p/4854719.html">最近公共祖先LCA(Tarjan算法)的思考和算法实现- JVxie - 博客园 (cnblogs.com)</a></p><p>Tarjan的基本逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span>从根节点开始进行<span class="hljs-built_in">DFS</span> (设当前遍历到节点u，其子节点为v);<br><span class="hljs-number">2.</span>若u还存在没访问过的子节点，继续遍历，否则进行操作<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>；<br><span class="hljs-number">3.</span>将u标记为”访问过“<br><span class="hljs-number">4.</span>在并查集中，将v合并到u上,并标记节点v已被访问过；<br><span class="hljs-number">5.</span>寻找与当前点u有询问关系的点x，若点x已经被访问过，那么lca（u,x）= <span class="hljs-built_in">find</span>(u)；<br></code></pre></td></tr></table></figure><p>Tarjan函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> f)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : e[x])&#123;<br><span class="hljs-keyword">if</span>(!visited[it] &amp;&amp; it != f)&#123;<br><span class="hljs-built_in">tarjan</span>(it, x);<br><span class="hljs-built_in">join</span>(x, it);<br>&#125;<br>&#125;<br>visited[x] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; it : q[x])&#123;<br><span class="hljs-type">int</span> t = it.first;<br><span class="hljs-type">int</span> i = it.second;<br><span class="hljs-keyword">if</span>(visited[t])&#123;<br>ans[i] = <span class="hljs-built_in">find</span>(t);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>询问关系的存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; q[MAX];<br><span class="hljs-comment">//first - 端点 ；second - 下标 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; m ; i ++)&#123;<br>    <span class="hljs-type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;<br>    q[u].<span class="hljs-built_in">push_back</span>(&#123;v,i&#125;);<br>    q[v].<span class="hljs-built_in">push_back</span>(&#123;u,i&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>分治</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/algorithm/%E5%9B%BE%E8%AE%BA/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/algorithm/%E5%9B%BE%E8%AE%BA/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集">并查集</h1><h2 id="概念">概念</h2><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。</p><h2 id="实现">实现</h2><p>属性： pre[]：记录每个结点的先驱结点size[]：记录当前结点所属集合的大小 count：记录连通分量的个数 方法：查找代表元（find）：查找当前结点所属集合的代表元，树形结构，我们可以通过pre逐层向上查找，一直找到根节点即为当前集合的代表元。（这里的代表元就是一个集合中的代表元素，如果两个元素的代表元相同，则这两个元素属于同一集合）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (pre[x] == x) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br></code></pre></td></tr></table></figure><p>合并（connect）：合并两个结点，我们通过pre[y]=x，将y结点连接到x上，这里我们为了减少find函数的迭代次数，我们总是把小的集合连接到大的集合上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        x = <span class="hljs-built_in">find</span>(x);<br>        y = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y])<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        pre[y] = x;<br>        size[x] += size[y];<br>        count--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询（isconnect）：判断两个结点是否属于同一集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>&#125;<br></code></pre></td></tr></table></figure><p>断开连接（disconnect）：将当前结点断开与其上层节点的连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        pre[x] = x;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; pre;<br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        count = n;<br>        pre.<span class="hljs-built_in">resize</span>(n);<br>        size.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            pre[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (pre[x] == x)<br>            <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        x = <span class="hljs-built_in">find</span>(x);<br>        y = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y])<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        pre[y] = x;<br>        size[x] += size[y];<br>        count--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        pre[x] = x;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="模板">模板</h1><p><a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集- 洛谷 | 计算机科学教育新生态</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pre[MAX],n,t;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>pre[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(pre[x] == x) <span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x);<br><span class="hljs-type">int</span> fy = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(fx != fy) pre[fx] = fy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;t;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">while</span>(t--)&#123;<br><span class="hljs-type">int</span> z,x,y;<br>cin&gt;&gt;z&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">if</span>(z == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">Union</span>(x,y);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;(<span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y)?<span class="hljs-string">&quot;Y&quot;</span>:<span class="hljs-string">&quot;N&quot;</span>)&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树算法合集</title>
    <link href="/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/"/>
    <url>/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树基本性质">二叉树基本性质</h1><p>性质1：在二叉树的第 <span class="math inline">\(i\)</span> 层上至多有<span class="math inline">\(2^{i-1}\)</span> 个结点（i&gt;=1）</p><p>性质2：深度为 <span class="math inline">\(k\)</span> 的二叉树至多有<span class="math inline">\(2^k-1\)</span> 个结点（k&gt;=1）</p><p>性质3：对于任何一颗二叉树T，如果其终端结点数为<span class="math inline">\(n_0\)</span>，度为2的结点数为<span class="math inline">\(n_2\)</span>，则<span class="math inline">\(n_0=n_2+1\)</span></p><blockquote><p>原理：点数 = 边数 + 1</p><p>由 <span class="math inline">\(n = n0 + n1 + n2 = 2*n2 + n1 +1\)</span> 得 <span class="math inline">\(n_0=n_2+1\)</span></p></blockquote><p>性质4：具有n个节点的<strong>完全二叉树</strong>深为<span class="math inline">\(log_2{k}+1\)</span></p><p>性质5：如果对一颗有n个结点的<strong>完全二叉树</strong>（其深度为<span class="math inline">\([log_2n]+1\)</span>）的结点按层序编号（从第1层到<span class="math inline">\([log_2n]+1\)</span>层，每层从左到右），对任一结点i（1&lt;=i&lt;=n）:</p><p>（1）如果<span class="math inline">\(i=1\)</span>，则结点i是二叉树的根，无双亲，如果<span class="math inline">\(i&gt;1\)</span>,则其双亲结点是结点<span class="math inline">\([i/2]\)</span> （2）如果<span class="math inline">\(2i&gt;n\)</span>，则结点i无左孩子（结点i为叶子结点）否则左孩子是结点<span class="math inline">\(2i\)</span>。 （3）如果<span class="math inline">\(2i+1&gt;n\)</span>,则结点i无右孩子，否则其右孩子是结点<span class="math inline">\(2i+1\)</span>.</p><blockquote><p>若根节点从0开始，左 = <span class="math inline">\(2i + 1\)</span>，右= <span class="math inline">\(2i+2\)</span></p></blockquote><h1 id="节点数据结构">节点数据结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> val;<br>node * l;<br>node * r;<br><br><span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> val_)&#123;<br>val = val_;<br>        l = <span class="hljs-literal">nullptr</span>;<br>        r = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的遍历">二叉树的遍历</h1><p>先序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br>pre.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">preTra</span>(p-&gt;l);<br><span class="hljs-built_in">preTra</span>(p-&gt;r);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>pre.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">preTra</span>(p-&gt;r);<br><span class="hljs-built_in">preTra</span>(p-&gt;l);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br><span class="hljs-built_in">inTra</span>(p-&gt;l);<br>        in.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">inTra</span>(p-&gt;r);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">inTra</span>(p-&gt;r);<br>in.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br><span class="hljs-built_in">inTra</span>(p-&gt;l);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br><span class="hljs-built_in">postTra</span>(p-&gt;l);<br><span class="hljs-built_in">postTra</span>(p-&gt;r);<br>post.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">postTra</span>(p-&gt;r);<br><span class="hljs-built_in">postTra</span>(p-&gt;l);<br>post.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>层序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">layerTra</span><span class="hljs-params">(node * p)</span></span>&#123;<br>queue&lt;node *&gt; q;<br>q.<span class="hljs-built_in">push</span>(p);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>node * f = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>layer.<span class="hljs-built_in">push_back</span>(q-&gt;val);<br><br><span class="hljs-keyword">if</span>(f-&gt;l != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(f-&gt;l);<br><span class="hljs-keyword">if</span>(f-&gt;r != <span class="hljs-literal">nullptr</span>) q.<span class="hljs-built_in">push</span>(f-&gt;r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的建树">二叉树的建树</h1><h2 id="t1--已知后序和中序遍历">T1--已知后序和中序遍历</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805349394006016&amp;page=1">1127ZigZagging on a Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><blockquote><p>后序和中序遍历唯一地确定一颗二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> postl, <span class="hljs-type">int</span> postr, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(postl &gt; postr) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-type">int</span> i = inl;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != post[postr]) i++;<br><br>node* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(in[i]);<br>p-&gt;l = <span class="hljs-built_in">create</span>(postl, postl + (i - inl) - <span class="hljs-number">1</span>, inl, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//注意：这里不能改成（r-inl），因为左右子树未必节点数相同</span><br>p-&gt;r = <span class="hljs-built_in">create</span>(postl + (i - inl), postr - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, inr);<br><br><span class="hljs-keyword">return</span> p;<br>&#125;<br>node * root = <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h2 id="t2--已知先序和中序遍历">T2--已知先序和中序遍历</h2><blockquote><p>前序和中序遍历唯一地确定一颗二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(prel &gt; prer) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-type">int</span> i = inl;<br>    <span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != pre[prel]) i++;<br>    <br>    node * p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(in[i]);<br>    p-&gt;l = <span class="hljs-built_in">create</span>(prel<span class="hljs-number">+1</span>, prel + (i-inl), inl, i<span class="hljs-number">-1</span>);<br>    p-&gt;r = <span class="hljs-built_in">create</span>(prel + (i-inl) + <span class="hljs-number">1</span>, prer, i<span class="hljs-number">+1</span>, inr);<br>    <br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br>node * root = <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h2 id="t3--已知层序和中序遍历">T3--已知层序和中序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> layerl, <span class="hljs-type">int</span> layerr, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(layerl &gt; layerr)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-type">int</span> i = inl;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != layer[layerl]) i++;<br><br>node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(in[i]);<br>p-&gt;l = <span class="hljs-built_in">create</span>(layerl<span class="hljs-number">+1</span>, layerl + (i-inl) ,inl, i<span class="hljs-number">-1</span>);<br>p-&gt;r = <span class="hljs-built_in">create</span>(layerl+(i-inl)<span class="hljs-number">+1</span>, layerr, i<span class="hljs-number">+1</span>, inr);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="t4--已知先序和后序遍历不唯一">T4--已知先序和后序遍历（不唯一）</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805353470869504&amp;page=1">1119Pre- and Post-order Traversals - PAT (Advanced Level) Practice(pintia.cn)</a></p><blockquote><p>已知先序和后序遍历可能无法唯一地确定二叉树</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> postl, <span class="hljs-type">int</span> postr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel == prer)&#123;<br>node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(pre[prel]);<br><span class="hljs-keyword">return</span> p;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>node *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(pre[prel]);<br><span class="hljs-type">int</span> i = prel<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= prer &amp;&amp; pre[i] != post[postr<span class="hljs-number">-1</span>]) i++;<span class="hljs-comment">//找到后序遍历倒数第二个点，即右子树的第一个点</span><br><span class="hljs-keyword">if</span>(i - prel - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)&#123; <br>p-&gt;l = <span class="hljs-built_in">create</span>(prel<span class="hljs-number">+1</span>, i<span class="hljs-number">-1</span>, postl, postl+(i-prel<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//若左子树为空，那么右子树第一个点可能在左子树，也可能在右子树。此处我们将该点放在右子树</span><br>Unique = <span class="hljs-literal">false</span>;<br>&#125;<br>p-&gt;r = <span class="hljs-built_in">create</span>(i, prer, postl+(i-prel<span class="hljs-number">-1</span>), postr<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br>&#125;<br>node * root = <span class="hljs-built_in">create</span>(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br></code></pre></td></tr></table></figure><h1 id="序列互转">序列互转</h1><h2 id="任意两种序列-转-其他">任意两种序列 转 其他</h2><p>若题目只要求某个遍历序列，可以在建树的过程中，直接生成序列。</p><p>先 + 中 转 后</p><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805345078067200&amp;page=1">1138Postorder Traversal - PAT (Advanced Level) Practice (pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPost</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel &gt; prer) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> i = inl;<br><span class="hljs-keyword">while</span>(i &lt;= inr &amp;&amp; in[i] != pre[prel]) i++;<br><span class="hljs-built_in">getPost</span>(prel<span class="hljs-number">+1</span>, prel + (i-inl), inl, i<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">getPost</span>(prel+(i-inl)<span class="hljs-number">+1</span>, prer, i<span class="hljs-number">+1</span>, inr);<br>post.<span class="hljs-built_in">push_back</span>(pre[prel]);<br>&#125;<br></code></pre></td></tr></table></figure><p>先+后 转 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getIn</span><span class="hljs-params">(<span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> postl, <span class="hljs-type">int</span> postr)</span></span>&#123;<br><span class="hljs-keyword">if</span>(prel == prer)&#123;<br>in.<span class="hljs-built_in">push_back</span>(pre[prel]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(pre[prel] == post[postr])&#123;<br><span class="hljs-type">int</span> i = prel<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= prer &amp;&amp; pre[i] != post[postr<span class="hljs-number">-1</span>]) i++;<br><span class="hljs-keyword">if</span>(i - prel &gt; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">getIn</span>(prel<span class="hljs-number">+1</span>, i<span class="hljs-number">-1</span>, postl, postl+(i-prel<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>Unique = <span class="hljs-literal">false</span>;<br>&#125;<br>in.<span class="hljs-built_in">push_back</span>(pre[prel]);<br><span class="hljs-built_in">getIn</span>(i, prer, postl+(i-prel<span class="hljs-number">-1</span>), postr<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="先中后序-转-层序完全二叉树">先/中/后序 转层序（完全二叉树）</h2><blockquote><p>完全二叉树(Complete Binary Tree)：设二叉树的深度为h，除第 h层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h层所有的结点都连续集中在最左边，这就是完全二叉树。</p><p>满二叉树(Full binary tree)：各层 (1~h-1)的结点数都达到最大个数的二叉树。所有节点的度要么为0，要么为2，且所有的叶子节点都在最后一层。</p></blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805407749357568&amp;page=0">1064Complete Binary Search Tree - PAT (Advanced Level) Practice(pintia.cn)</a>、</p><p>对于一颗完全二叉树/满二叉树而言，按层序从上到下，从左到右地标注（root= 0），可以得到任意一个节点r，其左孩子为r*2+1，右孩子为 r*2 +2。可以根据这个性质，将先/中/后序序列转为层序。</p><p>这里以中序转层序（节点数为n）为例，函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inToLayer</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r &gt;= n) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">inToLayer</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>layer[r] = in[idx++];<br><span class="hljs-built_in">inToLayer</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="层序-转-先中后序完全二叉树">层序 转先/中/后序（完全二叉树）</h2><p>以 层序 转 后序为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postTra</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r &gt;= n) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">postTra</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">postTra</span>(r*<span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>post.<span class="hljs-built_in">push_back</span>(layer[r]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="求二叉树的深度">求二叉树的深度</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getDepth</span>(p-&gt;l),<span class="hljs-built_in">getDepth</span>(p-&gt;r));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="求二叉树的镜像">求二叉树的镜像</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mirror</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(p-&gt;l != <span class="hljs-literal">nullptr</span> || p-&gt;r != <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-built_in">swap</span>(p-&gt;l, p-&gt;r);<br><span class="hljs-built_in">mirror</span>(p-&gt;l);<br><span class="hljs-built_in">mirror</span>(p-&gt;r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉树">平衡二叉树</h1><blockquote><p>定义：一棵空树 或 左右子树的高度差不超过1且左右子树也是平衡树</p></blockquote><p>输入一颗二叉树，判断是否为平衡二叉树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBanlance</span><span class="hljs-params">(node * p, <span class="hljs-type">int</span> &amp; depth)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>)&#123;<br>depth = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">int</span> ld,rd;<br>    <span class="hljs-comment">//先判断左右子树是否平衡，再判断当前子树，避免重复计算深度</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBanlance</span>(p-&gt;l,ld) &amp;&amp; <span class="hljs-built_in">isBanlance</span>(p-&gt;r,rd))&#123;<br><span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(ld - rd);<br><span class="hljs-keyword">if</span>(diff &lt;= <span class="hljs-number">1</span>)&#123;<br>depth = <span class="hljs-built_in">max</span>(ld,rd) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对称二叉树">对称二叉树</h1><blockquote><p>定义：一颗二叉树，所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。</p><p>直观理解：从根节点画一条纵轴，左右子树完全沿轴对称</p></blockquote><p>核心思想：左右子树对称 &lt;=&gt; 左右根节点相等 &amp;&amp;左子树的左子树和右子树的右子树对称 &amp;&amp;左子树的右子树和右子树的左子树对称</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSym</span><span class="hljs-params">(node * le, node * ri)</span></span>&#123;<br><span class="hljs-keyword">if</span>(le == <span class="hljs-literal">nullptr</span> &amp;&amp; ri == <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(le != <span class="hljs-literal">nullptr</span> &amp;&amp; ri != <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-built_in">return</span> (le-&gt;x == ri-&gt;x) &amp;&amp; <span class="hljs-built_in">isSym</span>(le-&gt;l,ri-&gt;r) &amp;&amp; <span class="hljs-built_in">isSym</span>(le-&gt;r,ri-&gt;l);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTreeSym</span><span class="hljs-params">(node * p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">isSym</span>(p-&gt;l, p-&gt;r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完全二叉树">完全二叉树</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805359372255232&amp;page=1">1110Complete Binary Tree - PAT (Advanced Level) Practice (pintia.cn)</a></p><blockquote><p>完全二叉树(Complete Binary Tree)：设二叉树的深度为h，除第 h层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h层所有的结点都连续集中在最左边，这就是完全二叉树。</p></blockquote><p>一颗树是完全二叉树的充要条件是：层序遍历的最大下标等于 n-1 (root ==0)</p><blockquote><p>root == 1时，层序遍历的最大下标等于 n</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>q.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">0</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>().first;<br><span class="hljs-type">int</span> d = q.<span class="hljs-built_in">front</span>().second;<br>q.<span class="hljs-built_in">pop</span>();<br>maxIdx = <span class="hljs-built_in">max</span>(maxIdx,d);<br><span class="hljs-keyword">if</span>(nodes[f].l != <span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(&#123;nodes[f].l,<span class="hljs-number">2</span>*d + <span class="hljs-number">1</span>&#125;);<br><span class="hljs-keyword">if</span>(nodes[f].r != <span class="hljs-number">-1</span>) q.<span class="hljs-built_in">push</span>(&#123;nodes[f].r,<span class="hljs-number">2</span>*d + <span class="hljs-number">2</span>&#125;);<br>&#125;<br><span class="hljs-keyword">return</span> maxIdx == n<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树bst">二叉搜索树BST</h1><blockquote><p>二叉搜索树(Binary SearchTree)：它是一棵空树，或者是具有下列性质的二叉树：</p><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>左、右子树也分别为二叉排序树。</p></blockquote><p>一个重要性质：二叉搜索树的中序遍历序列是有序上升的。（很多题目中可利用该性质将BST当成普通二叉树来做）</p><h2 id="bst建树">BST建树</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805355987451904&amp;page=1">1115Counting Nodes in a Binary Search Tree - PAT (Advanced Level) Practice(pintia.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node * <span class="hljs-title">insert</span><span class="hljs-params">(node * p, <span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>)&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt;= p-&gt;val)&#123; <span class="hljs-comment">//根据不同题目，这里可能是x &gt; p-&gt;val</span><br>p-&gt;r = <span class="hljs-built_in">insert</span>(p-&gt;r, x);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>p-&gt;l = <span class="hljs-built_in">insert</span>(p-&gt;l, x);<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node * root = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    cin&gt;&gt;v[i]; <span class="hljs-comment">//按固定顺序插入的二叉搜索树是唯一的。</span><br>    root = <span class="hljs-built_in">insert</span>(root, v[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bst上lca">BST上LCA</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805343727501312&amp;page=1">1143Lowest Common Ancestor - PAT (Advanced Level) Practice(pintia.cn)</a></p><p>BST上任意两点的最近公共祖先满足条件：<span class="math inline">\(min(u,v) &lt;= a &lt;= max(u,v)\)</span></p><p>满足这个条件的点是唯一的，是充要条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//沿先序遍历路径找LCA</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++)&#123;<br>    <span class="hljs-comment">//pre[i] &gt;= min(u,v) &amp;&amp; pre[i] &lt;= max(u,v)</span><br>    <span class="hljs-keyword">if</span>((pre[i] &gt;= u &amp;&amp; pre[i] &lt;= v) || (pre[i] &gt;= v &amp;&amp; pre[i] &lt;= u))&#123;<br>        a = pre[i];<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断某个先序序列是否来自bst">判断某个先序序列是否来自BST</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805440976633856&amp;page=0">1043Is It a Binary Search Tree - PAT (Advanced Level) Practice(pintia.cn)</a></p><p>法1：按该先序序列逐个插入节点，建立BST，与正确的先序序列比较。</p><p>法2：直接在先序序列上判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对于二叉搜索树的先序遍历的序列而言</span><br><span class="hljs-comment">//头节点一定为根节点，而左右子树的根，在该序列中的距离一定为1</span><br><span class="hljs-comment">//由此规律可构造的平衡树的节点个数一定是n个</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPost</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> i = l + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> j = r;<br><span class="hljs-keyword">if</span>(!isMirror)&#123;<br><span class="hljs-keyword">while</span>(i &lt;= r &amp;&amp; pre[i] &lt; pre[l]) i++;<span class="hljs-comment">//第一个 &gt;= root的节点</span><br><span class="hljs-keyword">while</span>(j &gt; l &amp;&amp; pre[j] &gt;= pre[l]) j--;<span class="hljs-comment">//最后一个 &lt; root的节点</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">while</span>(i &lt;= r &amp;&amp; pre[i] &gt;= pre[l]) i++;<span class="hljs-comment">//第一个 &lt; root的节点</span><br><span class="hljs-keyword">while</span>(j &gt; l &amp;&amp; pre[j] &lt; pre[l]) j--;<span class="hljs-comment">//最后一个 &gt;= root的节点</span><br>&#125;<br><span class="hljs-keyword">if</span>(i - j != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">getPost</span>(l<span class="hljs-number">+1</span>, j);<br><span class="hljs-built_in">getPost</span>(i, r);<br>post.<span class="hljs-built_in">push_back</span>(pre[l]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉搜索树avl">平衡二叉搜索树AVL</h1><blockquote><p>AVL树的名字来源于它的发明作者G.M.<strong>A</strong>delson-<strong>V</strong>elsky 和 E.M.<strong>L</strong>andis。</p><p>AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree,简称平衡二叉树）</p><p>将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(BalanceFactor)。</p></blockquote><p>每次查找AVL树中的元素，耗时O（logN）</p><p>AVL树满足以下两个条件：</p><blockquote><p>条件一：它必须是二叉查找树。</p><p>条件二：每个节点的左子树和右子树的高度差至多为1。</p></blockquote><h2 id="avl建树">AVL建树</h2><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805351302414336&amp;page=1">1123Is It a Complete AVL Tree - PAT (Advanced Level) Practice(pintia.cn)</a></p><h1 id="中缀表达式">中缀表达式</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/exam/problems/type/7?problemSetProblemId=994805347921805312&amp;page=1">1130Infix Expression - PAT (Advanced Level) Practice (pintia.cn)</a></p><p><img src="/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/4d1c4a98-33cc-45ff-820f-c548845681ba.jpeg" alt="infix1.JPG" align="left"></p><blockquote><p>二叉运算树的中序遍历，恰是一个中缀表达式</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">inTra</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br><span class="hljs-keyword">if</span>(p == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>string le = <span class="hljs-built_in">inTra</span>(tree[p].l);<br>string ri = <span class="hljs-built_in">inTra</span>(tree[p].r);<br><span class="hljs-keyword">if</span>((le != <span class="hljs-string">&quot;&quot;</span> || ri != <span class="hljs-string">&quot;&quot;</span>) &amp;&amp; p != root)&#123; <span class="hljs-comment">//若非根节点p，存在孩子，需要加上括号</span><br>le = <span class="hljs-string">&quot;(&quot;</span> + le;<br>ri = ri + <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> le + tree[p].s + ri;<br>&#125;<br>cout&lt;&lt;<span class="hljs-built_in">inTra</span>(root);<br></code></pre></td></tr></table></figure><h1 id="最优二叉查找树">最优二叉查找树</h1><p><a href="https://pintia.cn/problem-sets/1844196541682872320/exam/problems/type/7?problemSetProblemId=1844196541703843844&amp;page=0">7-5最优二叉查找树 - 练习3-2 (pintia.cn)</a></p><p>假设 一颗 查找树 上的每个点（深度为 c）都有一个查找概率p，那么我们可以得到查找次数的期望： <span class="math display">\[E(c) = \sum_{i}^{n} c_i*p_i\]</span> 最优二叉查找树 指的是 使得查找次数期望最小 的 二叉查找树。</p><p>设C（i，j）为以i为左端点，j为右端点的二叉树的查找期望代价。</p><p>我们可以得到如下的状态转移方程： <span class="math display">\[\begin{cases}C[i][j] = 0 &amp; i &gt; j \\C[i][j] = P_i &amp; i = j \\C[i][j] = min( C[i][k-1] + C[k+1][j] + \sum_{i}^{j} P ) ) &amp; else \\\end{cases}\]</span>在得到c[i][j]数组的同时，我们需要可以记录一下，取最小值时候的根k，得到R[i][j]数组，以构造查找树。</p><p>动态规划</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123; <span class="hljs-comment">//处理坐标为x，y的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-comment">// int root = 0;</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x ; i &lt;= y ; i ++)&#123;<br>sum += c[i][i];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = x ; k &lt;= y ; k ++)&#123;<br><span class="hljs-keyword">if</span>(sum + c[x][k<span class="hljs-number">-1</span>] + c[k<span class="hljs-number">+1</span>][y] &lt; res)&#123;<br>res = sum + c[x][k<span class="hljs-number">-1</span>] + c[k<span class="hljs-number">+1</span>][y];<br><span class="hljs-comment">// root = k;</span><br>&#125;<br>&#125;<br>c[x][y] = res;<br><span class="hljs-comment">// r[x][y] = root;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>按主对角线方向进行dp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; i ++)&#123;<br>    <span class="hljs-type">double</span> p;cin&gt;&gt;p;<br>    c[i][i] = p*<span class="hljs-number">10000</span>; <span class="hljs-comment">// 这题要求输出结果x10000后的数值</span><br>    r[i][i] = i;<br>&#125;<br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>,y = <span class="hljs-number">2</span>,cnt = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>( !( x == <span class="hljs-number">1</span> &amp;&amp; y == n) )&#123;<br>    <span class="hljs-built_in">dp</span>(x, y);<br>    x++;y++;<br>    <span class="hljs-keyword">if</span>(y &gt; n)&#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = ++cnt;<br>    &#125;<br>&#125;<span class="hljs-built_in">dp</span>(x, y);<br>cout&lt;&lt;c[<span class="hljs-number">1</span>][n];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>康托展开</title>
    <link href="/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    <url>/algorithm/%E6%9C%AA%E5%88%86%E7%B1%BB/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="康托展开">康托展开</h1><p>康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。<span class="math display">\[X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[1]*0!\]</span> 其中, a[i]为整数，并且0 &lt;= a[i] &lt;= i, 0 &lt;= i &lt; n,表示当前未出现的的元素中排第几个，这就是康托展开</p><p>举个例子说明。 在（1，2，3，4，5）5个数的排列组合中，计算34152的康托展开值。</p><p>首位是3，则小于3的数有两个，为1和2，a[5]=2，则首位小于3的所有排列组合为a[5]<em>(5-1)!第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此a[4]=2第三位是1，则在其之后小于1的数有0个，所以a[3]=0第四位是5，则在其之后小于5的数有1个，为2，所以a[2]=1最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0根据公式： X = 2 </em> 4! + 2 * 3! + 0 * 2! + 1 * 1! + 0 * 0! = 2 * 24 +2 * 6 + 1 = 61 所以比 34152 小的组合有61个，即34152是排第62。</p><h1 id="八数码难题bfs剪枝">八数码难题（BFS剪枝）</h1><p><a href="https://www.luogu.com.cn/problem/P1379">P1379 八数码难题 -洛谷 | 计算机科学教育新生态</a></p><p>在 3×3 的棋盘上，摆有八个棋子，每个棋子上标有 1 至 8的某一数字。棋盘中留有一个空格，空格用 0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局和目标布局，找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 状态结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> x,y,steps;<br><span class="hljs-type">int</span> ctVal;<br><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br>&#125;;<br><br><span class="hljs-comment">// 0-10的阶乘</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> f[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>,<span class="hljs-number">120</span>,<span class="hljs-number">720</span>,<span class="hljs-number">5040</span>,<span class="hljs-number">40320</span>,<span class="hljs-number">362880</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> dirx[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> diry[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-comment">// 某个排列是否出现过</span><br><span class="hljs-type">bool</span> visct[<span class="hljs-number">10000000</span>];<br><span class="hljs-comment">// 起点和终点</span><br>string s,t;<br><span class="hljs-type">int</span> tt;<br><br><span class="hljs-comment">// 康托展开</span><br><span class="hljs-comment">// 即将 某个排列 映射 到 某个数字（第几个排列）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cantor</span><span class="hljs-params">(string s)</span></span>&#123;<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-literal">false</span>,<span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cnt = s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; s.<span class="hljs-built_in">length</span>() ; i ++)&#123;<br><span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>vis[s[i]-<span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; s[i] - <span class="hljs-string">&#x27;0&#x27;</span> ; j ++)&#123;<br><span class="hljs-keyword">if</span>(!vis[j]) low++;<br>&#125;<br>res += f[cnt--]*low;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>queue&lt;node&gt; q;<br><span class="hljs-comment">// 初始化起点</span><br>node temp;<br>temp.steps = <span class="hljs-number">0</span>;<br>temp.ctVal = <span class="hljs-built_in">cantor</span>(s);<br>visct[temp.ctVal] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">3</span> ; j ++)&#123;<br>temp.a[i][j] = s[(i<span class="hljs-number">-1</span>)*<span class="hljs-number">3</span> + (j<span class="hljs-number">-1</span>)] - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">if</span>(s[(i<span class="hljs-number">-1</span>)*<span class="hljs-number">3</span> + (j<span class="hljs-number">-1</span>)] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>temp.x = i;<br>temp.y = j;<br>&#125;<br>&#125;<br>&#125;<br>q.<span class="hljs-built_in">push</span>(temp);<br><br>tt = <span class="hljs-built_in">cantor</span>(<span class="hljs-string">&quot;123804765&quot;</span>);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>node fr = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 如果找到，退出</span><br><span class="hljs-keyword">if</span>(fr.ctVal == tt)&#123;<br>cout&lt;&lt;fr.steps;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>node nex; string str;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">4</span> ; i ++)&#123;<br>nex.x = fr.x + dirx[i];<br>nex.y = fr.y + diry[i];<br><span class="hljs-keyword">if</span>(!(nex.x &gt;= <span class="hljs-number">1</span> &amp;&amp; nex.x &lt;= <span class="hljs-number">3</span> &amp;&amp; nex.y &gt;= <span class="hljs-number">1</span> &amp;&amp; nex.y &lt;= <span class="hljs-number">3</span>)) <span class="hljs-keyword">continue</span>;<br>nex.steps = fr.steps + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">memcpy</span>(nex.a,fr.a,<span class="hljs-built_in">sizeof</span>(nex.a));<br><span class="hljs-built_in">swap</span>(nex.a[fr.x][fr.y],nex.a[nex.x][nex.y]);<br>str = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">3</span> ; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= <span class="hljs-number">3</span> ; j ++)&#123;<br>str += <span class="hljs-built_in">char</span>(nex.a[i][j] + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;<br>nex.ctVal = <span class="hljs-built_in">cantor</span>(str);<br><span class="hljs-comment">// 如果康托展开值重复，说明之前出现过更优解</span><br><span class="hljs-keyword">if</span>(!visct[nex.ctVal])&#123;<br>q.<span class="hljs-built_in">push</span>(nex);<br>visct[nex.ctVal] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>cin&gt;&gt;s;<br><span class="hljs-built_in">bfs</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>全排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>质数筛</title>
    <link href="/algorithm/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0%E7%AD%9B/"/>
    <url>/algorithm/%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="枚举法">枚举法</h1><blockquote><p>暴力枚举法， 一般在查询很少的时候使用</p></blockquote><p>判断一个数 n 是否为质数的时间复杂度为<span class="math inline">\(O(\sqrt{n})\)</span></p><p>若询问m次，时间复杂度为 <span class="math inline">\(O(m\sqrt{n})\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i*i &lt;= x ; i ++)&#123;<br><span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="埃式筛法">埃式筛法</h1><blockquote><p>Eratosthenes 筛法（埃拉托斯特尼筛法，简称埃氏筛法。</p></blockquote><p>建立一个&lt;=n的<span class="math inline">\(O(1)\)</span>查询表的时间复杂度是<span class="math inline">\(O(nloglogn)\)</span></p><p>原理：对于任意一个大于1的正整数，那么它的x倍就是非素数。如果从小到大遍历每个数，同时把当前数的所有倍数记为非素数，那么运行结束的时候没有被标记的数就是素数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">bool</span>&gt; isPrime;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>isPrime.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>, <span class="hljs-literal">true</span>);<br>isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123; <br><span class="hljs-keyword">if</span>(isPrime[i])&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i*i ; j &lt;= n ; j += i)&#123;<br>                <span class="hljs-comment">// 注意这里可以从i*i开始,而不是2*i</span><br>                <span class="hljs-comment">// 因为所有因数为 [2, i-1] 的乘积都已经被计算过；</span><br>isPrime[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="欧拉筛法">欧拉筛法</h1><blockquote><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记。</p><p>而欧拉筛法保证了一个合数只被最小的素因数标记，达到了线性的时间复杂度</p></blockquote><p>建立一个&lt;=n的<span class="math inline">\(O(1)\)</span>查询表的时间复杂度是<span class="math inline">\(O(n)\)</span></p><p>原理：从小到大遍历每个数，记录&lt;= i的非素数，将它们与 i的乘积（&lt;=n）标记为非素数，若i % it ==0，则直接break，因为后面还会有更大倍数标记这个乘积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">bool</span>&gt; isPrime;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>isPrime.<span class="hljs-built_in">resize</span>(n<span class="hljs-number">+1</span>, <span class="hljs-literal">true</span>);<br>isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    vector&lt;<span class="hljs-type">int</span> &gt; pri;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ; i &lt;= n ; i ++)&#123;<br><span class="hljs-keyword">if</span>(isPrime[i])&#123;<br>pri.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : pri)&#123;<br><span class="hljs-keyword">if</span>(i*it &gt; n) <span class="hljs-keyword">break</span>;<br>isPrime[i*it] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(i % it == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//关键</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
